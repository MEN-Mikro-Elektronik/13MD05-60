<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>MEN - MSCAN API - Main Page</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Language" content="en, english">
<meta name="Copyright" content="All material copyright MEN Mikro Elektronik GmbH">
<link href="men_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
	<!-- Titel -->
	<img src="menlogo.gif" alt="MEN" style="float: left; height: 103px; width: 155px; margin: 0px;"></a>
	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">MSCAN API &nbsp; for MSCAN fileset 2.19</h1>
	<h3>Main Page</h3>
</div>

<div class="left_to_right">
<!-- Hauptteil -->
	<div class="main">
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindexHL" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>MSCAN API Documentation</h1>
<p>
<h3 align="center">for MSCAN fileset 2.19 </h3>This document describes the features of the MSCAN driver API as well as most of the features of the underlying CAN chip (either Motorola Scalable CAN or MEN Boromir).<h2><a name="FuncOv"></a>
Functional Overview</h2>
The main features of MSCAN driver for MDIS5 is and it's API are:<ul>
<li>operates on direct CAN (layer 2) frames.</li><li>permits access to all features of the MSCAN CAN controller.</li><li>supports CAN Specification 2.0, standard and extended data and remote frames</li><li>programmable global acceptance filter (mask and code), standard or extended</li><li>10 message objects with FIFOs (provided by driver)</li><li>programmable acceptance filter for each RX object</li></ul>
<p>
The package consists of an MDIS5 low-level driver and a C library which provides an Application Programming Interface - "MSCAN_API" - between the application and the driver. The driver itself does not implement any CAN protocol such as CANopen or DeviceNet. However it provides message queues for errors and for receive and transmit objects.<h3><a name="Diffs"></a>
Differences to SJA1000 API</h3>
The MSCAN API is similar, but not identical to the API provided by the SJA1000 MDIS5 driver.<p>
The differences are:<ul>
<li>CAN frames are exchanged by means of <a class="el" href="structMSCAN__FRAME.html">MSCAN_FRAME</a> structures, not with single parameters to the read/write routines.</li><li>Additional API functions to exchange more than one can frame with the driver FIFOs for higher performance: <a class="el" href="mscan__api_8c.html#a10">mscan_read_nmsg()</a> and <a class="el" href="mscan__api_8c.html#a12">mscan_write_nmsg()</a>.</li><li>Well defined priority between transmit FIFOs, see <a class="el" href="index.html#Transm">Transmitting Frames</a></li><li>Different setup of receive filters, see <a class="el" href="index.html#ConfFilt">Configure Filters</a></li><li>Different parameters to <a class="el" href="mscan__api_8c.html#a6">mscan_config_msg()</a></li><li>Additional function to control bus timing directly: <a class="el" href="mscan__api_8c.html#a8">mscan_set_bustiming()</a>.</li><li>RTR receive handling different: For MSCAN, the application must handle received remote transmit requests. SJA1000 implementation seems to be broken.</li><li>Error codes renamed from <code>CPL_xxx</code> to <code>MSCAN_xxx</code>.</li><li>sja1000_read_register, sja1000_read_counter, sja1000_read_configuration, sja1000_read_alcr, sja1000_read_eccr not implemented since they are SJA1000 specific.</li><li>Additional call <a class="el" href="mscan__api_8c.html#a25">mscan_error_counters()</a> to read Rx/Tx error counters</li><li>Additional call <a class="el" href="mscan__api_8c.html#a24">mscan_node_status()</a> to get current node status</li><li>Additional filtering for individual IDs (as supported by sp82c200 driver)</li></ul>
<h3><a name="FIFOs"></a>
Message Objects and FIFOs</h3>
The driver provides up to 10 message object to the user, numbered from 0 to 9. Each object has it's own FIFO.<p>
Message object 0 is the error FIFO and is maintained by the driver to buffer error events on the CAN bus. It can be configured for receive only.<p>
Message objects 1..9 can be configured for receive or transmit, but not for both.<p>
Each message object's FIFO buffers a configurable number of entries (frames). API function <a class="el" href="mscan__api_8h.html#a40">mscan_config_msg</a> configures any message object.<p>
Message objects configured to receive frames only receive those CAN frames that pass through the global ID filter <em>and</em> the object's local filter.<p>
Transmit message objects don't use the ID filters. Typically you will create only one transmit message object. However, multiple transmit message objects can be used to control the transmit priority of the frames to be sent, see <a class="el" href="index.html#Transm">Transmitting Frames</a>.<p>
It is possible to install a signal that is sent to the application when a new frame arrives on a message object or when a frame has been transmitted. For each message object a different signal can be installed, but it is also possible to install the same signal for all message objects. You can install signals via <a class="el" href="mscan__api_8h.html#a48">mscan_set_rcvsig</a> or <a class="el" href="mscan__api_8h.html#a49">mscan_set_xmtsig</a>.<h3><a name="InitSteps"></a>
Initialisation Steps</h3>
You should initialize the CAN driver by performing the following sequence of API calls:<p>
<ul>
<li>Open a path to the device using <a class="el" href="mscan__api_8h.html#a37">mscan_init</a>.</li><li>Set the CAN bus bit rate through <a class="el" href="mscan__api_8h.html#a41">mscan_set_bitrate</a> or <a class="el" href="mscan__api_8h.html#a42">mscan_set_bustiming</a>.</li><li>Set the global acceptance filter using <a class="el" href="mscan__api_8h.html#a39">mscan_set_filter</a>.</li><li>Configure the error message object (object 0) using <a class="el" href="mscan__api_8h.html#a40">mscan_config_msg</a>.</li><li>Configure the RX and TX message objects as required via <a class="el" href="mscan__api_8h.html#a40">mscan_config_msg</a>.</li><li>Install signals for message objects using <a class="el" href="mscan__api_8h.html#a48">mscan_set_rcvsig</a> or <a class="el" href="mscan__api_8h.html#a49">mscan_set_xmtsig</a>.</li></ul>
<p>
Now frames can be transmitted to or received from the CAN bus.<h3><a name="Recv"></a>
Receiving Frames</h3>
Once bus activity has been enabled and message objects have been configured, the CAN controller monitors the CAN frames on the bus. Whenever a frame on the bus passes through the global filter and matches the identifier of one of the configured message objects (see <a class="el" href="index.html#ConfFilt">Configure Filters</a>), the driver puts the frame into the corresponding receive FIFO. If multiple local filters match the receive frame, the message object with the lowest number will receive the frame.<p>
If installed, a signal is sent to the application to signify the arrival of a new frame.<h4><a name="QOvr"></a>
FIFO Overrun Errors</h4>
If the buffer FIFO was already full, the new frame is discarded and a MSCAN_QOVERRUN error entry is put into the error FIFO. Additionally a signal is sent to the application if a signal was installed for the error object.<h4><a name="RecvRtr"></a>
Receiving RTR Frames</h4>
When an RTR frame is received (and it matches the global and local filter), the frame is written into the corresponding object’s receive FIFO. Application can detect the receiption of an RTR frame by looking at the <em>flags</em> field of the <a class="el" href="structMSCAN__FRAME.html">MSCAN_FRAME</a> structure.<h4><a name="ReadMsg"></a>
Reading Received Frames</h4>
The application can read received frames of a single message object by calling <a class="el" href="mscan__api_8h.html#a43">mscan_read_msg</a> or <a class="el" href="mscan__api_8h.html#a44">mscan_read_nmsg</a>. These functions read frame(s) from the object’s FIFO and returns the received data.<p>
<a class="el" href="mscan__api_8h.html#a43">mscan_read_msg</a> can be blocking or non-blocking if no frame is available. The timeout parameter specifies how long to wait until a frame arrives. <a class="el" href="mscan__api_8h.html#a44">mscan_read_nmsg</a> is always non-blocking.<p>
The number of entries in the receive FIFO can be determined at any time by calling <a class="el" href="mscan__api_8h.html#a52">mscan_queue_status</a>. The FIFO can be cleared using <a class="el" href="mscan__api_8h.html#a53">mscan_queue_clear</a>.<p>
It is possible that different objects are processed by different processes. For example, one process can wait for frames on object 1, while a second process can wait for frames on object 2.<h4><a name="RxUseSigs"></a>
Using Signals for Receive</h4>
The application can use <a class="el" href="mscan__api_8h.html#a48">mscan_set_rcvsig</a> to install a signal that is sent whenever a new frame is put into the object’s receive FIFO. A signal for a specific object can be installed by a single process only. Each frame causes one signal to be sent to the application. Sending of signals can be cleared using <a class="el" href="mscan__api_8h.html#a50">mscan_clr_rcvsig</a>.<h4><a name="ConfFilt"></a>
Configure Filters</h4>
MSCAN driver supports three different types of filters:<ul>
<li>two global filters</li><li>local filter using <em>mask</em> and <em>code</em> for each Rx message object</li><li>additional local filtering for 11-bit IDs using an acceptance field</li></ul>
<p>
The global filtering is done in hardware and can be used to reduce the load of the CPU. If a received frame's ID does not match the global filter, it is discarded.<p>
The local, message object related filters are implemented in software. They are used by the driver to determine the local object number to which the received frame belongs to. If the received frame's ID did not match any object's filter, the received frame is discarded. When received frame's ID matches more than one object's filter, the lowest numbered object wins.<p>
Both global and local filters have the same format (with the exception of <em>accField</em>, which is used for local filters only); they are specified by means of the <a class="el" href="structMSCAN__FILTER.html">MSCAN_FILTER</a> structure. Each filter can be set to either standard <em>or</em> extended identifiers, but not for both (i.e. a filter that is programmed for extended IDs will filter out all standard IDs).<p>
Since there are two global filters available, one can be set for standard IDs and the other for extended IDs.<p>
The filters can also be programmed to mask or compare the RTR bit of received frames.<p>
Each filter has an "Acceptance Code" and an "Acceptance Mask". These are 11-bit numbers for standard IDs and a 29-bit numbers for extended IDs. The filter's acceptance mask can be used to mask non-relevant bits of the identifier. For example, if filter acceptance code is set to 0x0002 and the acceptance mask is set to 0x0001, filter passes frames with ID=2 and ID=3, because bit 0 of the ID is masked (ignored).<p>
If only one receive object is defined, the global acceptance filter is sufficient (provided that you don't want to mix standard and extended frames). The local filter can be disabled by setting the local acceptance mask to <code>0xffffffff</code> (all bits to 1). In this case, all frames whose identifiers pass the global acceptance filter will be permitted for the receive object.<p>
<b>Acceptance-Field</b> <p>
For standard, 11-bit identifiers, there is an additional local filter, that can be used to filter out individual IDs, not only groups, see <a class="el" href="structMSCAN__FILTER.html#o4">MSCAN_FILTER::accField</a>. This filtering is not available for extended IDs. Note that this filter is applied <em>after</em> the global and local filter masks.<p>
For example, to setup a filter that let IDs 3, 10, 22 and 99 pass through, use the following code:<p>
<div class="fragment"><pre>      <a class="code" href="structMSCAN__FILTER.html">MSCAN_FILTER</a> flt;

      flt.<a class="code" href="structMSCAN__FILTER.html#o0">code</a> = 0x00000000;
      flt.<a class="code" href="structMSCAN__FILTER.html#o1">mask</a> = 0xFFFFFFFF;
      flt.<a class="code" href="structMSCAN__FILTER.html#o2">cflags</a> = 0;
      flt.<a class="code" href="structMSCAN__FILTER.html#o3">mflags</a> = <a class="code" href="mscan__api_8h.html#a66a33">MSCAN_USE_ACCFIELD</a>;
      
      memset( &amp;flt.<a class="code" href="structMSCAN__FILTER.html#o4">accField</a>, 0, <span class="keyword">sizeof</span>(flt.<a class="code" href="structMSCAN__FILTER.html#o4">accField</a>) );
      <a class="code" href="mscan__api_8h.html#a1">MSCAN_ACCFIELD_SET</a>( flt.<a class="code" href="structMSCAN__FILTER.html#o4">accField</a>, 3 );
      <a class="code" href="mscan__api_8h.html#a1">MSCAN_ACCFIELD_SET</a>( flt.<a class="code" href="structMSCAN__FILTER.html#o4">accField</a>, 10 );
      <a class="code" href="mscan__api_8h.html#a1">MSCAN_ACCFIELD_SET</a>( flt.<a class="code" href="structMSCAN__FILTER.html#o4">accField</a>, 22 );
      <a class="code" href="mscan__api_8h.html#a1">MSCAN_ACCFIELD_SET</a>( flt.<a class="code" href="structMSCAN__FILTER.html#o4">accField</a>, 99 );
</pre></div><p>
The filter can be configured through commands <a class="el" href="mscan__api_8h.html#a39">mscan_set_filter</a> (global filter) and <a class="el" href="mscan__api_8h.html#a40">mscan_config_msg</a> (local filter).<h3><a name="Transm"></a>
Transmitting Frames</h3>
Once message objects have been configured and bus activity has been enabled, the CAN controller is ready to transmit objects. The application can send CAN frames to a transmit object using <a class="el" href="mscan__api_8h.html#a45">mscan_write_msg</a> or <a class="el" href="mscan__api_8h.html#a46">mscan_write_nmsg</a>.<p>
The driver puts the frame(s) into its transmit FIFO. If a free CAN transmit buffer is available, the driver schedules the the frame in front of the FIFO for transmission.<p>
The frames within each FIFO are sent over the CAN bus in the same order as they have been put into the transmit FIFO; independently of the CAN frame's ID. I.e. the frame that has been put first into the FIFO is the first frame sent over the CAN bus.<p>
However, you can create multiple transmit objects. These objects have an implicit priority against eachother, based on their object number. The lower the object number, the higher the priority. For example, if you create two transmit objects (let's say 3 and 4), frames in transmit object #3 have priority over frames in transmit object #4. Frames in transmit object #4 are not sent before all frames of transmit object #3 have been sent.<p>
When the frame has been transmitted over the bus, the driver fetches the next frame from the lowest numbered available transmit FIFO and puts it into the CAN controller.<p>
<a class="el" href="mscan__api_8h.html#a45">mscan_write_msg</a> can be blocking or non-blocking if no space is available in the transmit FIFO. The timeout parameter specifies how long to wait until space is available again. <a class="el" href="mscan__api_8h.html#a46">mscan_write_nmsg</a> is always non-blocking.<p>
The number of <em>free</em> entries in the transmit FIFO can be determined at any time by calling <a class="el" href="mscan__api_8h.html#a52">mscan_queue_status</a>.<p>
The FIFO can be cleared using <a class="el" href="mscan__api_8h.html#a53">mscan_queue_clear</a>. The <em>txabort</em> parameter can be used to abort any pending transmission that has not been competed yet. (The txabort feature is not yet implemented!).<h4><a name="TxUseSigs"></a>
Using Signals for Transmit</h4>
Every time the driver has successfully sent a frame over the CAN bus, it can inform the application by sending a signal. The application must call <a class="el" href="mscan__api_8h.html#a49">mscan_set_xmtsig</a> on the corresponding Tx message object. Note that the signal is sent for <em>every</em> transmitted frame. Signals can be disabled by using <a class="el" href="mscan__api_8h.html#a51">mscan_clr_xmtsig</a>.<h4><a name="SendRtr"></a>
Sending RTR Frames</h4>
The application can force a remote CAN bus station to send a specific object by sending a remote transfer request (RTR) frame. This can be done using <a class="el" href="mscan__api_8h.html#a56">mscan_rtr</a>, <a class="el" href="mscan__api_8h.html#a45">mscan_write_msg</a> or <a class="el" href="mscan__api_8h.html#a46">mscan_write_nmsg</a>.<h3><a name="ErrHandl"></a>
Handling of CAN Errors</h3>
As noted above, the driver maintains a special global FIFO that holds CAN errors or driver internal events. The error FIFO has the special object number 0.<p>
Note that the error FIFO must be configured like any other message object before it can be used.<p>
Whenever the state of the CAN controller changes or when a driver internal error occurs, the driver puts a new error entry into the error FIFO. Each entry consists of an error code and the related message objects. If the error is global for all message objects, the "related message object" number is 0.<p>
The following errors may occur:<p>
<ul>
<li><code>MSCAN_BUSOFF_SET</code>: Controller now in busoff state</li><li><code>MSCAN_BUSOFF_CLR</code>: Controller left busoff state</li><li><code>MSCAN_WARN_SET</code>: Controller has entered error passive state</li><li><code>MSCAN_WARN_CLR</code>: Controller has left error passive state</li><li><code>MSCAN_QOVERRUN</code>: Object’s receiver FIFO overflowed</li><li><code>MSCAN_DATA_OVERRUN</code>: Data overrun interrupt occurred (hardware receive FIFO full)</li></ul>
<p>
The application can read from the error FIFO by calling <a class="el" href="mscan__api_8h.html#a47">mscan_read_error</a>. This function returns the next entry from the error FIFO. This function is blocking, i.e. if there are no entries in the error FIFO it waits until an error entry is present.<p>
You can query the number of entries in the error FIFO using <a class="el" href="mscan__api_8h.html#a52">mscan_queue_status</a> and clear the FIFO using <a class="el" href="mscan__api_8h.html#a53">mscan_queue_clear</a>.<p>
The application can install a signal that is sent whenever a new entry is inserted into the error FIFO using <a class="el" href="mscan__api_8h.html#a48">mscan_set_rcvsig</a>. This signal can be installed by a single process only.<h4><a name="NodeStat"></a>
Reading node status</h4>
The current node status can be queried any time by calling <a class="el" href="mscan__api_8h.html#a58">mscan_node_status</a>. See <a class="el" href="mscan__api_8h.html#a67">MSCAN_NODE_STATUS</a> for details.<h4><a name="ReadCntr"></a>
Reading controller error counters</h4>
It is possible to read the CAN controllers error counters directly by calling <a class="el" href="mscan__api_8h.html#a59">mscan_error_counters</a>. On standard MSCAN implementation, this can be done only when bus activity is disabled (error counters are not accessible when controller is active on the bus). However, MEN's implementation "Boromir" allows to read error counters in either mode. For interpretation of the CAN controller error counters, see the MSCAN controller manual.<h4><a name="BusOffRec"></a>
Recovering from Busoff State</h4>
The MSCAN controller automatically recovers from bus off state. There is no need to call <a class="el" href="mscan__api_8h.html#a54">mscan_clear_busoff</a>. This function is only present for compatibility with other controllers. 
	</div>
</div>

<div class="footer">
<!-- Footer -->
	<p class="footer">
	Generated for MSCAN API using <a href="http://www.doxygen.org">doxygen</a>.<br>
	Copyright &copy; 2012 <a href="http://www.men.de">MEN Mikro Elektronik GmbH</a>. All Rights Reserved.
	</p>
</div>

</body>
</html>

