{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment SYSPARAM2 Reference Manual for SYSPARAM2 fileset 1.30 }SYSPARAM2}
{\comment Generated byDoxgyen. }
{\creatim \yr2012\mo9\dy21\hr14\min41\sec54}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version for SYSPARAM2 fileset 1.30\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
SYSPARAM2 Main Page\par \pard\plain 
{\tc \v Main Page}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid The system parameter library provides a generic way to access parameters, such as\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
parameters stored in non volatile storage (NVS){
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
board inventory parameters (production data)\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
configurable parameters (e.g. console baudrate)\par
}
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
parameters auto-detected by firmware\par
}
\par
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
User callable routines
\par}
{\tc\tcl2 \v User callable routines}
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamGet()}\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamSet()}\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamSetEx()}\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamEnum()}\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamGetAll()}\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamSetDefaults()}\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamMakePersistant()}\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamErrStr()}\par
}
\par
Before any of these functions can be called, a system specific init routine must be called, e.g. {\b Em04SysParamInit()}.\par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b API Differences to original SYSPARAM lib}  \par
}}
\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
SYSPARAM2 Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSPARAM2 Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
\par
{\b {\b F302_FLASH} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b F302_FLASH::systemDataParms} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_ALLOC} (Structure to maintain allocated objects )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_HELP_DESC} (Descriptor for SYSPARAM parameter descriptions )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_HELP_DESC_TBL} (Descriptor for parameter description table )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABME \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_MMSMB_SUPER} (Sysparam super object extended for MENMONs CPUs with SMB NV storage )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_NV_STORAGE} (NV storage object )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_NVS_ADR} (Descriptor for NV storage address )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_PAR_DESC} (Descriptor for a single parameter, used by {\b SYSP_PGRP_MAGPAR} )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_PAR_GRP} (Parameter group object )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_PGRP_MAGPAR} (Parameter group for EEPROM structures with NV magic/parity )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_PGRP_MMPARA} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABML \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_PGRP_NETIF} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_PGRP_STR} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_PGRP_VX} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_SUPER} (Sysparam super object )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSP_TUS_PARAM_INFO} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSPARAM_MMSMB_INIT} (Structure passed to xxxSysParamInit for MENMON/SMB implementations )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSPARAM_NVS_INFO} (NVS info structure )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSPARAM_PARAM_HELP} (Parameter help structure )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SYSPARAM_PARAM_INFO} (Parameter info structure )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b VXBL_BOOT_PARAMS} (Structure to convert boot line )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
SYSPARAM2 File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSPARAM2 File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
\par
{\b {\b sysp_a12.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_api.c} (Exported common routines of SYSPARAM )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_apiex.c} (Extended API routines of SYSPARAM )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_core.c} (Core functions )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_eeprod.c} (Handler for parameter group conforming to eeprod.h )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_eeprod2.c} (Handler for parameter group conforming to EEPROD2 structure )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_em01.c} (EM01 specific part )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_em03.c} (EM03 specific part )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_em04.c} (EM04 specific part )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_em04a.c} (EM04A specific part )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_em09.c} (EM09 specific part cloned from EM03 )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_em10a.c} (EM10A specific part, only needed for Touch calibration data )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_ep01.c} (EP01 specific part )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_ep04.c} (EP04 specific part (cloned from {\b sysp_em03.c} V2.9) )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_esm_cb.c} (ESM (embedded system modules) carrier board handlers )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_esm_cb.work.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_f302.c} (F302 specific part cloned from EM03 )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_intern.h} (Internal header file for sysparam library )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_mm_netif.c} (Special fake NVS section/parameter group that provides the nmacX and nspeedX parameters of network interfaces that store those values into their own SROM )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_mmpara.c} (Parameter group handler for MENMON detected parameters )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_mpgrp.c} (Handler for parameter groups using magic/parity )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_mpgrp.work.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_p504.c} (P504 board specific part )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_paramhelp.c} (Provide help text for commonly used parameters )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_sc15a.c} (SC15A board specific part (cloned from {\b sysp_p504.c} V2.3) )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_sc20.c} (SC20 specific part )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_strgrp.c} (Parameter group handler for NV sections containg a single string )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_sysdep.h} (SYSPARAM system dependent includes/defines )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_tags.c} (Standard parameter name strings )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_tags_esm_cb.c} (Standard ESM carrier board parameter name strings )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_tags_mpc52xx.c} (Standard MPC5200 parameter name strings )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_tags_mpc85xx.c} (Standard MPC85XX parameter name strings )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysp_vxbline.c} (Parameter group handler for VxWorks bootline parameters )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sysparam2.h} (Header file for MEN's sysparam library (second try!) )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
SYSPARAM2 Page Index\par \pard\plain 
{\tc \v Page Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSPARAM2 Related Pages\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all related documentation pages:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
\par
API Differences to original SYSPARAM lib\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

dummy\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Definition of tuple strings\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

}\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
SYSPARAM2 Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F302_FLASH Struct Reference\par \pard\plain 
{\tc\tcl2 \v F302_FLASH}
{\xe \v F302_FLASH}
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EEPROD2 {\b pd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b F302_FLASH::systemDataParms} {\b systemData}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pd\:F302_FLASH}
{\xe \v F302_FLASH\:pd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EEPROD2 {\b F302_FLASH::pd}}
}\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v systemData\:F302_FLASH}
{\xe \v F302_FLASH\:systemData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b F302_FLASH::systemDataParms}  {\b F302_FLASH::systemData}}
}\par
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_f302.c}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F302_FLASH::systemDataParms Struct Reference\par \pard\plain 
{\tc\tcl2 \v F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms}
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int8 {\b id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int8 {\b nmac} [7]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int16 {\b FPGA_variant}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int16 {\b FPGA_rev}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int16 {\b FPGA_date}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int16 {\b FPGA_time}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int16 {\b BSP_version}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b chameleon_base}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int16 {\b PHY_address}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b niosclkhz}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int8 {\b reserved} [22]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v BSP_version\:F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms\:BSP_version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int16 {\b F302_FLASH::systemDataParms::BSP_version}}
}\par
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v chameleon_base\:F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms\:chameleon_base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b F302_FLASH::systemDataParms::chameleon_base}}
}\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v FPGA_date\:F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms\:FPGA_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int16 {\b F302_FLASH::systemDataParms::FPGA_date}}
}\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v FPGA_rev\:F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms\:FPGA_rev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int16 {\b F302_FLASH::systemDataParms::FPGA_rev}}
}\par
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v FPGA_time\:F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms\:FPGA_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int16 {\b F302_FLASH::systemDataParms::FPGA_time}}
}\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v FPGA_variant\:F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms\:FPGA_variant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int16 {\b F302_FLASH::systemDataParms::FPGA_variant}}
}\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v id\:F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int8 {\b F302_FLASH::systemDataParms::id}}
}\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v niosclkhz\:F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms\:niosclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b F302_FLASH::systemDataParms::niosclkhz}}
}\par
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v nmac\:F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms\:nmac}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int8 {\b F302_FLASH::systemDataParms::nmac}[7]}
}\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v PHY_address\:F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms\:PHY_address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int16 {\b F302_FLASH::systemDataParms::PHY_address}}
}\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v reserved\:F302_FLASH::systemDataParms}
{\xe \v F302_FLASH::systemDataParms\:reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int8 {\b F302_FLASH::systemDataParms::reserved}[22]}
}\par
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_f302.c}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_ALLOC Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_ALLOC}
{\xe \v SYSP_ALLOC}
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid structure to maintain allocated objects  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int8 * {\b mem}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i byte array }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i number of bytes available at mem }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b minavail}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid structure to maintain allocated objects \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v mem\:SYSP_ALLOC}
{\xe \v SYSP_ALLOC\:mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int8* {\b SYSP_ALLOC::mem}}
}\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
byte array \par
\par
\par
}
{\xe \v minavail\:SYSP_ALLOC}
{\xe \v SYSP_ALLOC\:minavail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_ALLOC::minavail}}
}\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v size\:SYSP_ALLOC}
{\xe \v SYSP_ALLOC\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_ALLOC::size}}
}\par
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
number of bytes available at mem \par
\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_intern.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_HELP_DESC Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_HELP_DESC}
{\xe \v SYSP_HELP_DESC}
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Descriptor for SYSPARAM parameter descriptions.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b parName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b aliasName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b shortDesc}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b longDescFirstLine}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b longDescContinuation}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b allowedChars}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Descriptor for SYSPARAM parameter descriptions. \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v aliasName\:SYSP_HELP_DESC}
{\xe \v SYSP_HELP_DESC\:aliasName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_HELP_DESC::aliasName}}
}\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v allowedChars\:SYSP_HELP_DESC}
{\xe \v SYSP_HELP_DESC\:allowedChars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_HELP_DESC::allowedChars}}
}\par
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v longDescContinuation\:SYSP_HELP_DESC}
{\xe \v SYSP_HELP_DESC\:longDescContinuation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_HELP_DESC::longDescContinuation}}
}\par
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v longDescFirstLine\:SYSP_HELP_DESC}
{\xe \v SYSP_HELP_DESC\:longDescFirstLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_HELP_DESC::longDescFirstLine}}
}\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v parName\:SYSP_HELP_DESC}
{\xe \v SYSP_HELP_DESC\:parName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_HELP_DESC::parName}}
}\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v shortDesc\:SYSP_HELP_DESC}
{\xe \v SYSP_HELP_DESC\:shortDesc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_HELP_DESC::shortDesc}}
}\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_intern.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_HELP_DESC_TBL Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_HELP_DESC_TBL}
{\xe \v SYSP_HELP_DESC_TBL}
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Descriptor for parameter description table.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_HELP_DESC_TBL} * {\b next}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_HELP_DESC} * {\b desc}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Descriptor for parameter description table. \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v desc\:SYSP_HELP_DESC_TBL}
{\xe \v SYSP_HELP_DESC_TBL\:desc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_HELP_DESC}* {\b SYSP_HELP_DESC_TBL::desc}}
}\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v next\:SYSP_HELP_DESC_TBL}
{\xe \v SYSP_HELP_DESC_TBL\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b SYSP_HELP_DESC_TBL}* {\b SYSP_HELP_DESC_TBL::next}}
}\par
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_intern.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_MMSMB_SUPER Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_MMSMB_SUPER}
{\xe \v SYSP_MMSMB_SUPER}
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Sysparam super object extended for MENMONs CPUs with SMB NV storage.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_SUPER} {\b s}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSPARAM_MMSMB_INIT} {\b initBlk}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Sysparam super object extended for MENMONs CPUs with SMB NV storage. \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v initBlk\:SYSP_MMSMB_SUPER}
{\xe \v SYSP_MMSMB_SUPER\:initBlk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSPARAM_MMSMB_INIT} {\b SYSP_MMSMB_SUPER::initBlk}}
}\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v s\:SYSP_MMSMB_SUPER}
{\xe \v SYSP_MMSMB_SUPER\:s}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_SUPER} {\b SYSP_MMSMB_SUPER::s}}
}\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_intern.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_NV_STORAGE Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE}
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid NV storage object.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_NV_STORAGE} * {\b next}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i pointer to next NVS (must be first elem!) }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b nvsName}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i name of this NVS (e.g. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_SUPER} * {\b super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i sysparam super object }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b prefix} [SYSP_PREFIX_LEN]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i parameter name prefix of that group }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_NVS_ADR} {\b nvsAdr}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i phys. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b nvsSize}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i size of phys. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PAR_GRP} * {\b parGrpLst}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i linked list of parameter group objects }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b readNvs} )(struct {\b SYSP_NV_STORAGE} *nvs, int offset, int size, u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to read from NV storage }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b writeNvs} )(struct {\b SYSP_NV_STORAGE} *nvs, int offset, int size, const u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to write to NV storage }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b numParams} )(struct {\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i get the number of parameters handled by that group }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b enumParams} )(struct {\b SYSP_NV_STORAGE} *nvs, int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to enumerate all parameters of that NVS }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b setParam} )(struct {\b SYSP_NV_STORAGE} *nvs, const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to set a parameter of that NV storage object }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b getParam} )(struct {\b SYSP_NV_STORAGE} *nvs, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to get a parameter of that NV storage object }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b getParamDefault} )(struct {\b SYSP_NV_STORAGE} *nvs, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to get a parameter's default of that NV storage object }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b setDefaults} )(struct {\b SYSP_NV_STORAGE} *nvs, int force)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b save} )(struct {\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i save all parameters of that NVS object to physical NV storage }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid NV storage object. \par
\par
Contains the methods and variables to handle an instance of a sysparam NV storage (EEPROM). \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v enumParams\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:enumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_NV_STORAGE::enumParams})( struct {\b SYSP_NV_STORAGE} *nvs, int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)}
}\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to enumerate all parameters of that NVS \par
Writes info about parameter specified by {\i idx}  to {\i info} .\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  this NV storage object \par
{\i idx} {\b IN}  the nth parameter to query \par
{\i alias} {\b IN}  if TRUE, return alias name \par
{\i info} {\b OUT}  receives the parameter name and the parameter's access attributes\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_INVAL_VALUE if {\i idx}  out of range\par
}
\par
}\par
\par
}
{\xe \v getParam\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:getParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_NV_STORAGE::getParam})( struct {\b SYSP_NV_STORAGE} *nvs, const char *parName, char *parVal, int parValMaxLen )}
}\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to get a parameter of that NV storage object \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  this NV storage object \par
{\i parName} {\b IN}  the parameter name to get (with prefix) \par
{\i parVal} {\b OUT}  receives parameter value as a string \par
{\i parValMaxLen} {\b IN}  max length of parVal (including terminating 0)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
}\par
\par
}
{\xe \v getParamDefault\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:getParamDefault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_NV_STORAGE::getParamDefault})( struct {\b SYSP_NV_STORAGE} *nvs, const char *parName, char *parVal, int parValMaxLen )}
}\par
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to get a parameter's default of that NV storage object \par
\par
\par
}
{\xe \v next\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b SYSP_NV_STORAGE}* {\b SYSP_NV_STORAGE::next}}
}\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
pointer to next NVS (must be first elem!) \par
\par
\par
}
{\xe \v numParams\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:numParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_NV_STORAGE::numParams})( struct {\b SYSP_NV_STORAGE} *nvs )}
}\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
get the number of parameters handled by that group \par
\par
\par
}
{\xe \v nvsAdr\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:nvsAdr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_NVS_ADR} {\b SYSP_NV_STORAGE::nvsAdr}}
}\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
phys. \par
address of NV storage \par
\par
}
{\xe \v nvsName\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:nvsName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_NV_STORAGE::nvsName}}
}\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
name of this NVS (e.g. \par
"em04cpu") \par
\par
}
{\xe \v nvsSize\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:nvsSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b SYSP_NV_STORAGE::nvsSize}}
}\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
size of phys. \par
section in bytes \par
\par
}
{\xe \v parGrpLst\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:parGrpLst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_PAR_GRP}* {\b SYSP_NV_STORAGE::parGrpLst}}
}\par
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
linked list of parameter group objects \par
\par
\par
}
{\xe \v prefix\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:prefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b SYSP_NV_STORAGE::prefix}[SYSP_PREFIX_LEN]}
}\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
parameter name prefix of that group \par
\par
\par
}
{\xe \v readNvs\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:readNvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_NV_STORAGE::readNvs})( struct {\b SYSP_NV_STORAGE} *nvs, int offset, int size, u_int8 *data)}
}\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to read from NV storage \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  this NV storage object \par
{\i offset} {\b IN}  starting byte offset within NVS \par
{\i size} {\b IN}  number of bytes to read from NVS \par
{\i data} {\b OUT}  receives read data \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
}\par
\par
}
{\xe \v save\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:save}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_NV_STORAGE::save})( struct {\b SYSP_NV_STORAGE} *nvs)}
}\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
save all parameters of that NVS object to physical NV storage \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  this NV storage object \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
}\par
\par
}
{\xe \v setDefaults\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:setDefaults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_NV_STORAGE::setDefaults})( struct {\b SYSP_NV_STORAGE} *nvs, int force)}
}\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v setParam\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:setParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_NV_STORAGE::setParam})( struct {\b SYSP_NV_STORAGE} *nvs, const char *parName, const char *parVal, const char *passwd, int attr)}
}\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to set a parameter of that NV storage object \par
parameter names must include possible prefix.\par
New parameter value is written only to internal shadow copy and is not saved until {\b save()} method is called.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  this NV storage object \par
{\i parName} {\b IN}  the parameter name to set (with prefix) \par
{\i parVal} {\b IN}  new parameter value \par
{\i passwd} {\b IN}  password for password protected values (may be NULL) \par
{\i attr} {\b IN}  0 or {\b SYSPARAM_SA_FROM_FIRMWARE}\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
}\par
\par
}
{\xe \v super\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b SYSP_SUPER}* {\b SYSP_NV_STORAGE::super}}
}\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
sysparam super object \par
\par
\par
}
{\xe \v writeNvs\:SYSP_NV_STORAGE}
{\xe \v SYSP_NV_STORAGE\:writeNvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_NV_STORAGE::writeNvs})( struct {\b SYSP_NV_STORAGE} *nvs, int offset, int size, const u_int8 *data)}
}\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to write to NV storage \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  this NV storage object \par
{\i offset} {\b IN}  starting byte offset within NVS \par
{\i size} {\b IN}  number of bytes to write to NVS \par
{\i data} {\b IN}  data to write to NVS \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
}\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_intern.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_NVS_ADR Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_NVS_ADR}
{\xe \v SYSP_NVS_ADR}
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Descriptor for NV storage address.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b SYSP_NVSADR_SMB}, 
{\b SYSP_NVSADR_MEM}
 \}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum SYSP_NVS_ADR:: \{ ... \}  {\b type}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i how union below is to be interpreted }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ u_int8 {\b bus}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ u_int8 {\b dev}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b smb}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ void * {\b mem}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b addr}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Descriptor for NV storage address. \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}
}\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumeration values: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v SYSP_NVSADR_SMB\:SYSP_NVS_ADR}
{\xe \v SYSP_NVS_ADR\:SYSP_NVSADR_SMB}
{\b {\i {\i SYSP_NVSADR_SMB}{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
}}  address is smb address \par
{\xe \v SYSP_NVSADR_MEM\:SYSP_NVS_ADR}
{\xe \v SYSP_NVS_ADR\:SYSP_NVSADR_MEM}
{\b {\i {\i SYSP_NVSADR_MEM}{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
}}  address is memory address \par
}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v addr\:SYSP_NVS_ADR}
{\xe \v SYSP_NVS_ADR\:addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union \{ ... \}   {\b SYSP_NVS_ADR::addr}}
}\par
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v bus\:SYSP_NVS_ADR}
{\xe \v SYSP_NVS_ADR\:bus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int8 {\b SYSP_NVS_ADR::bus}}
}\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SMB bus number. \par
\par
\par
}
{\xe \v dev\:SYSP_NVS_ADR}
{\xe \v SYSP_NVS_ADR\:dev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int8 {\b SYSP_NVS_ADR::dev}}
}\par
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
device address on SMB bus \par
\par
\par
}
{\xe \v mem\:SYSP_NVS_ADR}
{\xe \v SYSP_NVS_ADR\:mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* {\b SYSP_NVS_ADR::mem}}
}\par
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
mem address (if type == SYSP_NVSADR_MEM) \par
\par
\par
}
{\xe \v smb\:SYSP_NVS_ADR}
{\xe \v SYSP_NVS_ADR\:smb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   {\b SYSP_NVS_ADR::smb}}
}\par
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SMB address (if type == SYSP_NVSADR_SMB). \par
\par
\par
}
{\xe \v type\:SYSP_NVS_ADR}
{\xe \v SYSP_NVS_ADR\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum \{ ... \}   {\b SYSP_NVS_ADR::type}}
}\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
how union below is to be interpreted \par
\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_intern.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_PAR_DESC Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_PAR_DESC}
{\xe \v SYSP_PAR_DESC}
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Descriptor for a single parameter, used by {\b SYSP_PGRP_MAGPAR}.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b parName}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i parameter name }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b aliasName}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i alias name (may be NULL) }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b offset}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i raw data offset within group }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b toRaw} )(void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i write new value to raw data. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b fromRaw} )(char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i convert raw data to string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b validate} )(const char *str, int {\b vParam})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check if value {\i str}  is valid for parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b defaultVal}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i parameter default (as string) }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vParam}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i vParam is a genereric parameter passed to {\b validate()}. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pdFlags}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i see SYSP_PD_FLAGS }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Descriptor for a single parameter, used by {\b SYSP_PGRP_MAGPAR}. \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v aliasName\:SYSP_PAR_DESC}
{\xe \v SYSP_PAR_DESC\:aliasName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_PAR_DESC::aliasName}}
}\par
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
alias name (may be NULL) \par
\par
\par
}
{\xe \v defaultVal\:SYSP_PAR_DESC}
{\xe \v SYSP_PAR_DESC\:defaultVal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_PAR_DESC::defaultVal}}
}\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
parameter default (as string) \par
\par
\par
}
{\xe \v fromRaw\:SYSP_PAR_DESC}
{\xe \v SYSP_PAR_DESC\:fromRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_PAR_DESC::fromRaw})( char *dest, int destLen, void *src )}
}\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
convert raw data to string \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} {\b OUT}  receives string \par
{\i destLen} {\b IN}  max length of dest, incl. '\\0' \par
{\i src} {\b IN}  raw data \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
}\par
\par
}
{\xe \v offset\:SYSP_PAR_DESC}
{\xe \v SYSP_PAR_DESC\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PAR_DESC::offset}}
}\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
raw data offset within group \par
\par
\par
}
{\xe \v parName\:SYSP_PAR_DESC}
{\xe \v SYSP_PAR_DESC\:parName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_PAR_DESC::parName}}
}\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
parameter name \par
\par
\par
}
{\xe \v pdFlags\:SYSP_PAR_DESC}
{\xe \v SYSP_PAR_DESC\:pdFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PAR_DESC::pdFlags}}
}\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
see SYSP_PD_FLAGS \par
\par
\par
}
{\xe \v toRaw\:SYSP_PAR_DESC}
{\xe \v SYSP_PAR_DESC\:toRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_PAR_DESC::toRaw})( void *dest, const char *src )}
}\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
write new value to raw data. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} {\b OUT}  receives raw data \par
{\i src} {\b IN}  new value as string \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
}\par
\par
}
{\xe \v validate\:SYSP_PAR_DESC}
{\xe \v SYSP_PAR_DESC\:validate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_PAR_DESC::validate})( const char *str, int {\b vParam} )}
}\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check if value {\i str}  is valid for parameter. \par
this method can be NULL. {\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i str} {\b IN}  pointer to raw data \par
{\i vParam} {\b IN}  method specific validation parameter \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
}\par
\par
}
{\xe \v vParam\:SYSP_PAR_DESC}
{\xe \v SYSP_PAR_DESC\:vParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PAR_DESC::vParam}}
}\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
vParam is a genereric parameter passed to {\b validate()}. \par
used to specify limits.\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_intern.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_PAR_GRP Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP}
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Parameter group object.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PAR_GRP} * {\b next}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i pointer to next parameter group (must be first elem!) }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b grpName}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i name of this parameter group (e.g. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_NV_STORAGE} * {\b nvs}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i the NV storage object that contains this parameter group (null if none) }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nvsOffset}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i starting byte offset of this group within NV storage }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b numParams} )(struct {\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i get the number of parameters handled by that group }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b enumParams} )(struct {\b SYSP_PAR_GRP} *parGrp, int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to enumerate all parameters of that group }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b setParam} )(struct {\b SYSP_PAR_GRP} *parGrp, const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to set a parameter of that group }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b getParam} )(struct {\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to get a parameter of that group }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b getParamDefault} )(struct {\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to get a parameter's default of that group }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b setDefaults} )(struct {\b SYSP_PAR_GRP} *parGrp, int force)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i set default values of all parameters of that group }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b save} )(struct {\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i save parameter group to NV storage This method can be NULL }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Parameter group object. \par
\par
Contains the methods and variables to handle an instance of a parameter group, e.g. a section in an EEPROM or parameter group for VxBline or menmon parameter string \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v enumParams\:SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP\:enumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_PAR_GRP::enumParams})( struct {\b SYSP_PAR_GRP} *parGrp, int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)}
}\par
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to enumerate all parameters of that group \par
Writes info about parameter specified by {\i idx}  to {\i info}  \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parGrp} {\b IN}  this param group object \par
{\i idx} {\b IN}  the nth parameter to query \par
{\i alias} {\b IN}  if TRUE, return alias name \par
{\i info} {\b OUT}  receives parameter name (without prefix) and parameter's access attributes\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_INVAL_VALUE if {\i idx}  out of range\par
}
\par
}\par
\par
}
{\xe \v getParam\:SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP\:getParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_PAR_GRP::getParam})( struct {\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen )}
}\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to get a parameter of that group \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parGrp} {\b IN}  this param group object \par
{\i parName} {\b IN}  the parameter name to get (without prefix) \par
{\i parVal} {\b OUT}  receives parameter value as a string \par
{\i parValMaxLen} {\b IN}  max length of parVal (including terminating 0)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
}\par
\par
}
{\xe \v getParamDefault\:SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP\:getParamDefault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_PAR_GRP::getParamDefault})( struct {\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen )}
}\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to get a parameter's default of that group \par
This pointer can be NULL\par
\par
}
{\xe \v grpName\:SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP\:grpName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_PAR_GRP::grpName}}
}\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
name of this parameter group (e.g. \par
"prod") \par
\par
}
{\xe \v next\:SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b SYSP_PAR_GRP}* {\b SYSP_PAR_GRP::next}}
}\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
pointer to next parameter group (must be first elem!) \par
\par
\par
}
{\xe \v numParams\:SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP\:numParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_PAR_GRP::numParams})( struct {\b SYSP_PAR_GRP} *parGrp )}
}\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
get the number of parameters handled by that group \par
\par
\par
}
{\xe \v nvs\:SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP\:nvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b SYSP_NV_STORAGE}* {\b SYSP_PAR_GRP::nvs}}
}\par
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
the NV storage object that contains this parameter group (null if none) \par
\par
\par
}
{\xe \v nvsOffset\:SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP\:nvsOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PAR_GRP::nvsOffset}}
}\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
starting byte offset of this group within NV storage \par
\par
\par
}
{\xe \v save\:SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP\:save}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_PAR_GRP::save})( struct {\b SYSP_PAR_GRP} *parGrp)}
}\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
save parameter group to NV storage This method can be NULL \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parGrp} {\b IN}  this param group object \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
}\par
\par
}
{\xe \v setDefaults\:SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP\:setDefaults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_PAR_GRP::setDefaults})( struct {\b SYSP_PAR_GRP} *parGrp, int force)}
}\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
set default values of all parameters of that group \par
parameters are written only to internal shadow copy.\par
This method can be NULL\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parGrp} {\b IN}  this param group object \par
{\i force} {\b IN}  if TRUE, apply defaults, even if this group is a inventory group\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
}\par
\par
}
{\xe \v setParam\:SYSP_PAR_GRP}
{\xe \v SYSP_PAR_GRP\:setParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_PAR_GRP::setParam})( struct {\b SYSP_PAR_GRP} *parGrp, const char *parName, const char *parVal, const char *passwd, int attr)}
}\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to set a parameter of that group \par
parameter names do not include prefix.\par
parameter is written only to internal shadow copy. Not saved until {\b save()} method is called\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parGrp} {\b IN}  this param group object \par
{\i parName} {\b IN}  the parameter name to set (without prefix) \par
{\i parVal} {\b IN}  new parameter value \par
{\i passwd} {\b IN}  password for password protected values (may be NULL) \par
{\i attr} {\b IN}  0 or {\b SYSPARAM_SA_FROM_FIRMWARE}\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
}\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_intern.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_PGRP_MAGPAR Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_PGRP_MAGPAR}
{\xe \v SYSP_PGRP_MAGPAR}
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Parameter group for EEPROM structures with NV magic/parity.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b SYSP_MPGRP_NONE} = 0, 
{\b SYSP_MPGRP_PROD} = 0x1
 \}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PAR_GRP} {\b parGrp}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i common parameter group object }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} * {\b parList}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i size of section (incl }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int8 * {\b rawData}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i raw data }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int8 {\b magic}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i magic ID of section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int8 {\b _pad}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum SYSP_PGRP_MAGPAR:: \{ ... \}  {\b mpFlags}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i group flags }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numParams}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i number of parameters handled }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Parameter group for EEPROM structures with NV magic/parity. \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}
}\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumeration values: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v SYSP_MPGRP_NONE\:SYSP_PGRP_MAGPAR}
{\xe \v SYSP_PGRP_MAGPAR\:SYSP_MPGRP_NONE}
{\b {\i {\i SYSP_MPGRP_NONE}{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
}}  \par
{\xe \v SYSP_MPGRP_PROD\:SYSP_PGRP_MAGPAR}
{\xe \v SYSP_PGRP_MAGPAR\:SYSP_MPGRP_PROD}
{\b {\i {\i SYSP_MPGRP_PROD}{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
}}  group contains production data \par
}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v _pad\:SYSP_PGRP_MAGPAR}
{\xe \v SYSP_PGRP_MAGPAR\:_pad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int8 {\b SYSP_PGRP_MAGPAR::_pad}}
}\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v magic\:SYSP_PGRP_MAGPAR}
{\xe \v SYSP_PGRP_MAGPAR\:magic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int8 {\b SYSP_PGRP_MAGPAR::magic}}
}\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
magic ID of section \par
\par
\par
}
{\xe \v mpFlags\:SYSP_PGRP_MAGPAR}
{\xe \v SYSP_PGRP_MAGPAR\:mpFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum \{ ... \}   {\b SYSP_PGRP_MAGPAR::mpFlags}}
}\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
group flags \par
\par
\par
}
{\xe \v numParams\:SYSP_PGRP_MAGPAR}
{\xe \v SYSP_PGRP_MAGPAR\:numParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PGRP_MAGPAR::numParams}}
}\par
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
number of parameters handled \par
\par
\par
}
{\xe \v parGrp\:SYSP_PGRP_MAGPAR}
{\xe \v SYSP_PGRP_MAGPAR\:parGrp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_PAR_GRP} {\b SYSP_PGRP_MAGPAR::parGrp}}
}\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
common parameter group object \par
\par
\par
}
{\xe \v parList\:SYSP_PGRP_MAGPAR}
{\xe \v SYSP_PGRP_MAGPAR\:parList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC}* {\b SYSP_PGRP_MAGPAR::parList}}
}\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters \par
\par
\par
}
{\xe \v rawData\:SYSP_PGRP_MAGPAR}
{\xe \v SYSP_PGRP_MAGPAR\:rawData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int8* {\b SYSP_PGRP_MAGPAR::rawData}}
}\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
raw data \par
\par
\par
}
{\xe \v size\:SYSP_PGRP_MAGPAR}
{\xe \v SYSP_PGRP_MAGPAR\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PGRP_MAGPAR::size}}
}\par
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
size of section (incl \par
magic/parity) \par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_intern.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_PGRP_MMPARA Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_PGRP_MMPARA}
{\xe \v SYSP_PGRP_MMPARA}
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PAR_GRP} {\b parGrp}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i common parameter group object }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_CONST_STRING} * {\b parList}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i array of handled parameter names }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numParams}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i number of parameters handled }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bufSize}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i size of {\i buf}  }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b buf}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i holds all handled parameters as name=value pairs }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v buf\:SYSP_PGRP_MMPARA}
{\xe \v SYSP_PGRP_MMPARA\:buf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b SYSP_PGRP_MMPARA::buf}}
}\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
holds all handled parameters as name=value pairs \par
\par
\par
}
{\xe \v bufSize\:SYSP_PGRP_MMPARA}
{\xe \v SYSP_PGRP_MMPARA\:bufSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PGRP_MMPARA::bufSize}}
}\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
size of {\i buf}  \par
\par
\par
}
{\xe \v numParams\:SYSP_PGRP_MMPARA}
{\xe \v SYSP_PGRP_MMPARA\:numParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PGRP_MMPARA::numParams}}
}\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
number of parameters handled \par
\par
\par
}
{\xe \v parGrp\:SYSP_PGRP_MMPARA}
{\xe \v SYSP_PGRP_MMPARA\:parGrp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_PAR_GRP} {\b SYSP_PGRP_MMPARA::parGrp}}
}\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
common parameter group object \par
\par
\par
}
{\xe \v parList\:SYSP_PGRP_MMPARA}
{\xe \v SYSP_PGRP_MMPARA\:parList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_CONST_STRING}* {\b SYSP_PGRP_MMPARA::parList}}
}\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
array of handled parameter names \par
\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_mmpara.c}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_PGRP_NETIF Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_PGRP_NETIF}
{\xe \v SYSP_PGRP_NETIF}
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PAR_GRP} {\b parGrp}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i common parameter group object }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b netifNum}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i serve the nth (0..n) nspeed/nmac parameter }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NETIF * {\b netif}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i the NETIF device }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NETIF_LINK_SPEED {\b spd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NETIF_GET_MAC_ADDR {\b mac}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b macChanged}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v mac\:SYSP_PGRP_NETIF}
{\xe \v SYSP_PGRP_NETIF\:mac}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NETIF_GET_MAC_ADDR {\b SYSP_PGRP_NETIF::mac}}
}\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v macChanged\:SYSP_PGRP_NETIF}
{\xe \v SYSP_PGRP_NETIF\:macChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PGRP_NETIF::macChanged}}
}\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v netif\:SYSP_PGRP_NETIF}
{\xe \v SYSP_PGRP_NETIF\:netif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NETIF* {\b SYSP_PGRP_NETIF::netif}}
}\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
the NETIF device \par
\par
\par
}
{\xe \v netifNum\:SYSP_PGRP_NETIF}
{\xe \v SYSP_PGRP_NETIF\:netifNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PGRP_NETIF::netifNum}}
}\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
serve the nth (0..n) nspeed/nmac parameter \par
\par
\par
}
{\xe \v parGrp\:SYSP_PGRP_NETIF}
{\xe \v SYSP_PGRP_NETIF\:parGrp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_PAR_GRP} {\b SYSP_PGRP_NETIF::parGrp}}
}\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
common parameter group object \par
\par
\par
}
{\xe \v spd\:SYSP_PGRP_NETIF}
{\xe \v SYSP_PGRP_NETIF\:spd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NETIF_LINK_SPEED {\b SYSP_PGRP_NETIF::spd}}
}\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_mm_netif.c}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_PGRP_STR Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_PGRP_STR}
{\xe \v SYSP_PGRP_STR}
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PAR_GRP} {\b parGrp}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i common parameter group object }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b alias}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i alias name for parameter }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b defVal}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i string default value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b str}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i current value of string (behind obj) }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i size of NV area }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v alias\:SYSP_PGRP_STR}
{\xe \v SYSP_PGRP_STR\:alias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_PGRP_STR::alias}}
}\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
alias name for parameter \par
\par
\par
}
{\xe \v defVal\:SYSP_PGRP_STR}
{\xe \v SYSP_PGRP_STR\:defVal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_PGRP_STR::defVal}}
}\par
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
string default value \par
\par
\par
}
{\xe \v parGrp\:SYSP_PGRP_STR}
{\xe \v SYSP_PGRP_STR\:parGrp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_PAR_GRP} {\b SYSP_PGRP_STR::parGrp}}
}\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
common parameter group object \par
\par
\par
}
{\xe \v size\:SYSP_PGRP_STR}
{\xe \v SYSP_PGRP_STR\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PGRP_STR::size}}
}\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
size of NV area \par
\par
\par
}
{\xe \v str\:SYSP_PGRP_STR}
{\xe \v SYSP_PGRP_STR\:str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b SYSP_PGRP_STR::str}}
}\par
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
current value of string (behind obj) \par
\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_strgrp.c}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_PGRP_VX Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_PGRP_VX}
{\xe \v SYSP_PGRP_VX}
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PAR_GRP} {\b parGrp}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i common parameter group object }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VXBL_BOOT_PARAMS} {\b bpStruct}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i boot parameter structure }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b vxDefBline}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i boot line with defaults }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b vxBline}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i current boot line }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i size of NV area }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v bpStruct\:SYSP_PGRP_VX}
{\xe \v SYSP_PGRP_VX\:bpStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VXBL_BOOT_PARAMS} {\b SYSP_PGRP_VX::bpStruct}}
}\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
boot parameter structure \par
\par
\par
}
{\xe \v parGrp\:SYSP_PGRP_VX}
{\xe \v SYSP_PGRP_VX\:parGrp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_PAR_GRP} {\b SYSP_PGRP_VX::parGrp}}
}\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
common parameter group object \par
\par
\par
}
{\xe \v size\:SYSP_PGRP_VX}
{\xe \v SYSP_PGRP_VX\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_PGRP_VX::size}}
}\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
size of NV area \par
\par
\par
}
{\xe \v vxBline\:SYSP_PGRP_VX}
{\xe \v SYSP_PGRP_VX\:vxBline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b SYSP_PGRP_VX::vxBline}}
}\par
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
current boot line \par
\par
\par
}
{\xe \v vxDefBline\:SYSP_PGRP_VX}
{\xe \v SYSP_PGRP_VX\:vxDefBline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_PGRP_VX::vxDefBline}}
}\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
boot line with defaults \par
\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_vxbline.c}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_SUPER Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_SUPER}
{\xe \v SYSP_SUPER}
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Sysparam super object.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b readNvs} )(struct {\b SYSP_SUPER} *super, {\b SYSP_NVS_ADR} nvsAdr, int offset, int size, u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to read from NV storage }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b writeNvs} )(struct {\b SYSP_SUPER} *super, {\b SYSP_NVS_ADR} nvsAdr, int offset, int size, const u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to write to NV storage }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b reInit} )(struct {\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to restart entrire sysparam lib. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b postProcessSetParam} )(struct {\b SYSP_SUPER} *super, const char *parName, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function to do any required post processing after a {\b SysParamSet()}. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_POST_PROCESS_CB} {\b postProcessHook}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i users' hook. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_NV_STORAGE} * {\b nvsLst}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i linked list of NV storage objects }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_ALLOC} {\b alloc}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i main allocation object }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b initialized}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i sysparam initialized }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DBG_HANDLE * {\b dbh}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i debug handle }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Sysparam super object. \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v alloc\:SYSP_SUPER}
{\xe \v SYSP_SUPER\:alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_ALLOC} {\b SYSP_SUPER::alloc}}
}\par
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
main allocation object \par
\par
\par
}
{\xe \v dbh\:SYSP_SUPER}
{\xe \v SYSP_SUPER\:dbh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DBG_HANDLE* {\b SYSP_SUPER::dbh}}
}\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
debug handle \par
\par
\par
}
{\xe \v initialized\:SYSP_SUPER}
{\xe \v SYSP_SUPER\:initialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_SUPER::initialized}}
}\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
sysparam initialized \par
\par
\par
}
{\xe \v nvsLst\:SYSP_SUPER}
{\xe \v SYSP_SUPER\:nvsLst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_NV_STORAGE}* {\b SYSP_SUPER::nvsLst}}
}\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
linked list of NV storage objects \par
\par
\par
}
{\xe \v postProcessHook\:SYSP_SUPER}
{\xe \v SYSP_SUPER\:postProcessHook}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_POST_PROCESS_CB} {\b SYSP_SUPER::postProcessHook}}
}\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
users' hook. \par
\par
\par
}
{\xe \v postProcessSetParam\:SYSP_SUPER}
{\xe \v SYSP_SUPER\:postProcessSetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_SUPER::postProcessSetParam})( struct {\b SYSP_SUPER} *super, const char *parName, int attr)}
}\par
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to do any required post processing after a {\b SysParamSet()}. \par
can be used to update MENMON parameter string.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i super} {\b IN}  this object \par
{\i parName} {\b IN}  parameter name including possible prefix. NULL if called from SysParamSetDefaults \par
{\i attr} {\b IN}  attribute flags (see {\b SYSPARAM_SET_ATTR})\par
}
\par
\par
}
{\xe \v readNvs\:SYSP_SUPER}
{\xe \v SYSP_SUPER\:readNvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_SUPER::readNvs})( struct {\b SYSP_SUPER} *super, {\b SYSP_NVS_ADR} nvsAdr, int offset, int size, u_int8 *data)}
}\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to read from NV storage \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i super} {\b IN}  this object \par
{\i nvsAdr} {\b IN}  NV storage address \par
{\i offset} {\b IN}  starting byte offset within NVS \par
{\i size} {\b IN}  number of bytes to read from NVS \par
{\i data} {\b OUT}  receives read data \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
}\par
\par
}
{\xe \v reInit\:SYSP_SUPER}
{\xe \v SYSP_SUPER\:reInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_SUPER::reInit})( struct {\b SYSP_SUPER} *super )}
}\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to restart entrire sysparam lib. \par
\par
\par
}
{\xe \v writeNvs\:SYSP_SUPER}
{\xe \v SYSP_SUPER\:writeNvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* {\b SYSP_SUPER::writeNvs})( struct {\b SYSP_SUPER} *super, {\b SYSP_NVS_ADR} nvsAdr, int offset, int size, const u_int8 *data)}
}\par
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function to write to NV storage \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i super} {\b IN}  this object \par
{\i nvsAdr} {\b IN}  NV storage address \par
{\i offset} {\b IN}  starting byte offset within NVS \par
{\i size} {\b IN}  number of bytes to write to NVS \par
{\i data} {\b IN}  data to write to NVS \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
}\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_intern.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSP_TUS_PARAM_INFO Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSP_TUS_PARAM_INFO}
{\xe \v SYSP_TUS_PARAM_INFO}
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b parStr}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i parameter name begin pointer into TUS (not null terminated). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b parStrEnd}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i parameter name end pointer+1 into TUS }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b valStr}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i value string begin pointer into TUS (not null terminated) Value string will NOT include surrounding ticks }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b valStrEnd}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i value string end pointer+1 into TUS }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hasTicks}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i true if value surrounnded by ticks }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v hasTicks\:SYSP_TUS_PARAM_INFO}
{\xe \v SYSP_TUS_PARAM_INFO\:hasTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSP_TUS_PARAM_INFO::hasTicks}}
}\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
true if value surrounnded by ticks \par
\par
\par
}
{\xe \v parStr\:SYSP_TUS_PARAM_INFO}
{\xe \v SYSP_TUS_PARAM_INFO\:parStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b SYSP_TUS_PARAM_INFO::parStr}}
}\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
parameter name begin pointer into TUS (not null terminated). \par
\par
\par
}
{\xe \v parStrEnd\:SYSP_TUS_PARAM_INFO}
{\xe \v SYSP_TUS_PARAM_INFO\:parStrEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b SYSP_TUS_PARAM_INFO::parStrEnd}}
}\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
parameter name end pointer+1 into TUS \par
\par
\par
}
{\xe \v valStr\:SYSP_TUS_PARAM_INFO}
{\xe \v SYSP_TUS_PARAM_INFO\:valStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b SYSP_TUS_PARAM_INFO::valStr}}
}\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
value string begin pointer into TUS (not null terminated) Value string will NOT include surrounding ticks \par
\par
\par
}
{\xe \v valStrEnd\:SYSP_TUS_PARAM_INFO}
{\xe \v SYSP_TUS_PARAM_INFO\:valStrEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b SYSP_TUS_PARAM_INFO::valStrEnd}}
}\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
value string end pointer+1 into TUS \par
\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_mmpara.c}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSPARAM_MMSMB_INIT Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSPARAM_MMSMB_INIT}
{\xe \v SYSPARAM_MMSMB_INIT}
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid structure passed to xxxSysParamInit for MENMON/SMB implementations  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b osh}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i passed unmodified to eeRead/eeWrite }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32(* {\b eeRead} )(void *{\b osh}, int smbBus, int smbAdr, int offset, u_int8 *buf, int bufLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function callback to read eeproms, }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32(* {\b eeWrite} )(void *{\b osh}, int smbBus, int smbAdr, int offset, u_int8 *buf, int bufLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i function callback to write eeproms, }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b mmParaStringAdrs}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i MENMON parameter string address. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mmParaStringMaxLen}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i space in MENMON parameter string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b vxBlineStringAdrs}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i VxWorks bootline string address. }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid structure passed to xxxSysParamInit for MENMON/SMB implementations \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v eeRead\:SYSPARAM_MMSMB_INIT}
{\xe \v SYSPARAM_MMSMB_INIT\:eeRead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32(* {\b SYSPARAM_MMSMB_INIT::eeRead})(void* {\b osh}, int smbBus, int smbAdr, int offset, u_int8 *buf, int bufLen )}
}\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function callback to read eeproms, \par
Should read {\i bufLen}  bytes from {\i offset}  of the SMB eeprom at {\i smbBus}  and {\i smbAdr}  into {\i buf} . The data block may cross a 256 byte boundary.\par
This function is "missused" also for NVS sections in (boot) flash. If {\i smbBus}  is {\b SYSPARAM_SMB_BUS_FLASH}, then the NVS section is in flash. In this case {\i smbAdr}  is interpreted as a sector identifier, e.g. 0xff for last sector in flash. {\i offset}  is measured from the beginning of addresses flash sector.\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 if ok, a value != 0 on error\par
}\par
\par
}
{\xe \v eeWrite\:SYSPARAM_MMSMB_INIT}
{\xe \v SYSPARAM_MMSMB_INIT\:eeWrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32(* {\b SYSPARAM_MMSMB_INIT::eeWrite})(void* {\b osh}, int smbBus, int smbAdr, int offset, u_int8 *buf, int bufLen )}
}\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
function callback to write eeproms, \par
Should write {\i bufLen}  bytes to {\i offset}  of the SMB eeprom at {\i smbBus}  and {\i smbAdr}  from {\i buf} . The data block may cross a 256 byte boundary. The function should perform a read-after-write.\par
Also used for flash, see note in {\b eeRead()}.\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 if ok, a value != 0 on error\par
}\par
\par
}
{\xe \v mmParaStringAdrs\:SYSPARAM_MMSMB_INIT}
{\xe \v SYSPARAM_MMSMB_INIT\:mmParaStringAdrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b SYSPARAM_MMSMB_INIT::mmParaStringAdrs}}
}\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
MENMON parameter string address. \par
The content of this string is used to initialize the parameters in the {\f2 mmpara}  parameter group (cpu=, pciclkhz=...). It should be therefore either be{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
initialized with parameters or\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
an empty string and the parameters updated later by firmware\par
}
\par
This string is then filled by SYSPARAM with most of the parameters and whenever a {\b SysParamSet()} or {\b SysParamSetDefaults()} is issued.\par
\par
}
{\xe \v mmParaStringMaxLen\:SYSPARAM_MMSMB_INIT}
{\xe \v SYSPARAM_MMSMB_INIT\:mmParaStringMaxLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SYSPARAM_MMSMB_INIT::mmParaStringMaxLen}}
}\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
space in MENMON parameter string \par
\par
\par
}
{\xe \v osh\:SYSPARAM_MMSMB_INIT}
{\xe \v SYSPARAM_MMSMB_INIT\:osh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* {\b SYSPARAM_MMSMB_INIT::osh}}
}\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
passed unmodified to eeRead/eeWrite \par
\par
\par
}
{\xe \v vxBlineStringAdrs\:SYSPARAM_MMSMB_INIT}
{\xe \v SYSPARAM_MMSMB_INIT\:vxBlineStringAdrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b SYSPARAM_MMSMB_INIT::vxBlineStringAdrs}}
}\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
VxWorks bootline string address. \par
This string is the immediate buffer for the parameters in the {\f2 vxbline}  parameter group.\par
When it is an empty string when the xxxSysParamInit() routine is called, SYSPARAM reads the string from non volatile storage.\par
If it is a non-empty string, the string is basically validated.\par
Whenever either the NV data or the passed string appears invalid, a default bootline is setup (CPU dependant).\par
This string shall have space for at least 480 bytes.\par
{\i vxBlineStringAdrs}  will receive immediately any modification made through {\b SysParamSet()} or {\b SysParamSetDefaults()}.\par
The string can be also modified outside the SYSPARAM library. The {\b SysParamGet()} will fetch the values always directly from this string.\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysparam2.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSPARAM_NVS_INFO Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSPARAM_NVS_INFO}
{\xe \v SYSPARAM_NVS_INFO}
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid NVS info structure.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b prefix} [SYSP_PREFIX_LEN]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i NVS prefix. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [SYSP_NVSNAME_LEN]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i NVS section name. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b nvsSize}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i size of section in bytes }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid NVS info structure. \par
\par
To be used with {\b SYSP_NvsEnum()} \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v name\:SYSPARAM_NVS_INFO}
{\xe \v SYSPARAM_NVS_INFO\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b SYSPARAM_NVS_INFO::name}[SYSP_NVSNAME_LEN]}
}\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
NVS section name. \par
\par
\par
}
{\xe \v nvsSize\:SYSPARAM_NVS_INFO}
{\xe \v SYSPARAM_NVS_INFO\:nvsSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b SYSPARAM_NVS_INFO::nvsSize}}
}\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
size of section in bytes \par
\par
\par
}
{\xe \v prefix\:SYSPARAM_NVS_INFO}
{\xe \v SYSPARAM_NVS_INFO\:prefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b SYSPARAM_NVS_INFO::prefix}[SYSP_PREFIX_LEN]}
}\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
NVS prefix. \par
\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysparam2.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSPARAM_PARAM_HELP Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSPARAM_PARAM_HELP}
{\xe \v SYSPARAM_PARAM_HELP}
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Parameter help structure.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b shortDesc} [40]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i short description of parameter }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b longDescFirstLine}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i First line (most important part) of longer description 79 chars max, can be NULL. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b longDescContinuation}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i continued longer description, may consist of multiple lines, each line 79 chars max, can be NULL }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b allowedChars}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allowed characters for live editing (setupmenu), argument to strmatch(), if NULL, all chars allowed }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b choice} [10]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i if multiple choice input, the list of choices if not multiple choice, choice[0] is NULL. }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Parameter help structure. \par
\par
Filled by {\b SysParamHelp()} \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v allowedChars\:SYSPARAM_PARAM_HELP}
{\xe \v SYSPARAM_PARAM_HELP\:allowedChars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSPARAM_PARAM_HELP::allowedChars}}
}\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allowed characters for live editing (setupmenu), argument to strmatch(), if NULL, all chars allowed \par
\par
\par
}
{\xe \v choice\:SYSPARAM_PARAM_HELP}
{\xe \v SYSPARAM_PARAM_HELP\:choice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSPARAM_PARAM_HELP::choice}[10]}
}\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
if multiple choice input, the list of choices if not multiple choice, choice[0] is NULL. \par
List of choices always NULL terminated\par
\par
}
{\xe \v longDescContinuation\:SYSPARAM_PARAM_HELP}
{\xe \v SYSPARAM_PARAM_HELP\:longDescContinuation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSPARAM_PARAM_HELP::longDescContinuation}}
}\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
continued longer description, may consist of multiple lines, each line 79 chars max, can be NULL \par
\par
\par
}
{\xe \v longDescFirstLine\:SYSPARAM_PARAM_HELP}
{\xe \v SYSPARAM_PARAM_HELP\:longDescFirstLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSPARAM_PARAM_HELP::longDescFirstLine}}
}\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
First line (most important part) of longer description 79 chars max, can be NULL. \par
\par
\par
}
{\xe \v shortDesc\:SYSPARAM_PARAM_HELP}
{\xe \v SYSPARAM_PARAM_HELP\:shortDesc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b SYSPARAM_PARAM_HELP::shortDesc}[40]}
}\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
short description of parameter \par
\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysparam2.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SYSPARAM_PARAM_INFO Struct Reference\par \pard\plain 
{\tc\tcl2 \v SYSPARAM_PARAM_INFO}
{\xe \v SYSPARAM_PARAM_INFO}
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Parameter info structure.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b parName} [SYSP_PREFIX_LEN+SYSP_PARNAME_LEN]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i parameter name including prefix }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSPARAM_ACC_ATTR} {\b attr}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i parameter access attributes }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Parameter info structure. \par
\par
To be used with {\b SysParamEnum()} \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v attr\:SYSPARAM_PARAM_INFO}
{\xe \v SYSPARAM_PARAM_INFO\:attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSPARAM_ACC_ATTR} {\b SYSPARAM_PARAM_INFO::attr}}
}\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
parameter access attributes \par
\par
\par
}
{\xe \v parName\:SYSPARAM_PARAM_INFO}
{\xe \v SYSPARAM_PARAM_INFO\:parName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b SYSPARAM_PARAM_INFO::parName}[SYSP_PREFIX_LEN+SYSP_PARNAME_LEN]}
}\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
parameter name including prefix \par
\par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysparam2.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VXBL_BOOT_PARAMS Struct Reference\par \pard\plain 
{\tc\tcl2 \v VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS}
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid structure to convert boot line  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b bootDev} [BOOT_DEV_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b hostName} [BOOT_HOST_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b targetName} [BOOT_HOST_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b ead} [BOOT_TARGET_ADDR_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b bad} [BOOT_TARGET_ADDR_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b had} [BOOT_ADDR_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b gad} [BOOT_ADDR_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b bootFile} [BOOT_FILE_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b startupScript} [BOOT_STARTUP_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b usr} [BOOT_USR_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b passwd} [BOOT_PASSWORD_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b other} [BOOT_OTHER_LEN]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b procNum}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b unitNum}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid structure to convert boot line \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v bad\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:bad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::bad}[BOOT_TARGET_ADDR_LEN]}
}\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v bootDev\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:bootDev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::bootDev}[BOOT_DEV_LEN]}
}\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v bootFile\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:bootFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::bootFile}[BOOT_FILE_LEN]}
}\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v ead\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:ead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::ead}[BOOT_TARGET_ADDR_LEN]}
}\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v flags\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int {\b VXBL_BOOT_PARAMS::flags}}
}\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v gad\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:gad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::gad}[BOOT_ADDR_LEN]}
}\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v had\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:had}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::had}[BOOT_ADDR_LEN]}
}\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v hostName\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:hostName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::hostName}[BOOT_HOST_LEN]}
}\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v other\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:other}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::other}[BOOT_OTHER_LEN]}
}\par
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v passwd\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:passwd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::passwd}[BOOT_PASSWORD_LEN]}
}\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v procNum\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:procNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int {\b VXBL_BOOT_PARAMS::procNum}}
}\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v startupScript\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:startupScript}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::startupScript}[BOOT_STARTUP_LEN]}
}\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v targetName\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:targetName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::targetName}[BOOT_HOST_LEN]}
}\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v unitNum\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:unitNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int {\b VXBL_BOOT_PARAMS::unitNum}}
}\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v usr\:VXBL_BOOT_PARAMS}
{\xe \v VXBL_BOOT_PARAMS\:usr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b VXBL_BOOT_PARAMS::usr}[BOOT_USR_LEN]}
}\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sysp_vxbline.c}\par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
SYSPARAM2 File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_a12.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_a12.c}
{\xe \v sysp_a12.c}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFFX}(x)\~ offsetof(struct menmx_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsA12CpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for A12 CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b A12Init} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for A12. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b A12SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for A12. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1100]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListA12Menm} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in A12 CPU EEPROM, menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListA12MenmX} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in A12 CPU EEPROM, menmon extended section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_CONST_STRING} {\b SYSP_parListA12Mmpara} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in "mmpara" parameter group }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_a12.c}
{\xe \v sysp_a12.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFFX\:sysp_a12.c}
{\xe \v sysp_a12.c\:_EEOFFX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFFX(x)\~ offsetof(struct menmx_parms,x)}
}\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v A12Init\:sysp_a12.c}
{\xe \v sysp_a12.c\:A12Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int A12Init ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for A12. \par
Probes for CPU EEPROM and possible ESM carrier boards {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v A12SysParamInit\:sysp_a12.c}
{\xe \v sysp_a12.c\:A12SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int A12SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for A12. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_NvsA12CpuProbe\:sysp_a12.c}
{\xe \v sysp_a12.c\:SYSP_NvsA12CpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsA12CpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for A12 CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in A12 CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_a12.c}
{\xe \v sysp_a12.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1100]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_super\:sysp_a12.c}
{\xe \v sysp_a12.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_parListA12Menm\:sysp_a12.c}
{\xe \v sysp_a12.c\:SYSP_parListA12Menm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListA12Menm}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
\par
    \par
    SYSP_PDE_U8X( "misc",           NULL, _EEOFF(mm_misc), "0", 0),\par
    SYSP_PDE_BOOL1( SYSP_ldlogodis, NULL, _EEOFF(mm_misc), "0", 0 ),\par
    SYSP_PDE_BOOL2( "nobanner",     NULL, _EEOFF(mm_misc), "0", 0 ),\par
    \par
    \par
    SYSP_PDE_U8X( "selftest",       NULL, _EEOFF(mm_selftest), "0", 0),\par
    SYSP_PDE_BOOL0( SYSP_stdis,     NULL, _EEOFF(mm_selftest), "0", 0 ),\par
    SYSP_PDE_BOOL1( SYSP_stignfault,NULL, _EEOFF(mm_selftest), "0", 0 ),\par
\par
    SYSP_PDE_U8X( "vmeirqenb", "vme_irq", _EEOFF(mm_vme_irqenb), "fe", \par
                  SYSP_PD_MMPARASTR),\par
    SYSP_PDE_U8X( "vme_a24sa",    NULL, _EEOFF(mm_vme_a24slaveAddr), "ff", 0),\par
    SYSP_PDE_U8X( "pciopts",         NULL, _EEOFF(mm_pci_opts), "3", 0),\par
    SYSP_PDE_BOOL0( "pci_stgath",  NULL, _EEOFF(mm_pci_opts), "1", 0 ),\par
    SYSP_PDE_BOOL1( "pci_specrd", NULL, _EEOFF(mm_pci_opts), "1", 0 ),\par
    SYSP_PDE_U8X( "vme_opts",        NULL, _EEOFF(mm_vme_opts), "0", 0),\par
    SYSP_PDE_BOOL0( "vme_req",    NULL, _EEOFF(mm_vme_opts), "0", 0 ),\par
    SYSP_PDE_U8X( "vme_a32ma",  NULL, _EEOFF(mm_vmePLDz002_a32masterBase), "0", 0),\par
    SYSP_PDE_U16X( "vmode",  NULL, _EEOFF(mm_vmode), "101", 0),\par
    SYSP_PDE_U8X( "kmap",  NULL, _EEOFF(mm_keymap), "0", 0),\par
\par
\par
    SYSP_PDE_CBR(   _EEOFF(mm_cbaud) ),\par
    SYSP_PDE_BSADR( _EEOFF(mm_bsadr) ),\par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in A12 CPU EEPROM, menmon section \par
\par
}
{\xe \v SYSP_parListA12MenmX\:sysp_a12.c}
{\xe \v sysp_a12.c\:SYSP_parListA12MenmX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListA12MenmX}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_CON0( _EEOFFX(mmx_con[0]), "4" ),  \par
    SYSP_PDE_CON1( _EEOFFX(mmx_con[1]), "20" ), \par
    SYSP_PDE_CON2( _EEOFFX(mmx_con[2]), "0" ),  \par
    SYSP_PDE_CON3( _EEOFFX(mmx_con[3]), "0" ),  \par
    SYSP_PDE_GCON( _EEOFFX(mmx_gcon),   "ff"),  \par
    SYSP_PDE_VMODE( _EEOFFX(mmx_vmode) ),\par
    SYSP_PDE_ECL(   _EEOFFX(mmx_ecl) ),\par
    SYSP_PDE_TTO(   _EEOFFX(mmx_tto) ),\par
    SYSP_PDE_TRIES( _EEOFFX(mmx_tries) ),\par
    SYSP_PDE_TDP(   _EEOFFX(mmx_tdp) ),\par
    SYSP_PDE_HDP(   _EEOFFX(mmx_hdp) ),\par
    SYSP_PDE_STWAIT(_EEOFFX(mmx_stwait), "30" ),\par
    SYSP_PDE_WDT(   _EEOFFX(mmx_wdt), "0" ),\par
    SYSP_PDE_UXX(   _EEOFFX(mmx_usr[0]) ),\par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in A12 CPU EEPROM, menmon extended section \par
\par
}
{\xe \v SYSP_parListA12Mmpara\:sysp_a12.c}
{\xe \v sysp_a12.c\:SYSP_parListA12Mmpara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_CONST_STRING} {\b SYSP_parListA12Mmpara}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_mem0,\par
    SYSP_mem1,\par
    SYSP_flash0,\par
    SYSP_cpu,\par
    "cpuclk",\par
    SYSP_cpuclkhz,\par
    "memclk",\par
    SYSP_memclkhz,\par
    SYSP_pciclkhz,\par
    SYSP_clun,\par
    SYSP_dlun,\par
    SYSP_rststat,   \par
    SYSP_mmst,\par
    SYSP_mm,\par
    SYSP_cons,\par
    NULL\par
\}\par
\par
}
list of parameters in "mmpara" parameter group \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_api.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_api.c}
{\xe \v sysp_api.c}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Exported common routines of SYSPARAM.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_GETALL_MAX_PARLEN}\~ 512\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i max. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamSetEx} (const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Modify value of single system parameter (extended version). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamSet} (const char *parName, const char *parVal, const char *passwd)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Modify value of single system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamGet} (const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get value of single system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamGetDefault} (const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get default value of single system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamGetAll} (char *buf, int bufLen, int alias)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get all parameters with their values. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamSetDefaults} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set all non volatile parameters to defaults. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamMakePersistant} (const char *parName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Write temporary changes to NV storage. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamEnum} (int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Enumerate all parameters of Sysparam. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamNumParams} (int *numP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get total number of parameters handled by Sysparam. }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Exported common routines of SYSPARAM. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2010/06/07 16:13:30 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.9 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
\par
}
\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v SYSP_GETALL_MAX_PARLEN\:sysp_api.c}
{\xe \v sysp_api.c\:SYSP_GETALL_MAX_PARLEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_GETALL_MAX_PARLEN\~ 512}
}\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
max. \par
length of each parameter string for SysParamGetAll \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v SysParamEnum\:sysp_api.c}
{\xe \v sysp_api.c\:SysParamEnum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamEnum (int {\i idx}, int {\i alias}, {\b SYSPARAM_PARAM_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enumerate all parameters of Sysparam. \par
Writes info about parameter specified by {\i idx}  to {\i info} .\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i idx} {\b IN}  the nth parameter to query \par
{\i alias} {\b IN}  if TRUE, return alias name \par
{\i info} {\b OUT}  receives the parameter name and the parameter's access attributes\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_VALUE} if {\i idx}  out of range \par
}
\par
}\par
\par
}
{\xe \v SysParamGet\:sysp_api.c}
{\xe \v sysp_api.c\:SysParamGet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamGet (const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get value of single system parameter. \par
This gets the current value of the parameter {\i parName} . Parameter name can be either the official parameter name or the alias name.\par
If {\b SysParamGet()} returns non-zero, {\i parVal}  will contain an empty string (unless {\i parValMaxLen}  is {\f2 0} ).\par
If the parameter value (as a string) is longer than {\i parValMaxLen} , string in {\i parVal}  is truncated. {\i parVal}  is always guaranteed to be null-terminated.\par
{\i parVal}  may contain blanks.\par
This function can be used to probe for the existance of a parameter name. Pass {\i parVal}  as NULL and parValMaxLen as 0 in this case.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i parVal} {\b OUT}  receives the parameter's value as a string \par
{\i parValMaxLen} {\b IN}  maximum bytes that {\i parVal}  can hold, including the terminating '\\0'\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: parameter is not known\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_VALUE}: parValMaxLen is 0 and {\i parVal}  is not NULL. Or internal representation is damaged\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_VAL_TRUNCATED}: only a part of value could be copied to {\i parVal}  (and {\i parVal}  was not NULL) \par
}
\par
}\par
\par
}
{\xe \v SysParamGetAll\:sysp_api.c}
{\xe \v sysp_api.c\:SysParamGetAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamGetAll (char * {\i buf}, int {\i bufLen}, int {\i alias})}
}\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get all parameters with their values. \par
Build a string containing all known parameters and their values.\par
Each parameter/value tuple is put into a separate line.\par
If a tuple does not fit as a whole in {\i buf} , it is omitted.\par
Example: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \par
brd=EM04\\n\par
kerpar=ip=auto rw\\n\par
e=192.1.1.22:FFFFFF00\\n\par
mmstartup=\\n\par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i buf} {\b OUT}  receives the all parameter/value pairs as a string \par
{\i bufLen} {\b IN}  maximum bytes that {\i buf}  can hold, including the terminating '\\0' \par
{\i alias} {\b IN}  if TRUE, return the alias parameter names rather than the official names\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_VAL_TRUNCATED}: only a part of pairs could be copied to {\i buf}  \par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NO_RESOURCE}: Could not allocate temp. buffer \par
}
\par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamEnum} \par
}\par
\par
}
{\xe \v SysParamGetDefault\:sysp_api.c}
{\xe \v sysp_api.c\:SysParamGetDefault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamGetDefault (const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get default value of single system parameter. \par
This gets the {\b default}  value of the parameter {\i parName} . Parameter name can be either the official parameter name or the alias name.\par
This is currently not supported by all types of parameters, If it is not supported, {\b SYSPARAM_INVAL_VALUE} is returned\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i parVal} {\b OUT}  receives the parameter's value as a string \par
{\i parValMaxLen} {\b IN}  maximum bytes that {\i parVal}  can hold, including the terminating '\\0'\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: parameter is not known\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_VALUE}: parValMaxLen is 0 and {\i parVal}  is not NULL. Or default value not available\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_VAL_TRUNCATED}: only a part of value could be copied to {\i parVal}  (and {\i parVal}  was not NULL) \par
}
\par
}\par
\par
}
{\xe \v SysParamMakePersistant\:sysp_api.c}
{\xe \v sysp_api.c\:SysParamMakePersistant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamMakePersistant (const char * {\i parName})}
}\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Write temporary changes to NV storage. \par
Make temporary changes persistant. Temporary changes are those made by calls to {\b SysParamSetEx()} with {\b SYSPARAM_SA_NON_PERSISTANT} flag set.\par
This function can either write all parameter groups (if {\i parName}  is NULL) or a specific parameter group (in this case parName must specify a parameter of that group).\par
For example, to save the VxWorks bootline parameter group to NV storage, call SysParamMakePersistant("s").\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix.\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: {\i parName}  is not NULL and is not known\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_EEPROM_ERROR}: Error during NVS update\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_READ_ONLY}: Specified parameter cannot be made persistant \par
}
\par
}\par
\par
}
{\xe \v SysParamNumParams\:sysp_api.c}
{\xe \v sysp_api.c\:SysParamNumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamNumParams (int * {\i numP})}
}\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get total number of parameters handled by Sysparam. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i *numP} {\b OUT}  receives number of parameters\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called \par
}
\par
}\par
\par
}
{\xe \v SysParamSet\:sysp_api.c}
{\xe \v sysp_api.c\:SysParamSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamSet (const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd})}
}\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Modify value of single system parameter. \par
This updates the internal representation of the specified parameter {\i parName}  and the parameter is written to non-volatile storage.\par
It is a shortcut to {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  SysParamSetEx( parName, parVal, passwd, 0 ); \par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i parVal} {\b IN}  new value for parameter as a string \par
{\i passwd} {\b IN}  an optional password for protected parameters can be NULL if parameter is not protected\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: parameter is not known\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_VALUE}: invalid value for parameter or {\i parVal}  too long\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_EEPROM_ERROR}: Error during NVS update\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_READ_ONLY}: Parameter is read only or bad password was specified.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NO_RESOURCE}: {\i parVal}  could not be stored due to lack of space (in NV storage or temp. buffers).\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_VAL_TRUNCATED}: only parts of {\i parVal}  have been stored.\par
}
\par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamSetEx} \par
}\par
\par
}
{\xe \v SysParamSetDefaults\:sysp_api.c}
{\xe \v sysp_api.c\:SysParamSetDefaults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamSetDefaults (void)}
}\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set all non volatile parameters to defaults. \par
All parameter groups that are stored in non volatile storage are set to their default values and are written into NV storage.\par
Inventory/production parameter groups are not modified by this call.\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_EEPROM_ERROR}: Error during NVS update \par
}
\par
}\par
\par
}
{\xe \v SysParamSetEx\:sysp_api.c}
{\xe \v sysp_api.c\:SysParamSetEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamSetEx (const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd}, int {\i attr})}
}\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Modify value of single system parameter (extended version). \par
This updates the internal representation of the specified parameter {\i parName} . Parameter name can be either the official parameter name or the alias name.\par
If {\b SYSPARAM_SA_NON_PERSISTANT} is not specified in {\i attr} , the parameter is also written into non volatile storage (NVS).\par
If {\b SYSPARAM_SA_NON_PERSISTANT} is given, NVS is not updated. NVS can be updated by another call to SysParamSetEx for a parameter in the same parameter group (with SYSPARAM_SA_NON_PERSISTANT clear) or by calling {\b SysParamMakePersistant()}.\par
Parameters that are read-only for the normal user can be written to by specifying attribute {\b SYSPARAM_SA_FROM_FIRMWARE} in {\i attr} . This flag should be set only when called from firmware.\par
A parameter's value can be cleared by passing an empty string ("") in {\i parVal} .\par
{\b Restart when production data name has changed}  When modifying the name of a production data section ("brd" parameter), the SYSPARAM library is entirely restarted, since the new name may imply a new EEPROM layout. After SYSPARAM has been restart (which is invisible to the user) the available parameters may have changed. Modifying the board name is only possible with {\b SYSPARAM_SA_NON_PERSISTANT} flag cleared.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i parVal} {\b IN}  new value for parameter as a string \par
{\i passwd} {\b IN}  an optional password for protected parameters can be NULL if parameter is not protected \par
{\i attr} {\b IN}  attribute flags (see {\b SYSPARAM_SET_ATTR})\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: parameter is not known\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_VALUE}: invalid value for parameter or {\i parVal}  too long\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_EEPROM_ERROR}: Error during NVS update\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_READ_ONLY}: Parameter is read only and {\b SYSPARAM_SA_FROM_FIRMWARE} was not set in {\i attr} , or bad password was specified.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NO_RESOURCE}: {\i parVal}  could not be stored due to lack of space (in NV storage or temp. buffers).\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_VAL_TRUNCATED}: only parts of {\i parVal}  have been stored. \par
}
\par
}\par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_apiex.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_apiex.c}
{\xe \v sysp_apiex.c}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Extended API routines of SYSPARAM.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b SysParamErrStr} (int errCode)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Convert SYSPARAM error code to string. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamSetFmt} (const char *parName, const char *passwd, int attr, const char *fmt,...)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set system parameter using printf style arguments. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamSignedInt} (const char *par, int base, int32 def, int32 *valueP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get value of signed integer system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamDefSignedInt} (const char *par, int base, int32 def, int32 *valueP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get default value of signed integer system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamUnsignedInt} (const char *par, int base, u_int32 def, u_int32 *valueP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get value of unsigned integer system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamUnsignedIntArray} (const char *par, int base, int no, u_int32 *defP, u_int32 *valueP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get array of unsigned integer system parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamBool} (const char *par, int def)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get value of boolean system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MenBrdNameWithModel} (char prefix, char *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Determine chars 3..9 (e.g. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MenBrdProdString} (char prefix, char *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Make full production data string. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsWriteRaw} ({\b SYSP_CONST_STRING} nvsName, int offset, int size, const u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Write specified NVS section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsReadRaw} ({\b SYSP_CONST_STRING} nvsName, int offset, int size, u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Read raw from specified NVS section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEnum} (int idx, {\b SYSPARAM_NVS_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Enumerate NVS sections. }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Extended API routines of SYSPARAM. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2010/06/07 16:15:20 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.10 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v SYSP_MenBrdNameWithModel\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SYSP_MenBrdNameWithModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MenBrdNameWithModel (char {\i prefix}, char * {\i buf})}
}\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Determine chars 3..9 (e.g. \par
EM04-00) of MEN product name\par
Uses SYSP_brd and SYSP_brdmod parameter. SYSP_brd value is padded with '-' if it contains only 4 chars\par
If SYSP_brd not valid, return empty string. If SYSP_brdmod not valid, model number will be missing from string\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i prefix} {\b IN}  board prefix (e.g. 'c') (0 if none) \par
{\i buf} {\b OUT}  filled with name (must have space for 7 chars + EOS)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_MenBrdProdString\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SYSP_MenBrdProdString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MenBrdProdString (char {\i prefix}, char * {\i buf})}
}\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Make full production data string. \par
Generates a string like this: EM04-00, Rev 01.02.03, Serial 8765\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i prefix} {\b IN}  board prefix (e.g. 'c') (0 if none) \par
{\i buf} {\b OUT}  filled with name (must have space for approx. 40 chars)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_NvsEnum\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SYSP_NvsEnum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEnum (int {\i idx}, {\b SYSPARAM_NVS_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enumerate NVS sections. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i idx} {\b IN}  nth section to query \par
{\i info} {\b OUT}  filled with info about NVS section\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 if ok (section found), or SYSPARAM_INVAL_VALUE if {\i idx}  out of range \par
}\par
\par
}
{\xe \v SYSP_NvsReadRaw\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SYSP_NvsReadRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsReadRaw ({\b SYSP_CONST_STRING} {\i nvsName}, int {\i offset}, int {\i size}, u_int8 * {\i data})}
}\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Read raw from specified NVS section. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvsName} {\b IN}  NVS section name to read from \par
{\i offset} {\b IN}  starting byte offset within NVS \par
{\i size} {\b IN}  number of bytes to read from NVS \par
{\i data} {\b OUT}  receives read data \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code \par
}\par
\par
}
{\xe \v SYSP_NvsWriteRaw\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SYSP_NvsWriteRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsWriteRaw ({\b SYSP_CONST_STRING} {\i nvsName}, int {\i offset}, int {\i size}, const u_int8 * {\i data})}
}\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Write specified NVS section. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvsName} {\b IN}  NVS section to write\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SysParamBool\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SysParamBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamBool (const char * {\i par}, int {\i def})}
}\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get value of boolean system parameter. \par
On error, or when parameter is empty, default value {\i def}  is applied.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i def} {\b IN}  default value (0/1)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid value of system parameter or {\i def}  on error \par
}\par
\par
}
{\xe \v SysParamDefSignedInt\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SysParamDefSignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamDefSignedInt (const char * {\i par}, int {\i base}, int32 {\i def}, int32 * {\i valueP})}
}\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get default value of signed integer system parameter. \par
On error, or when parameter is empty, default value {\i def}  is applied. If parameter is empty, no error is returned.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i base} {\b IN}  radix 10 or 16 \par
{\i def} {\b IN}  default value (if parameter/value invalid) \par
{\i valueP} {\b OUT}  receives value of system parameter\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamGet} \par
}\par
\par
}
{\xe \v SysParamErrStr\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SysParamErrStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* SysParamErrStr (int {\i errCode})}
}\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Convert SYSPARAM error code to string. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i errCode} {\b IN}  SYSPARAM error code\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Error string \par
}\par
\par
}
{\xe \v SysParamSetFmt\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SysParamSetFmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamSetFmt (const char * {\i parName}, const char * {\i passwd}, int {\i attr}, const char * {\i fmt}, ...)}
}\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set system parameter using printf style arguments. \par
{{\b \par
Warning:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Formatted string may not exceed 40 chars!\par
}{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i passwd} {\b IN}  an optional password for protected parameters can be NULL if parameter is not protected \par
{\i attr} {\b IN}  attribute flags (see {\b SYSPARAM_SET_ATTR}) \par
{\i fmt} {\b IN}  printf like format string \par
{\i ...} {\b IN}  arguments for format\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamSetEx} \par
}\par
\par
}
{\xe \v SysParamSignedInt\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SysParamSignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamSignedInt (const char * {\i par}, int {\i base}, int32 {\i def}, int32 * {\i valueP})}
}\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get value of signed integer system parameter. \par
On error, or when parameter is empty, default value {\i def}  is applied. If parameter is empty, no error is returned.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i base} {\b IN}  radix 10 or 16 \par
{\i def} {\b IN}  default value \par
{\i valueP} {\b OUT}  receives value of system parameter\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamGet} \par
}\par
\par
}
{\xe \v SysParamUnsignedInt\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SysParamUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamUnsignedInt (const char * {\i par}, int {\i base}, u_int32 {\i def}, u_int32 * {\i valueP})}
}\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get value of unsigned integer system parameter. \par
On error, or when parameter is empty, default value {\i def}  is applied. If parameter is empty, no error is returned.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i base} {\b IN}  radix 10 or 16 \par
{\i def} {\b IN}  default value \par
{\i valueP} {\b OUT}  receives value of system parameter\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamGet} \par
}\par
\par
}
{\xe \v SysParamUnsignedIntArray\:sysp_apiex.c}
{\xe \v sysp_apiex.c\:SysParamUnsignedIntArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamUnsignedIntArray (const char * {\i par}, int {\i base}, int {\i no}, u_int32 * {\i defP}, u_int32 * {\i valueP})}
}\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get array of unsigned integer system parameters. \par
On error, or when parameter is empty, default value {\i def}  is applied. If parameter is empty, no error is returned.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i base} {\b IN}  radix 10 or 16 \par
{\i no} {\b IN}  number of array elements \par
{\i def} {\b IN}  default values \par
{\i valueP} {\b OUT}  receives value of system parameter\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamGet} \par
}\par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_core.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_core.c}
{\xe \v sysp_core.c}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Core functions.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_BOARD_SPEZIFIC_BAUD_CHECK}(_x_)\~ 1\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b SYSP_Alloc} ({\b SYSP_ALLOC} *alloc, int size)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Allocate block from heap specified with {\i alloc} . }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_AllocUndo} ({\b SYSP_ALLOC} *alloc, int size)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Undo previous alloc. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_AllocInfo} (int *availP, int *minAvailP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get allocator info. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_PostProcessingHookInstall} ({\b SYSP_POST_PROCESS_CB} cb)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Configure one additional postprocessing function. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_RunPostProcessHooks} ({\b SYSP_SUPER} *super, const char *parName, int attr, int errCode)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Run all postprocessing functions. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_SuperMmsmbRead} ({\b SYSP_SUPER} *super, {\b SYSP_NVS_ADR} nvsAdr, int offset, int size, u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Super object method to read from EEPROM. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_SuperMmsmbWrite} ({\b SYSP_SUPER} *super, {\b SYSP_NVS_ADR} nvsAdr, int offset, int size, const u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Super object method to write EEPROM. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_SuperMmsmbPostProcessSetParam} ({\b SYSP_SUPER} *super, const char *parName, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SetParam postprocessing routine for MENMON/SMB. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_SuperMmsmbInit} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize extended super object for MENMON/SMB. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsCommonReadNvs} ({\b SYSP_NV_STORAGE} *nvs, int offset, int size, u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Common NVS read from EEPROM routine. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsCommonWriteNvs} ({\b SYSP_NV_STORAGE} *nvs, int offset, int size, const u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Common NVS write to EEPROM routine. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b NvsPrefixMatch} ({\b SYSP_NV_STORAGE} *nvs, const char *parName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if {\i parName}  matches the prefix of {\i nvs}  object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsCommonNumParams} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get number of parameters of NVS. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsCommonEnumParams} ({\b SYSP_NV_STORAGE} *nvs, int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Enum NVS params. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsCommonSetParam} ({\b SYSP_NV_STORAGE} *nvs, const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set NVS parameter default function Check for parName baud if baudrate is valid. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsCommonGetParam} ({\b SYSP_NV_STORAGE} *nvs, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get NVS parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsCommonGetParamDefault} ({\b SYSP_NV_STORAGE} *nvs, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get NVS default parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsCommonSetDefaults} ({\b SYSP_NV_STORAGE} *nvs, int force)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set NVS defaults. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsCommonSave} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Save NVS. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_NV_STORAGE} * {\b SYSP_NvsCreate} (int objSize, const char *nvsName, {\b SYSP_SUPER} *super, const char *prefix, {\b SYSP_NVS_ADR} nvsAdr, u_int32 nvsSize)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create a {\b SYSP_NV_STORAGE} object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_NvsAdd} ({\b SYSP_SUPER} *super, {\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Add a NV storage object to super list of NVS object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_NV_STORAGE} * {\b SYSP_NvsFind} ({\b SYSP_SUPER} *super, const char *nvsName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Find NV storage object by name. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_ParGrpAdd} ({\b SYSP_NV_STORAGE} *nvs, {\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Add a parameter group object to NVS list of parameter groups. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PAR_GRP} * {\b SYSP_ParNameToGroup} ({\b SYSP_SUPER} *super, const char *parName, const char **pureNameP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Find parameter group that handles {\i parName} . }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b SYSP_Prefix} (const char *parName, char *prefix)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Determine prefix part of {\i parName} . }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_FullParName} ({\b SYSP_NV_STORAGE} *nvs, const char *parName, char *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Make full parameter name incl. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ContainsBlanks} (const char *s)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if {\i s}  contains blanks or tabs. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} * {\b SYSP_FindParDesc} (const {\b SYSP_PAR_DESC} *parList, const char *parName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Find parameter description structure in array by parameter name. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ParDescArrayLen} (const {\b SYSP_PAR_DESC} *parList)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i get number of entries in SYSP_PAR_DESC_ARRAY }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StringArrayLen} (const {\b SYSP_CONST_STRING} *arr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Count number of string pointers in array until NULL pointer found. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StringArrFindStr} (const {\b SYSP_CONST_STRING} *arr, {\b SYSP_CONST_STRING} str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if string array {\i contains}  a string with the same value as {\i str}  {\i arr}  must be NULL terminated. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StringArrCopy} ({\b SYSP_CONST_STRING} dst[], const {\b SYSP_CONST_STRING} src[], int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i copy stringtable {\i src}  to stringtbl {\i dst}  }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StrSafeCpy} (char *dst, const char *src, int destLen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawNatIntD} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from int (native endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawNatIntD} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to int (native endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawNatIntX} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from int (native endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawNatIntX} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to int (native endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU32D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int32 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU32D} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int32 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU32X} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int32 (big endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU32X} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int32 (big endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU16X} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int16 (big endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU16X} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int16 (big endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawS16D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from int16 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawS16D} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to int16 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU16D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int16 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU16D} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int16 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU8X} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int8, hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU8X} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int8, hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU8D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int8, decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU8D} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int8, decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawStr} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from string returns an empty string if {\i src}  (raw data) contains any non-printable char. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawStr} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to string (hope it was checked by ValidateStr) }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawStrUpper} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to string (convert to upper case; hope it was checked by ValidateStr) }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawRev} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from revision number returns empty string if all bytes are 0xff }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawRev} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to revision number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateRev} (const char *s, int notused)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check revision number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawEth} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from ethernet MAC number returns empty string if all bytes are 0xff }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawEth} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to ethernet MAC number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateEth} (const char *s, int notused)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check ethernet MAC number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawTcal} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from touch calibration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawTcal} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to touch calibration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateTcal} (const char *s, int notused)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check revision number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool} (char *dest, int destLen, void *src, u_int8 bitNo)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from boolean }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool7} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool6} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool5} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool4} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool3} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool2} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool1} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool0} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool} (void *dest, const char *src, u_int8 bitNo)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to boolean (accept only '0' or '1') }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool7} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool6} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool5} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool4} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool3} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool2} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool1} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool0} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateBool} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check boolean (accept only '0' or '1') }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawMchoice} ({\b SYSP_CONST_STRING} *choiceArr, char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from multi choice index to string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawMchoice} ({\b SYSP_CONST_STRING} *choiceArr, void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to multi choice index }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateMchoice} ({\b SYSP_CONST_STRING} *choiceArr, const char *s)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check multi choice value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawNspeed} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from Nspeed number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawNspeed} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to Nspeed number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateNspeed} (const char *s, int notused)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check Nspeed value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawComMode} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from COM mode number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawComMode} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to COM mode number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateComMode} (const char *s, int notused)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check COM mode value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateBaud} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check baudrate value If {\i max}  is 0, no range checking is done }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateD} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check decimal unsigned integers If {\i max}  is 0, no range checking is done }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateSD} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check decimal signed integers If {\i max}  is 0, no range checking is done }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateX} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check hexadecimal unsigned integers If {\i max}  is 0, no range checking is done }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateStr} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check length of string {\i max}  is the max allowed string length, excluding term '\\0' }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_SUPER} * {\b SYSP_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i the only global variable. }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Core functions. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2010/06/07 16:18:54 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.18 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_BOARD_SPEZIFIC_BAUD_CHECK(_x_)} returns 1 for wrong baudrates or 0\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v SYSP_BOARD_SPEZIFIC_BAUD_CHECK\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_BOARD_SPEZIFIC_BAUD_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_BOARD_SPEZIFIC_BAUD_CHECK(_x_)\~ 1}
}\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v NvsPrefixMatch\:sysp_core.c}
{\xe \v sysp_core.c\:NvsPrefixMatch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* NvsPrefixMatch ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i parName}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if {\i parName}  matches the prefix of {\i nvs}  object. \par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid NULL if prefix doesn't match or pointer to parName without prefix \par
}\par
\par
}
{\xe \v SYSP_Alloc\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_Alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* SYSP_Alloc ({\b SYSP_ALLOC} * {\i alloc}, int {\i size})}
}\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Allocate block from heap specified with {\i alloc} . \par
Tries to allocate {\i size}  bytes from the heap maintained with {\i alloc} . On Success, returns a pointer to the first byte of the block. The data block is filled with zeroes.\par
If not enough mem available, NULL is returned.\par
{{\b \par
Warning:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This is not a full malloc() implementation. A memory block can only be free'ed when no other allocs have been made in the meantime; i.e. it works like a stack.\par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_AllocUndo}, {\b SYSP_ALLOC}, {\b SYSP_ALLOC_UNDO}, {\b SYSP_ALLOC_INIT} \par
}\par
\par
}
{\xe \v SYSP_AllocInfo\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_AllocInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_AllocInfo (int * {\i availP}, int * {\i minAvailP})}
}\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get allocator info. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i availP} {\b OUT}  receices currently available mem \par
{\i minAvailP} {\b OUT}  receices minimum available mem \par
}
\par
\par
}
{\xe \v SYSP_AllocUndo\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_AllocUndo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_AllocUndo ({\b SYSP_ALLOC} * {\i alloc}, int {\i size})}
}\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Undo previous alloc. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_Alloc}, {\b SYSP_ALLOC_UNDO} \par
}\par
\par
}
{\xe \v SYSP_ContainsBlanks\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ContainsBlanks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ContainsBlanks (const char * {\i s})}
}\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if {\i s}  contains blanks or tabs. \par
\par
\par
}
{\xe \v SYSP_FindParDesc\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FindParDesc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC}* SYSP_FindParDesc (const {\b SYSP_PAR_DESC} * {\i parList}, const char * {\i parName})}
}\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Find parameter description structure in array by parameter name. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parList} {\b IN}  parameter list \par
{\i parName} {\b IN}  parameter name to find (official or alias) \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYS_PAR_DESC structure or NULL if not found \par
}\par
\par
}
{\xe \v SYSP_FromRawBool\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool (char * {\i dest}, int {\i destLen}, void * {\i src}, u_int8 {\i bitNo})}
}\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from boolean \par
\par
\par
}
{\xe \v SYSP_FromRawBool0\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawBool0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool0 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool1\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawBool1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool1 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool2\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawBool2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool2 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool3\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawBool3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool3 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool4\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawBool4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool4 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool5\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawBool5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool5 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool6\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawBool6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool6 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool7\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawBool7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool7 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawComMode\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawComMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawComMode (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from COM mode number \par
\par
\par
}
{\xe \v SYSP_FromRawEth\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawEth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawEth (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from ethernet MAC number returns empty string if all bytes are 0xff \par
\par
\par
}
{\xe \v SYSP_FromRawMchoice\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawMchoice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawMchoice ({\b SYSP_CONST_STRING} * {\i choiceArr}, char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from multi choice index to string \par
{\i src}  is assumed to be an u_int8 value containing the multiple choice index (0..n).\par
If {\i src's}  content is out of range, an empty string is returned \par
\par
}
{\xe \v SYSP_FromRawNatIntD\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawNatIntD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawNatIntD (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from int (native endian), decimal \par
\par
\par
}
{\xe \v SYSP_FromRawNatIntX\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawNatIntX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawNatIntX (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from int (native endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_FromRawNspeed\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawNspeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawNspeed (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from Nspeed number \par
\par
\par
}
{\xe \v SYSP_FromRawRev\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawRev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawRev (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from revision number returns empty string if all bytes are 0xff \par
\par
\par
}
{\xe \v SYSP_FromRawS16D\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawS16D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawS16D (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from int16 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_FromRawStr\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawStr (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from string returns an empty string if {\i src}  (raw data) contains any non-printable char. \par
\par
\par
}
{\xe \v SYSP_FromRawTcal\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawTcal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawTcal (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from touch calibration \par
\par
\par
}
{\xe \v SYSP_FromRawU16D\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawU16D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU16D (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int16 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_FromRawU16X\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawU16X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU16X (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int16 (big endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_FromRawU32D\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawU32D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU32D (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int32 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_FromRawU32X\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawU32X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU32X (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int32 (big endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_FromRawU8D\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawU8D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU8D (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int8, decimal \par
\par
\par
}
{\xe \v SYSP_FromRawU8X\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FromRawU8X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU8X (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int8, hexadecimal \par
\par
\par
}
{\xe \v SYSP_FullParName\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_FullParName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* SYSP_FullParName ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i parName}, char * {\i buf})}
}\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Make full parameter name incl. \par
prefix\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  nvs object \par
{\i parName} {\b IN}  parameter name without prefix \par
{\i buf} {\b OUT}  receives the full parameter name. must have space for SYSP_PREFIX_LEN + SYSP_PARNAME_LEN chars \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pointer to buf \par
}\par
\par
}
{\xe \v SYSP_NvsAdd\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsAdd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_NvsAdd ({\b SYSP_SUPER} * {\i super}, {\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Add a NV storage object to super list of NVS object. \par
\par
\par
}
{\xe \v SYSP_NvsCommonEnumParams\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsCommonEnumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsCommonEnumParams ({\b SYSP_NV_STORAGE} * {\i nvs}, int {\i idx}, int {\i alias}, {\b SYSPARAM_PARAM_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enum NVS params. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_NV_STORAGE::enumParams} \par
}\par
\par
}
{\xe \v SYSP_NvsCommonGetParam\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsCommonGetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsCommonGetParam ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get NVS parameter. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_NV_STORAGE::getParam} \par
}\par
\par
}
{\xe \v SYSP_NvsCommonGetParamDefault\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsCommonGetParamDefault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsCommonGetParamDefault ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get NVS default parameter. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_NV_STORAGE::getParam} \par
}\par
\par
}
{\xe \v SYSP_NvsCommonNumParams\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsCommonNumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsCommonNumParams ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get number of parameters of NVS. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_NV_STORAGE::numParams} \par
}\par
\par
}
{\xe \v SYSP_NvsCommonReadNvs\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsCommonReadNvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsCommonReadNvs ({\b SYSP_NV_STORAGE} * {\i nvs}, int {\i offset}, int {\i size}, u_int8 * {\i data})}
}\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Common NVS read from EEPROM routine. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_NV_STORAGE::readNvs} \par
}\par
\par
}
{\xe \v SYSP_NvsCommonSave\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsCommonSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsCommonSave ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Save NVS. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_NV_STORAGE::save} \par
}\par
\par
}
{\xe \v SYSP_NvsCommonSetDefaults\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsCommonSetDefaults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsCommonSetDefaults ({\b SYSP_NV_STORAGE} * {\i nvs}, int {\i force})}
}\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set NVS defaults. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_NV_STORAGE::setDefaults} \par
}\par
\par
}
{\xe \v SYSP_NvsCommonSetParam\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsCommonSetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsCommonSetParam ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd}, int {\i attr})}
}\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set NVS parameter default function Check for parName baud if baudrate is valid. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_NV_STORAGE::setParam} \par
}\par
\par
}
{\xe \v SYSP_NvsCommonWriteNvs\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsCommonWriteNvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsCommonWriteNvs ({\b SYSP_NV_STORAGE} * {\i nvs}, int {\i offset}, int {\i size}, const u_int8 * {\i data})}
}\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Common NVS write to EEPROM routine. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_NV_STORAGE::writeNvs} \par
}\par
\par
}
{\xe \v SYSP_NvsCreate\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_NV_STORAGE}* SYSP_NvsCreate (int {\i objSize}, const char * {\i nvsName}, {\b SYSP_SUPER} * {\i super}, const char * {\i prefix}, {\b SYSP_NVS_ADR} {\i nvsAdr}, u_int32 {\i nvsSize})}
}\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create a {\b SYSP_NV_STORAGE} object. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i objSize} {\b IN}  size of object (>= {\b SYSP_NV_STORAGE} structure) \par
{\i nvsName} {\b IN}  name of NVS (must remain intact!) \par
{\i super} {\b IN}  sysparam super object \par
{\i prefix} {\b IN}  NVS parameter name prefix (up to 3 chars), caller can destroy pointer later \par
{\i nvsAdr} {\b IN}  NVS address \par
{\i nvsSize} {\b IN}  size of NVS section in bytes\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid allocated and initialized {\b SYSP_NV_STORAGE} object or NULL if alloc failed.\par
}all method pointers are set to their default functions \par
\par
}
{\xe \v SYSP_NvsFind\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_NvsFind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_NV_STORAGE}* SYSP_NvsFind ({\b SYSP_SUPER} * {\i super}, const char * {\i nvsName})}
}\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Find NV storage object by name. \par
\par
\par
}
{\xe \v SYSP_ParDescArrayLen\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ParDescArrayLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ParDescArrayLen (const {\b SYSP_PAR_DESC} * {\i parList})}
}\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
get number of entries in SYSP_PAR_DESC_ARRAY \par
\par
\par
}
{\xe \v SYSP_ParGrpAdd\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ParGrpAdd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_ParGrpAdd ({\b SYSP_NV_STORAGE} * {\i nvs}, {\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Add a parameter group object to NVS list of parameter groups. \par
\par
\par
}
{\xe \v SYSP_ParNameToGroup\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ParNameToGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_PAR_GRP}* SYSP_ParNameToGroup ({\b SYSP_SUPER} * {\i super}, const char * {\i parName}, const char ** {\i pureNameP})}
}\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Find parameter group that handles {\i parName} . \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i super} {\b IN}  SYSPARAM super object \par
{\i parName} {\b IN}  parameter name to (including NVS prefix), \par
{\i *pureNameP} {\b OUT}  if not NULL, receives a pointer to the pure parameter name without prefix \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid parameter group or NULL if not found \par
}\par
\par
}
{\xe \v SYSP_PostProcessingHookInstall\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_PostProcessingHookInstall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_PostProcessingHookInstall ({\b SYSP_POST_PROCESS_CB} {\i cb})}
}\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Configure one additional postprocessing function. \par
This function is called from SysParamSet whenever a parameter's value is changed (regardless if the change was marked persistent)\par
Overwrites any hook previously installed \par
\par
}
{\xe \v SYSP_Prefix\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_Prefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* SYSP_Prefix (const char * {\i parName}, char * {\i prefix})}
}\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Determine prefix part of {\i parName} . \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name to (including NVS prefix), e.g. "c-brd" \par
{\i prefix} {\b OUT}  receives the prefix string (null terminated) (3 chars + term. max). \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid parameter name without prefix If prefix part is longer than 3 chars, prefix will be empty \par
}\par
\par
}
{\xe \v SYSP_RunPostProcessHooks\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_RunPostProcessHooks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_RunPostProcessHooks ({\b SYSP_SUPER} * {\i super}, const char * {\i parName}, int {\i attr}, int {\i errCode})}
}\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Run all postprocessing functions. \par
\par
\par
}
{\xe \v SYSP_StringArrayLen\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_StringArrayLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StringArrayLen (const {\b SYSP_CONST_STRING} * {\i arr})}
}\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Count number of string pointers in array until NULL pointer found. \par
\par
\par
}
{\xe \v SYSP_StringArrCopy\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_StringArrCopy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StringArrCopy ({\b SYSP_CONST_STRING} {\i dst}[], const {\b SYSP_CONST_STRING} {\i src}[], int {\i max})}
}\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
copy stringtable {\i src}  to stringtbl {\i dst}  \par
Copy {\i max}  entries (excl. NULL terminator), make sure that {\i dst}  is NULL terminated\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid number of entries copied (excluding NULL terminator) \par
}\par
\par
}
{\xe \v SYSP_StringArrFindStr\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_StringArrFindStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StringArrFindStr (const {\b SYSP_CONST_STRING} * {\i arr}, {\b SYSP_CONST_STRING} {\i str})}
}\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if string array {\i contains}  a string with the same value as {\i str}  {\i arr}  must be NULL terminated. \par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid index in {\i arr}  or -1 if not found \par
}\par
\par
}
{\xe \v SYSP_StrSafeCpy\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_StrSafeCpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StrSafeCpy (char * {\i dst}, const char * {\i src}, int {\i destLen})}
}\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_SuperMmsmbInit\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_SuperMmsmbInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_SuperMmsmbInit ({\b SYSP_MMSMB_SUPER} * {\i xSuper})}
}\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize extended super object for MENMON/SMB. \par
Caller must initialize the following xSuper elements:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
s.alloc\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
s.reInit\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
initBlk \par
}
\par
\par
}
{\xe \v SYSP_SuperMmsmbPostProcessSetParam\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_SuperMmsmbPostProcessSetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_SuperMmsmbPostProcessSetParam ({\b SYSP_SUPER} * {\i super}, const char * {\i parName}, int {\i attr})}
}\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SetParam postprocessing routine for MENMON/SMB. \par
Updates the MENMON parameter string in memory \par
\par
}
{\xe \v SYSP_SuperMmsmbRead\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_SuperMmsmbRead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_SuperMmsmbRead ({\b SYSP_SUPER} * {\i super}, {\b SYSP_NVS_ADR} {\i nvsAdr}, int {\i offset}, int {\i size}, u_int8 * {\i data})}
}\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Super object method to read from EEPROM. \par
This implementation supports SMB EEPROMs only and uses the function callback passed through the initBlk.\par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_SUPER::readNvs} \par
}\par
\par
}
{\xe \v SYSP_SuperMmsmbWrite\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_SuperMmsmbWrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_SuperMmsmbWrite ({\b SYSP_SUPER} * {\i super}, {\b SYSP_NVS_ADR} {\i nvsAdr}, int {\i offset}, int {\i size}, const u_int8 * {\i data})}
}\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Super object method to write EEPROM. \par
This implementation supports SMB EEPROMs only and uses the function callback passed through the initBlk.\par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_SUPER::writeNvs} \par
}\par
\par
}
{\xe \v SYSP_ToRawBool\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool (void * {\i dest}, const char * {\i src}, u_int8 {\i bitNo})}
}\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to boolean (accept only '0' or '1') \par
\par
\par
}
{\xe \v SYSP_ToRawBool0\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawBool0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool0 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool1\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawBool1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool1 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool2\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawBool2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool2 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool3\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawBool3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool3 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool4\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawBool4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool4 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool5\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawBool5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool5 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool6\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawBool6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool6 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool7\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawBool7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool7 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawComMode\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawComMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawComMode (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to COM mode number \par
\par
\par
}
{\xe \v SYSP_ToRawEth\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawEth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawEth (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to ethernet MAC number \par
\par
\par
}
{\xe \v SYSP_ToRawMchoice\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawMchoice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawMchoice ({\b SYSP_CONST_STRING} * {\i choiceArr}, void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to multi choice index \par
if {\i src}  does not match any choice, set index to 0 \par
\par
}
{\xe \v SYSP_ToRawNatIntD\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawNatIntD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawNatIntD (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to int (native endian), decimal \par
\par
\par
}
{\xe \v SYSP_ToRawNatIntX\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawNatIntX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawNatIntX (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to int (native endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_ToRawNspeed\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawNspeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawNspeed (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to Nspeed number \par
\par
\par
}
{\xe \v SYSP_ToRawRev\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawRev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawRev (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to revision number \par
\par
\par
}
{\xe \v SYSP_ToRawS16D\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawS16D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawS16D (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to int16 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_ToRawStr\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawStr (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to string (hope it was checked by ValidateStr) \par
\par
\par
}
{\xe \v SYSP_ToRawStrUpper\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawStrUpper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawStrUpper (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to string (convert to upper case; hope it was checked by ValidateStr) \par
\par
\par
}
{\xe \v SYSP_ToRawTcal\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawTcal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawTcal (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to touch calibration \par
\par
\par
}
{\xe \v SYSP_ToRawU16D\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawU16D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU16D (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int16 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_ToRawU16X\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawU16X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU16X (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int16 (big endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_ToRawU32D\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawU32D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU32D (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int32 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_ToRawU32X\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawU32X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU32X (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int32 (big endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_ToRawU8D\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawU8D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU8D (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int8, decimal \par
\par
\par
}
{\xe \v SYSP_ToRawU8X\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ToRawU8X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU8X (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int8, hexadecimal \par
\par
\par
}
{\xe \v SYSP_ValidateBaud\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateBaud}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateBaud (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check baudrate value If {\i max}  is 0, no range checking is done \par
\par
\par
}
{\xe \v SYSP_ValidateBool\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateBool (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check boolean (accept only '0' or '1') \par
\par
\par
}
{\xe \v SYSP_ValidateComMode\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateComMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateComMode (const char * {\i s}, int {\i notused})}
}\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check COM mode value \par
\par
\par
}
{\xe \v SYSP_ValidateD\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateD (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check decimal unsigned integers If {\i max}  is 0, no range checking is done \par
\par
\par
}
{\xe \v SYSP_ValidateEth\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateEth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateEth (const char * {\i s}, int {\i notused})}
}\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check ethernet MAC number \par
\par
\par
}
{\xe \v SYSP_ValidateMchoice\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateMchoice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateMchoice ({\b SYSP_CONST_STRING} * {\i choiceArr}, const char * {\i s})}
}\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check multi choice value \par
\par
\par
}
{\xe \v SYSP_ValidateNspeed\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateNspeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateNspeed (const char * {\i s}, int {\i notused})}
}\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check Nspeed value \par
\par
\par
}
{\xe \v SYSP_ValidateRev\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateRev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateRev (const char * {\i s}, int {\i notused})}
}\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check revision number \par
\par
\par
}
{\xe \v SYSP_ValidateSD\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateSD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateSD (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check decimal signed integers If {\i max}  is 0, no range checking is done \par
\par
\par
}
{\xe \v SYSP_ValidateStr\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateStr (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check length of string {\i max}  is the max allowed string length, excluding term '\\0' \par
\par
\par
}
{\xe \v SYSP_ValidateTcal\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateTcal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateTcal (const char * {\i s}, int {\i notused})}
}\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check revision number \par
\par
\par
}
{\xe \v SYSP_ValidateX\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_ValidateX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateX (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check hexadecimal unsigned integers If {\i max}  is 0, no range checking is done \par
\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v SYSP_super\:sysp_core.c}
{\xe \v sysp_core.c\:SYSP_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_SUPER}* {\b SYSP_super}}
}\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
the only global variable. \par
Pointer to super object \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_eeprod.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_eeprod.c}
{\xe \v sysp_eeprod.c}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Handler for parameter group conforming to eeprod.h.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEPOFF}(x)\~ offsetof(EEPROD,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ProdFromRawU8D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i as SYSP_FromRawU8D, but returns SYSPARAM_INVAL_VALUE if raw is 0xff }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ProdFromRawU32D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i as SYSP_FromRawU32D, but returns SYSPARAM_INVAL_VALUE if raw is 0xff }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_EeprodGrpCreate} ({\b SYSP_NV_STORAGE} *nvs, const char *expHwNames[], int ignoreNvsError)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EEPROD parameter group. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEeprod} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Handler for parameter group conforming to eeprod.h. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2007/06/28 13:47:52 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.6 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSP_NAME_NO_UPPER_CASE - do not convert board name to upper case\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEPOFF\:sysp_eeprod.c}
{\xe \v sysp_eeprod.c\:_EEPOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEPOFF(x)\~ offsetof(EEPROD,x)}
}\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ProdFromRawU32D\:sysp_eeprod.c}
{\xe \v sysp_eeprod.c\:ProdFromRawU32D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ProdFromRawU32D (char * {\i dest}, int {\i destLen}, void * {\i src}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
as SYSP_FromRawU32D, but returns SYSPARAM_INVAL_VALUE if raw is 0xff \par
\par
\par
}
{\xe \v ProdFromRawU8D\:sysp_eeprod.c}
{\xe \v sysp_eeprod.c\:ProdFromRawU8D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ProdFromRawU8D (char * {\i dest}, int {\i destLen}, void * {\i src}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
as SYSP_FromRawU8D, but returns SYSPARAM_INVAL_VALUE if raw is 0xff \par
\par
\par
}
{\xe \v SYSP_EeprodGrpCreate\:sysp_eeprod.c}
{\xe \v sysp_eeprod.c\:SYSP_EeprodGrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_EeprodGrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i expHwNames}[], int {\i ignoreNvsError})}
}\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EEPROD parameter group. \par
On success, (and if hwName matched), the created parameter group is added to the NVS' list.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i expHwNames} {\b IN}  array of bord names tolerated (null-terminated). Can be NULL, in this case, any name will match. \par
{\i ignoreNvsError} {\b IN}  if TRUE, a NVS read error is ignored\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v SYSP_parListEeprod\:sysp_eeprod.c}
{\xe \v sysp_eeprod.c\:SYSP_parListEeprod}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEeprod}[]}
}\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_REV( SYSP_brdrev,  NULL, _EEPOFF(pd_revision)),\par
\par
    \{ SYSP_sernbr,  NULL, _EEPOFF(pd_serial),\par
      SYSP_ToRawU32D, ProdFromRawU32D, SYSP_ValidateD,\par
      NULL, 0, SYSP_PD_MMPARASTR \},\par
\par
    \{ SYSP_brdmod,  NULL, _EEPOFF(pd_model),\par
      SYSP_ToRawU8D, ProdFromRawU8D, SYSP_ValidateD,\par
      NULL, 0xFF, SYSP_PD_MMPARASTR \},\par
\par
\par
\par
\par
\par
    SYSP_PDE_STRUPPER( SYSP_brd,        NULL, _EEPOFF(pd_hwName), NULL, 6,\par
                       SYSP_PD_MMPARASTR | SYSP_PD_RESTART ),\par
\par
                 \par
    SYSP_PDE_END\par
\}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_eeprod2.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_eeprod2.c}
{\xe \v sysp_eeprod2.c}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Handler for parameter group conforming to EEPROD2 structure.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEP2OFF}(x)\~ offsetof(EEPROD2,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Prod2FromRawU8D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i as SYSP_FromRawU8D, but returns SYSPARAM_INVAL_VALUE if raw is 0xff }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Prod2FromRawU32D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i as SYSP_FromRawU32D, but returns SYSPARAM_INVAL_VALUE if raw is 0xff }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Prod2FromRawDate} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i converts raw date to string returns SYSPARAM_INVAL_VALUE and empty string if raw is 0xffff }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Prod2ToRawDate} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i converts string to raw date value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_Eeprod2GrpCreate} ({\b SYSP_NV_STORAGE} *nvs, const char *expHwNames[], int ignoreNvsError)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EEPROD2 parameter group. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_Eeprod2GrpCreateEx} ({\b SYSP_NV_STORAGE} *nvs, const char *expHwNames[], u_int32 offset, int ignoreNvsError)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EEPROD2 parameter group. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEeprod2} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Handler for parameter group conforming to EEPROD2 structure. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2010/03/11 16:36:19 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.9 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSP_NAME_NO_UPPER_CASE - do not convert board name to upper case\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEP2OFF\:sysp_eeprod2.c}
{\xe \v sysp_eeprod2.c\:_EEP2OFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEP2OFF(x)\~ offsetof(EEPROD2,x)}
}\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v Prod2FromRawDate\:sysp_eeprod2.c}
{\xe \v sysp_eeprod2.c\:Prod2FromRawDate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Prod2FromRawDate (char * {\i dest}, int {\i destLen}, void * {\i src}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
converts raw date to string returns SYSPARAM_INVAL_VALUE and empty string if raw is 0xffff \par
\par
\par
}
{\xe \v Prod2FromRawU32D\:sysp_eeprod2.c}
{\xe \v sysp_eeprod2.c\:Prod2FromRawU32D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Prod2FromRawU32D (char * {\i dest}, int {\i destLen}, void * {\i src}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
as SYSP_FromRawU32D, but returns SYSPARAM_INVAL_VALUE if raw is 0xff \par
\par
\par
}
{\xe \v Prod2FromRawU8D\:sysp_eeprod2.c}
{\xe \v sysp_eeprod2.c\:Prod2FromRawU8D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Prod2FromRawU8D (char * {\i dest}, int {\i destLen}, void * {\i src}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
as SYSP_FromRawU8D, but returns SYSPARAM_INVAL_VALUE if raw is 0xff \par
\par
\par
}
{\xe \v Prod2ToRawDate\:sysp_eeprod2.c}
{\xe \v sysp_eeprod2.c\:Prod2ToRawDate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Prod2ToRawDate (void * {\i dest}, const char * {\i src}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
converts string to raw date value \par
String format must be in US notation {\f2 m/d/y}  \par
Where {\f2 m}  is the month 1..12 (leading zeroes allowed) Where {\f2 d}  is the day of month 1..31 (leading zeroes allowed) Where {\f2 y}  is the year. If no century included, 2000 is added to year.\par
An empty {\i src}  string sets the raw date to 0xffff (invalid)\par
Includes the validation function returns SYSPARAM_INVAL_VALUE if invalid date \par
\par
}
{\xe \v SYSP_Eeprod2GrpCreate\:sysp_eeprod2.c}
{\xe \v sysp_eeprod2.c\:SYSP_Eeprod2GrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_Eeprod2GrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i expHwNames}[], int {\i ignoreNvsError})}
}\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EEPROD2 parameter group. \par
On success, (and if hwName matched), the created parameter group is added to the NVS' list.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i expHwNames} {\b IN}  array of bord names tolerated (null-terminated). Can be NULL, in this case, any name will match. \par
{\i ignoreNvsError} {\b IN}  if TRUE, a NVS read error is ignored\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_Eeprod2GrpCreateEx\:sysp_eeprod2.c}
{\xe \v sysp_eeprod2.c\:SYSP_Eeprod2GrpCreateEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_Eeprod2GrpCreateEx ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i expHwNames}[], u_int32 {\i offset}, int {\i ignoreNvsError})}
}\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EEPROD2 parameter group. \par
On success, (and if hwName matched), the created parameter group is added to the NVS' list.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i expHwNames} {\b IN}  array of bord names tolerated (null-terminated). \par
{\i offset} {\b IN}  offset of EEPROD2 structure inside EEPROM \par
{\i ignoreNvsError} {\b IN}  if TRUE, a NVS read error is ignored\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v SYSP_parListEeprod2\:sysp_eeprod2.c}
{\xe \v sysp_eeprod2.c\:SYSP_parListEeprod2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEeprod2}[]}
}\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_REV( SYSP_brdrev,  NULL, _EEP2OFF(pd_revision)),\par
\par
    \{ SYSP_sernbr,  NULL, _EEP2OFF(pd_serial),\par
      SYSP_ToRawU32D, Prod2FromRawU32D, SYSP_ValidateD,\par
      NULL, 0, SYSP_PD_MMPARASTR \},\par
\par
    \{ SYSP_brdmod,  NULL, _EEP2OFF(pd_model),\par
      SYSP_ToRawU8D, Prod2FromRawU8D, SYSP_ValidateD,\par
      NULL, 0xFF, SYSP_PD_MMPARASTR \},\par
\par
\par
\par
\par
    SYSP_PDE_STRUPPER( SYSP_brd,        NULL, _EEP2OFF(pd_hwName),\par
                       NULL, 6, SYSP_PD_MMPARASTR | SYSP_PD_RESTART ),\par
\par
\par
    \{ SYSP_prodat,  NULL, _EEP2OFF(pd_prodat),\par
      Prod2ToRawDate, Prod2FromRawDate, NULL,\par
      NULL, 0, SYSP_PD_MMPARASTR \},\par
\par
    \{ SYSP_repdat,  NULL, _EEP2OFF(pd_repdat),\par
      Prod2ToRawDate, Prod2FromRawDate, NULL,\par
      NULL, 0, SYSP_PD_MMPARASTR \},\par
\par
    SYSP_PDE_END\par
\}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_em01.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_em01.c}
{\xe \v sysp_em01.c}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid EM01 specific part.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFFLM81}(x)\~ offsetof(LM81_PARMS,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEm01CpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EM01 CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Em01Init} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for EM01. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EM01_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EM01. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_em1Lm81Calib_2V5} [] = "psr2v5_cal"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_em1Lm81Calib_3V3} [] = "psr3v3_cal"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_em1Lm81Calib_5V0} [] = "psr5v_cal"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_em1Lm81Calib_core} [] = "psrcore_cal"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_em1Lm81Calib_1V2} [] = "psr1v2_cal"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1100]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm01Menm} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EM01 CPU EEPROM, menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm01Lm81} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EM01 CPU EEPROM, menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_CONST_STRING} {\b SYSP_parListEm01Mmpara} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in "mmpara" parameter group }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
EM01 specific part. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2009/09/23 08:59:34 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.14 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid MM_CODE_SHRINK - to bring MENMON < 256 kB\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_em01.c}
{\xe \v sysp_em01.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFFLM81\:sysp_em01.c}
{\xe \v sysp_em01.c\:_EEOFFLM81}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFFLM81(x)\~ offsetof(LM81_PARMS,x)}
}\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EM01_SysParamInit\:sysp_em01.c}
{\xe \v sysp_em01.c\:EM01_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EM01_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EM01. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Em01Init\:sysp_em01.c}
{\xe \v sysp_em01.c\:Em01Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Em01Init ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for EM01. \par
Probes for CPU EEPROM and possible ESM carrier boards {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_NvsEm01CpuProbe\:sysp_em01.c}
{\xe \v sysp_em01.c\:SYSP_NvsEm01CpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEm01CpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EM01 CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in EM01 CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_em01.c}
{\xe \v sysp_em01.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1100]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_super\:sysp_em01.c}
{\xe \v sysp_em01.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_em1Lm81Calib_1V2\:sysp_em01.c}
{\xe \v sysp_em01.c\:SYSP_em1Lm81Calib_1V2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_em1Lm81Calib_1V2}[] = "psr1v2_cal"}
}\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_em1Lm81Calib_2V5\:sysp_em01.c}
{\xe \v sysp_em01.c\:SYSP_em1Lm81Calib_2V5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_em1Lm81Calib_2V5}[] = "psr2v5_cal"}
}\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_em1Lm81Calib_3V3\:sysp_em01.c}
{\xe \v sysp_em01.c\:SYSP_em1Lm81Calib_3V3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_em1Lm81Calib_3V3}[] = "psr3v3_cal"}
}\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_em1Lm81Calib_5V0\:sysp_em01.c}
{\xe \v sysp_em01.c\:SYSP_em1Lm81Calib_5V0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_em1Lm81Calib_5V0}[] = "psr5v_cal"}
}\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_em1Lm81Calib_core\:sysp_em01.c}
{\xe \v sysp_em01.c\:SYSP_em1Lm81Calib_core}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_em1Lm81Calib_core}[] = "psrcore_cal"}
}\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_parListEm01Lm81\:sysp_em01.c}
{\xe \v sysp_em01.c\:SYSP_parListEm01Lm81}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm01Lm81}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
\par
    \par
    \{ SYSP_em1Lm81Calib_2V5,    NULL,   _EEOFFLM81(lm81_2V5),   SYSP_ToRawU8X, SYSP_FromRawU8X, SYSP_ValidateX,   "88", 0xFF, SYSP_PD_NONE \}, \par
    \{ SYSP_em1Lm81Calib_core,   NULL,   _EEOFFLM81(lm81_vcore), SYSP_ToRawU8X, SYSP_FromRawU8X, SYSP_ValidateX,   "FF", 0xFF, SYSP_PD_NONE \},\par
    \{ SYSP_em1Lm81Calib_3V3,    NULL,   _EEOFFLM81(lm81_3V3),   SYSP_ToRawU8X, SYSP_FromRawU8X, SYSP_ValidateX,   "FF", 0xFF, SYSP_PD_NONE \},\par
    \{ SYSP_em1Lm81Calib_5V0,    NULL,   _EEOFFLM81(lm81_5V0),   SYSP_ToRawU8X, SYSP_FromRawU8X, SYSP_ValidateX,   "FF", 0xFF, SYSP_PD_NONE \},\par
    \{ SYSP_em1Lm81Calib_1V2,    NULL,   _EEOFFLM81(lm81_1V2),   SYSP_ToRawU8X, SYSP_FromRawU8X, SYSP_ValidateX,   "FF", 0xFF, SYSP_PD_NONE \},\par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in EM01 CPU EEPROM, menmon section \par
\par
}
{\xe \v SYSP_parListEm01Menm\:sysp_em01.c}
{\xe \v sysp_em01.c\:SYSP_parListEm01Menm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm01Menm}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters in EM01 CPU EEPROM, menmon section \par
\par
\par
}
{\xe \v SYSP_parListEm01Mmpara\:sysp_em01.c}
{\xe \v sysp_em01.c\:SYSP_parListEm01Mmpara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_CONST_STRING} {\b SYSP_parListEm01Mmpara}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_mem0,\par
    SYSP_mem1,\par
    SYSP_flash0,\par
    SYSP_flash1,\par
    SYSP_cpu,\par
    SYSP_cpuclkhz,\par
    SYSP_MPC52XX_inclkhz,\par
    SYSP_memclkhz,\par
    SYSP_MPC52XX_xlbclkhz,\par
    SYSP_MPC52XX_ipbclkhz,\par
    SYSP_pciclkhz,\par
    SYSP_clun,\par
    SYSP_dlun,\par
    SYSP_usbdp,\par
    SYSP_fpga,\par
    SYSP_rststat,\par
    SYSP_mmst,\par
    SYSP_mm,\par
    SYSP_cons,\par
    SYSP_nmac0,\par
    SYSP_rand,\par
    \par
    NULL\par
\}\par
\par
}
list of parameters in "mmpara" parameter group \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_em03.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_em03.c}
{\xe \v sysp_em03.c}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid EM03 specific part.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EM3_DFLT_WDT}\~ "0"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EM3_DFLT_MMSTARTUP}\~ ""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFFF}(x)\~ offsetof(struct flstr_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEm03CpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EM03 CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Em03Init} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for EM03. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EM03_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EM03. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1100]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm03Menm} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EM03 CPU EEPROM, menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm03FlStr} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EM03 boot flash, long string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_CONST_STRING} {\b SYSP_parListEm03Mmpara} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in "mmpara" parameter group }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
EM03 specific part. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2007/03/22 11:09:30 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.10 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSP_EM3_VARIANT_ALCA - alcatel EM3A specific defaults\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_em03.c}
{\xe \v sysp_em03.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFFF\:sysp_em03.c}
{\xe \v sysp_em03.c\:_EEOFFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFFF(x)\~ offsetof(struct flstr_parms,x)}
}\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v EM3_DFLT_MMSTARTUP\:sysp_em03.c}
{\xe \v sysp_em03.c\:EM3_DFLT_MMSTARTUP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EM3_DFLT_MMSTARTUP\~ ""}
}\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v EM3_DFLT_WDT\:sysp_em03.c}
{\xe \v sysp_em03.c\:EM3_DFLT_WDT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EM3_DFLT_WDT\~ "0"}
}\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EM03_SysParamInit\:sysp_em03.c}
{\xe \v sysp_em03.c\:EM03_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EM03_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EM03. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Em03Init\:sysp_em03.c}
{\xe \v sysp_em03.c\:Em03Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Em03Init ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for EM03. \par
Probes for CPU EEPROM and possible ESM carrier boards {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_NvsEm03CpuProbe\:sysp_em03.c}
{\xe \v sysp_em03.c\:SYSP_NvsEm03CpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEm03CpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EM03 CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in EM03 CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_em03.c}
{\xe \v sysp_em03.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1100]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_super\:sysp_em03.c}
{\xe \v sysp_em03.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_parListEm03FlStr\:sysp_em03.c}
{\xe \v sysp_em03.c\:SYSP_parListEm03FlStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm03FlStr}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_STR( SYSP_mmstartup, NULL, _EEOFFF(fl_startup), \par
                  EM3_DFLT_MMSTARTUP, \par
                  EM03_FLASH_STARTUP_LEN, 0 ),\par
    SYSP_PDE_STR( SYSP_kerpar, NULL, _EEOFFF(fl_kerpar), "", \par
                  EM03_FLASH_KERPAR_LEN, 0 ),\par
    \par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in EM03 boot flash, long string \par
\par
}
{\xe \v SYSP_parListEm03Menm\:sysp_em03.c}
{\xe \v sysp_em03.c\:SYSP_parListEm03Menm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm03Menm}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters in EM03 CPU EEPROM, menmon section \par
\par
\par
}
{\xe \v SYSP_parListEm03Mmpara\:sysp_em03.c}
{\xe \v sysp_em03.c\:SYSP_parListEm03Mmpara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_CONST_STRING} {\b SYSP_parListEm03Mmpara}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_mem0,\par
    SYSP_mem1,\par
    SYSP_flash0,\par
    SYSP_cpu,\par
    SYSP_cpuclkhz,\par
    SYSP_memclkhz,\par
    SYSP_pciclkhz,\par
    SYSP_MPC85XX_ccbclkhz,\par
    SYSP_MPC85XX_brgclkhz,\par
    SYSP_MPC85XX_immr,\par
    SYSP_clun,\par
    SYSP_dlun,\par
    SYSP_rststat,   \par
    SYSP_mmst,\par
    SYSP_mm,\par
    SYSP_cons,\par
    SYSP_nmac0,\par
    SYSP_nmac1,\par
    SYSP_nmac2,\par
    NULL\par
\}\par
\par
}
list of parameters in "mmpara" parameter group \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_em04.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_em04.c}
{\xe \v sysp_em04.c}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid EM04 specific part.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFFX}(x)\~ offsetof(struct menmx_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFFF}(x)\~ offsetof(struct flstr_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEm04CpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EM04 CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Em04Init} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for EM04. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Em04SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EM04. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1100]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm04Menm} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EM04 CPU EEPROM, menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm04MenmX} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EM04 CPU EEPROM, menmon extended section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm04FlStr} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EM04 boot flash, long string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_CONST_STRING} {\b SYSP_parListEm04Mmpara} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in "mmpara" parameter group }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
EM04 specific part. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2006/06/01 17:58:08 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.8 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_em04.c}
{\xe \v sysp_em04.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFFF\:sysp_em04.c}
{\xe \v sysp_em04.c\:_EEOFFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFFF(x)\~ offsetof(struct flstr_parms,x)}
}\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFFX\:sysp_em04.c}
{\xe \v sysp_em04.c\:_EEOFFX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFFX(x)\~ offsetof(struct menmx_parms,x)}
}\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v Em04Init\:sysp_em04.c}
{\xe \v sysp_em04.c\:Em04Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Em04Init ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for EM04. \par
Probes for CPU EEPROM and possible ESM carrier boards {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Em04SysParamInit\:sysp_em04.c}
{\xe \v sysp_em04.c\:Em04SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Em04SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EM04. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_NvsEm04CpuProbe\:sysp_em04.c}
{\xe \v sysp_em04.c\:SYSP_NvsEm04CpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEm04CpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EM04 CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in EM04 CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_em04.c}
{\xe \v sysp_em04.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1100]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_super\:sysp_em04.c}
{\xe \v sysp_em04.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_parListEm04FlStr\:sysp_em04.c}
{\xe \v sysp_em04.c\:SYSP_parListEm04FlStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm04FlStr}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_STR( SYSP_mmstartup, NULL, _EEOFFF(fl_startup), "", \par
                  EM04_FLASH_STARTUP_LEN, 0 ),\par
    SYSP_PDE_STR( SYSP_kerpar, NULL, _EEOFFF(fl_kerpar), "", \par
                  EM04_FLASH_KERPAR_LEN, 0 ),\par
    \par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in EM04 boot flash, long string \par
\par
}
{\xe \v SYSP_parListEm04Menm\:sysp_em04.c}
{\xe \v sysp_em04.c\:SYSP_parListEm04Menm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm04Menm}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
\par
    \par
    SYSP_PDE_U8X( "misc",           NULL, _EEOFF(mm_misc), "0", 0),\par
    SYSP_PDE_BOOL1( SYSP_ldlogodis, NULL, _EEOFF(mm_misc), "0", 0 ),\par
    SYSP_PDE_BOOL2( SYSP_updcdis,   NULL, _EEOFF(mm_misc), "0", 0 ),\par
    SYSP_PDE_BOOL3( "com3se",       NULL, _EEOFF(mm_misc), "0", 0 ),\par
    SYSP_PDE_BOOL4( SYSP_useflpar,  NULL, _EEOFF(mm_misc), "0", \par
                    SYSP_PD_RESTART ),\par
    SYSP_PDE_BOOL5( "nobanner",     NULL, _EEOFF(mm_misc), "0", 0 ),\par
    \par
    \par
    SYSP_PDE_U8X( "selftest",       NULL, _EEOFF(mm_selftest), "0", 0),\par
    SYSP_PDE_BOOL0( SYSP_stdis,     NULL, _EEOFF(mm_selftest), "0", 0 ),\par
    SYSP_PDE_BOOL1( SYSP_stignfault,NULL, _EEOFF(mm_selftest), "0", 0 ),\par
    SYSP_PDE_BOOL2( "stdis_int_cf", NULL, _EEOFF(mm_selftest), "0", 0 ),\par
    SYSP_PDE_BOOL3( "stdis_sram",   NULL, _EEOFF(mm_selftest), "0", 0 ),\par
    SYSP_PDE_BOOL4( "stdis_touch",  NULL, _EEOFF(mm_selftest), "0", 0 ),\par
    SYSP_PDE_BOOL5( "stdis_prtctrl",NULL, _EEOFF(mm_selftest), "0", 0 ),\par
\par
    SYSP_PDE_U8X( "pciopts",        NULL, _EEOFF(mm_pci_opts), "0", 0),\par
\par
    SYSP_PDE_CBR(   _EEOFF(mm_cbaud) ),\par
    SYSP_PDE_BSADR( _EEOFF(mm_bsadr) ),\par
    SYSP_PDE_UXX(   _EEOFF(mm_usr[0]) ),\par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in EM04 CPU EEPROM, menmon section \par
\par
}
{\xe \v SYSP_parListEm04MenmX\:sysp_em04.c}
{\xe \v sysp_em04.c\:SYSP_parListEm04MenmX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm04MenmX}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_CON0( _EEOFFX(mmx_con[0]), "8" ),  \par
    SYSP_PDE_CON1( _EEOFFX(mmx_con[1]), "a" ),  \par
    SYSP_PDE_CON2( _EEOFFX(mmx_con[2]), "0" ),  \par
    SYSP_PDE_CON3( _EEOFFX(mmx_con[3]), "0" ),  \par
    SYSP_PDE_GCON( _EEOFFX(mmx_gcon),   "ff"),  \par
    SYSP_PDE_VMODE( _EEOFFX(mmx_vmode) ),\par
    SYSP_PDE_ECL(   _EEOFFX(mmx_ecl) ),\par
    SYSP_PDE_TTO(   _EEOFFX(mmx_tto) ),\par
    SYSP_PDE_TRIES( _EEOFFX(mmx_tries) ),\par
    SYSP_PDE_TDP(   _EEOFFX(mmx_tdp) ),\par
    SYSP_PDE_HDP(   _EEOFFX(mmx_hdp) ),\par
    SYSP_PDE_STWAIT(_EEOFFX(mmx_stwait), "30" ),\par
    SYSP_PDE_WDT(   _EEOFFX(mmx_wdt), "0" ),\par
    \par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in EM04 CPU EEPROM, menmon extended section \par
\par
}
{\xe \v SYSP_parListEm04Mmpara\:sysp_em04.c}
{\xe \v sysp_em04.c\:SYSP_parListEm04Mmpara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_CONST_STRING} {\b SYSP_parListEm04Mmpara}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_mem0,\par
    SYSP_mem1,\par
    SYSP_flash0,\par
    SYSP_cpu,\par
    SYSP_cpuclkhz,\par
    SYSP_memclkhz,\par
    SYSP_pciclkhz,\par
    SYSP_clun,\par
    SYSP_dlun,\par
    SYSP_rststat,   \par
    SYSP_mmst,\par
    SYSP_mm,\par
    SYSP_cons,\par
    NULL\par
\}\par
\par
}
list of parameters in "mmpara" parameter group \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_em04a.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_em04a.c}
{\xe \v sysp_em04a.c}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid EM04A specific part.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF2}(x)\~ offsetof(struct tcpext_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEm04ACpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EM04A CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Em04AInit} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for EM04A. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Em04ASysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EM04A. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1024]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm04AMenm} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EM04A CPU EEPROM menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm04ATcpExt} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EM04A TCP extension section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_CONST_STRING} {\b SYSP_parListEm04AMmpara} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in "mmpara" parameter group }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
EM04A specific part. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2005/07/14 15:51:14 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.11 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_em04a.c}
{\xe \v sysp_em04a.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFF2\:sysp_em04a.c}
{\xe \v sysp_em04a.c\:_EEOFF2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF2(x)\~ offsetof(struct tcpext_parms,x)}
}\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v Em04AInit\:sysp_em04a.c}
{\xe \v sysp_em04a.c\:Em04AInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Em04AInit ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for EM04A. \par
Probes for CPU EEPROM Does not probe for possible ESM carrier boards (not foreseen for EM04A)\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Em04ASysParamInit\:sysp_em04a.c}
{\xe \v sysp_em04a.c\:Em04ASysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Em04ASysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EM04A. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_NvsEm04ACpuProbe\:sysp_em04a.c}
{\xe \v sysp_em04a.c\:SYSP_NvsEm04ACpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEm04ACpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EM04A CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in EM04A CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_em04a.c}
{\xe \v sysp_em04a.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1024]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_super\:sysp_em04a.c}
{\xe \v sysp_em04a.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_parListEm04AMenm\:sysp_em04a.c}
{\xe \v sysp_em04a.c\:SYSP_parListEm04AMenm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm04AMenm}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters in EM04A CPU EEPROM menmon section \par
\par
\par
}
{\xe \v SYSP_parListEm04AMmpara\:sysp_em04a.c}
{\xe \v sysp_em04a.c\:SYSP_parListEm04AMmpara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_CONST_STRING} {\b SYSP_parListEm04AMmpara}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    "mem0",\par
    "mem1",\par
    "cpu",\par
    "cpuclkhz",\par
    "memclkhz",\par
    "pciclkhz",\par
    "clun",\par
    "dlun",\par
    "rststat",\par
    "cons",\par
    "mmst",\par
    NULL\par
\}\par
\par
}
list of parameters in "mmpara" parameter group \par
\par
}
{\xe \v SYSP_parListEm04ATcpExt\:sysp_em04a.c}
{\xe \v sysp_em04a.c\:SYSP_parListEm04ATcpExt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm04ATcpExt}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_S16D( "tdp",       NULL, _EEOFF2(tcp_tdp),     "-1", 0),\par
    SYSP_PDE_S16D( "hdp",       NULL, _EEOFF2(tcp_hdp),     "-1", 0),\par
    SYSP_PDE_U8D( "tries",      NULL, _EEOFF2(tcp_tries),   "10", 0),\par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in EM04A TCP extension section \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_em09.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_em09.c}
{\xe \v sysp_em09.c}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid EM09 specific part cloned from EM03.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EM09_DFLT_WDT}\~ "0"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EM09_DFLT_MMSTARTUP}\~ ""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_VMEIN}(_nm, _alias, _adrSpace, _offs, _deflt)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i VME inbound window. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_WDT_PLD}(_eeoff, _def)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFFF}(x)\~ offsetof(struct flstr_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEm09CpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EM09 CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Em09Init} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for EM09. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EM09_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EM09. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1100]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_hwLongDesc} [] = "(1=hardware monitor reset enabled)"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsHexEm9} [] = "[0-9A-Fa-f]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsDecEm9} [] = "[0-9]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsBoolEm9} [] = "[01]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_HELP_DESC} {\b G_HelpDescEm9} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Table that describes all statically known board specific parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_HELP_DESC_TBL} {\b G_descTblEm09} = \{ NULL, {\b G_HelpDescEm9} \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm09Menm} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EM09 CPU EEPROM, menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm09FlStr} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EM09 boot flash, long string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_CONST_STRING} {\b SYSP_parListEm09Mmpara} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in "mmpara" parameter group }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
EM09 specific part cloned from EM03. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid aw {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2009/11/20 20:06:06 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.22 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}\par
{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSP_EM09_VARIANT_A017 - A017 specific eeprom layout\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_em09.c}
{\xe \v sysp_em09.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFFF\:sysp_em09.c}
{\xe \v sysp_em09.c\:_EEOFFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFFF(x)\~ offsetof(struct flstr_parms,x)}
}\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v EM09_DFLT_MMSTARTUP\:sysp_em09.c}
{\xe \v sysp_em09.c\:EM09_DFLT_MMSTARTUP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EM09_DFLT_MMSTARTUP\~ ""}
}\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v EM09_DFLT_WDT\:sysp_em09.c}
{\xe \v sysp_em09.c\:EM09_DFLT_WDT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EM09_DFLT_WDT\~ "0"}
}\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_PDE_VMEIN\:sysp_em09.c}
{\xe \v sysp_em09.c\:SYSP_PDE_VMEIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_VMEIN(_nm, _alias, _adrSpace, _offs, _deflt)}
}\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawVme##_adrSpace, SYSP_FromRawVme##_adrSpace, \\\par
   SYSP_ValidateVmeIn, _deflt, _adrSpace, \\\par
   (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET) \}\par
\par
}
VME inbound window. \par
\par
}
{\xe \v SYSP_PDE_WDT_PLD\:sysp_em09.c}
{\xe \v sysp_em09.c\:SYSP_PDE_WDT_PLD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_WDT_PLD(_eeoff, _def)}
}\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ SYSP_wdt, NULL, _EEOFF(mm_wdt), SYSP_ToRawS16D, SYSP_FromRawS16D, \\\par
   SYSP_ValidateWdtPld, EM09_DFLT_WDT, 0, 0 \}\par
\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EM09_SysParamInit\:sysp_em09.c}
{\xe \v sysp_em09.c\:EM09_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EM09_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EM09. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Em09Init\:sysp_em09.c}
{\xe \v sysp_em09.c\:Em09Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Em09Init ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for EM09. \par
Probes for CPU EEPROM and possible ESM carrier boards {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_NvsEm09CpuProbe\:sysp_em09.c}
{\xe \v sysp_em09.c\:SYSP_NvsEm09CpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEm09CpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EM09 CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in EM09 CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_em09.c}
{\xe \v sysp_em09.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1100]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_allowedCharsBoolEm9\:sysp_em09.c}
{\xe \v sysp_em09.c\:G_allowedCharsBoolEm9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsBoolEm9}[] = "[01]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_allowedCharsDecEm9\:sysp_em09.c}
{\xe \v sysp_em09.c\:G_allowedCharsDecEm9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsDecEm9}[] = "[0-9]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_allowedCharsHexEm9\:sysp_em09.c}
{\xe \v sysp_em09.c\:G_allowedCharsHexEm9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsHexEm9}[] = "[0-9A-Fa-f]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_descTblEm09\:sysp_em09.c}
{\xe \v sysp_em09.c\:G_descTblEm09}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_HELP_DESC_TBL} {\b G_descTblEm09} = \{ NULL, {\b G_HelpDescEm9} \}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_HelpDescEm9\:sysp_em09.c}
{\xe \v sysp_em09.c\:G_HelpDescEm9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_HELP_DESC} {\b G_HelpDescEm9}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Table that describes all statically known board specific parameters. \par
\par
\par
}
{\xe \v G_hwLongDesc\:sysp_em09.c}
{\xe \v sysp_em09.c\:G_hwLongDesc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_hwLongDesc}[] = "(1=hardware monitor reset enabled)"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_super\:sysp_em09.c}
{\xe \v sysp_em09.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_parListEm09FlStr\:sysp_em09.c}
{\xe \v sysp_em09.c\:SYSP_parListEm09FlStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm09FlStr}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_STR( SYSP_mmstartup, SYSP_startup, _EEOFFF(fl_startup),\par
                  EM09_DFLT_MMSTARTUP,\par
                  EM09_FLASH_STARTUP_LEN, 0 ),\par
    SYSP_PDE_STR( SYSP_kerpar, NULL, _EEOFFF(fl_kerpar), "",\par
                  EM09_FLASH_KERPAR_LEN, 0 ),\par
\par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in EM09 boot flash, long string \par
\par
}
{\xe \v SYSP_parListEm09Menm\:sysp_em09.c}
{\xe \v sysp_em09.c\:SYSP_parListEm09Menm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEm09Menm}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters in EM09 CPU EEPROM, menmon section \par
\par
\par
}
{\xe \v SYSP_parListEm09Mmpara\:sysp_em09.c}
{\xe \v sysp_em09.c\:SYSP_parListEm09Mmpara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_CONST_STRING} {\b SYSP_parListEm09Mmpara}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters in "mmpara" parameter group \par
\par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_em10a.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_em10a.c}
{\xe \v sysp_em10a.c}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid EM10A specific part, only needed for Touch calibration data.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_DATA_SIZE}\~ 1100\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LOGLINE}\~ \{\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEm10ACpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EM01 CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EM10AInit} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for EM10A. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EM10A_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EM10, just creates carrier data. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [SYSP_DATA_SIZE]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
EM10A specific part, only needed for Touch calibration data. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid ts {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2012/01/11 17:52:27 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.2 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid MM_CODE_SHRINK - to bring MENMON < 256 kB\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_em10a.c}
{\xe \v sysp_em10a.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v LOGLINE\:sysp_em10a.c}
{\xe \v sysp_em10a.c\:LOGLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LOGLINE\~ \{\}}
}\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_DATA_SIZE\:sysp_em10a.c}
{\xe \v sysp_em10a.c\:SYSP_DATA_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_DATA_SIZE\~ 1100}
}\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EM10A_SysParamInit\:sysp_em10a.c}
{\xe \v sysp_em10a.c\:EM10A_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EM10A_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EM10, just creates carrier data. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v EM10AInit\:sysp_em10a.c}
{\xe \v sysp_em10a.c\:EM10AInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EM10AInit ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for EM10A. \par
Probes for CPU EEPROM and possible ESM carrier boards {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_NvsEm10ACpuProbe\:sysp_em10a.c}
{\xe \v sysp_em10a.c\:SYSP_NvsEm10ACpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEm10ACpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EM01 CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in EM01 CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_em10a.c}
{\xe \v sysp_em10a.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[SYSP_DATA_SIZE]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_super\:sysp_em10a.c}
{\xe \v sysp_em10a.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_ep01.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_ep01.c}
{\xe \v sysp_ep01.c}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid EP01 specific part.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEp01CpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EP01 CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Ep01Init} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for EP01. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EP01_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EP01. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1100]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEp01Menm} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EP01 CPU EEPROM, menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_CONST_STRING} {\b SYSP_parListEp01Mmpara} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in "mmpara" parameter group }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
EP01 specific part. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2010/04/23 15:32:18 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.7 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_ep01.c}
{\xe \v sysp_ep01.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EP01_SysParamInit\:sysp_ep01.c}
{\xe \v sysp_ep01.c\:EP01_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EP01_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EP01. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Ep01Init\:sysp_ep01.c}
{\xe \v sysp_ep01.c\:Ep01Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Ep01Init ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for EP01. \par
Probes for CPU EEPROM and possible ESM carrier boards {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_NvsEp01CpuProbe\:sysp_ep01.c}
{\xe \v sysp_ep01.c\:SYSP_NvsEp01CpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEp01CpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EP01 CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in EP01 CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_ep01.c}
{\xe \v sysp_ep01.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1100]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_super\:sysp_ep01.c}
{\xe \v sysp_ep01.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_parListEp01Menm\:sysp_ep01.c}
{\xe \v sysp_ep01.c\:SYSP_parListEp01Menm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEp01Menm}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters in EP01 CPU EEPROM, menmon section \par
\par
\par
}
{\xe \v SYSP_parListEp01Mmpara\:sysp_ep01.c}
{\xe \v sysp_ep01.c\:SYSP_parListEp01Mmpara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_CONST_STRING} {\b SYSP_parListEp01Mmpara}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_mem0,\par
    SYSP_mem1,\par
    SYSP_flash0,\par
    SYSP_flash1,\par
    SYSP_cpu,\par
    SYSP_cpuclkhz,\par
    SYSP_MPC52XX_inclkhz,\par
    SYSP_memclkhz,\par
    SYSP_MPC52XX_xlbclkhz,\par
    SYSP_MPC52XX_ipbclkhz,\par
    SYSP_pciclkhz,\par
    SYSP_clun,\par
    SYSP_dlun,\par
    SYSP_usbdp,\par
    SYSP_rststat,\par
    SYSP_mmst,\par
    SYSP_mm,\par
    SYSP_cons,\par
    SYSP_nmac0,\par
    SYSP_nmac1,\par
    \par
    NULL\par
\}\par
\par
}
list of parameters in "mmpara" parameter group \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_ep04.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_ep04.c}
{\xe \v sysp_ep04.c}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid EP04 specific part (cloned from {\b sysp_em03.c} V2.9).  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EP4_DFLT_MMSTARTUP}\~ ""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFFF}(x)\~ offsetof(struct flstr_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEp04CpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EP04 CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Ep04Init} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for EP04. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Ep04SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EP04. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1100]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEp04Menm} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EP04 CPU EEPROM, menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEp04FlStr} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in EP04 boot flash, long string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_CONST_STRING} {\b SYSP_parListEp04Mmpara} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in "mmpara" parameter group }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
EP04 specific part (cloned from {\b sysp_em03.c} V2.9). \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid rt {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2009/11/30 11:46:02 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.5 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}\par
{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_ep04.c}
{\xe \v sysp_ep04.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFFF\:sysp_ep04.c}
{\xe \v sysp_ep04.c\:_EEOFFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFFF(x)\~ offsetof(struct flstr_parms,x)}
}\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v EP4_DFLT_MMSTARTUP\:sysp_ep04.c}
{\xe \v sysp_ep04.c\:EP4_DFLT_MMSTARTUP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EP4_DFLT_MMSTARTUP\~ ""}
}\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v Ep04Init\:sysp_ep04.c}
{\xe \v sysp_ep04.c\:Ep04Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Ep04Init ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for EP04. \par
Probes for CPU EEPROM and possible ESM carrier boards {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Ep04SysParamInit\:sysp_ep04.c}
{\xe \v sysp_ep04.c\:Ep04SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Ep04SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EP04. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_NvsEp04CpuProbe\:sysp_ep04.c}
{\xe \v sysp_ep04.c\:SYSP_NvsEp04CpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEp04CpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EP04 CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in EP04 CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_ep04.c}
{\xe \v sysp_ep04.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1100]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_super\:sysp_ep04.c}
{\xe \v sysp_ep04.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_parListEp04FlStr\:sysp_ep04.c}
{\xe \v sysp_ep04.c\:SYSP_parListEp04FlStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEp04FlStr}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_STR( SYSP_mmstartup, SYSP_startup, _EEOFFF(fl_startup),\par
                  EP4_DFLT_MMSTARTUP,\par
                  EP04_FLASH_STARTUP_LEN, 0 ),\par
    SYSP_PDE_STR( SYSP_kerpar, NULL, _EEOFFF(fl_kerpar), "",\par
                  EP04_FLASH_KERPAR_LEN, 0 ),\par
\par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in EP04 boot flash, long string \par
\par
}
{\xe \v SYSP_parListEp04Menm\:sysp_ep04.c}
{\xe \v sysp_ep04.c\:SYSP_parListEp04Menm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEp04Menm}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters in EP04 CPU EEPROM, menmon section \par
\par
\par
}
{\xe \v SYSP_parListEp04Mmpara\:sysp_ep04.c}
{\xe \v sysp_ep04.c\:SYSP_parListEp04Mmpara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_CONST_STRING} {\b SYSP_parListEp04Mmpara}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_mem0,\par
    SYSP_flash0,\par
    SYSP_cpu,\par
    SYSP_cpuclkhz,\par
    SYSP_memclkhz,\par
    SYSP_pciclkhz,\par
    SYSP_MPC85XX_ccbclkhz,\par
    SYSP_MPC85XX_immr,\par
    SYSP_clun,\par
    SYSP_dlun,\par
    SYSP_rststat,\par
    SYSP_mmst,\par
    SYSP_mm,\par
    SYSP_cons,\par
    SYSP_nmac0,\par
    SYSP_nmac1,\par
    SYSP_nspeed0,   \par
    SYSP_nspeed1,   \par
    NULL\par
\}\par
\par
}
list of parameters in "mmpara" parameter group \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_esm_cb.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid ESM (embedded system modules) carrier board handlers.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _AD65OFF}(x)\~ offsetof(struct ad65_menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _ESMCBMENMOFF}(x)\~ offsetof(struct esm_cb_menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _ESMCBINFOOFF}(x)\~ offsetof(struct esm_cb_info_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b StrNCmpNoCase} (const char *s1, const char *s2, int n)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Compare 2 strings. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_EsmCarrierInitGlobals} (int addr, int size, char prefix)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set Devive Address and Size for Carrier Board. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_EsmCarrierProbe} ({\b SYSP_SUPER} *super, int smbBusNo)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for all possible known ESM carrier boards. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsAd65EtcProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for AD65 and boards with same EEPROM layout. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_IsEsmCB_with_EEPROD2} (const char *brdName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i look in Table to see if EEPROD2 structure should be used with carrier board }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsHamedCompProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for HAMED and boards with same EEPROM layout. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsSaurerProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for Saurer and boards with same EEPROM layout. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEsmxCbProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for ESMexpress carrier boards and boards with same EEPROM layout. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b G_cbEepromSize} = 512\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b G_cbEepromAddr} = 0xac\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b G_prefix} = "c"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListAd65Tcal} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbInfo} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbInfoSaurer} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbTcal} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbMenmSaurer} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
ESM (embedded system modules) carrier board handlers. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2012/02/27 16:12:25 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.16 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _AD65OFF\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:_AD65OFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _AD65OFF(x)\~ offsetof(struct ad65_menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _ESMCBINFOOFF\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:_ESMCBINFOOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _ESMCBINFOOFF(x)\~ offsetof(struct esm_cb_info_parms,x)}
}\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _ESMCBMENMOFF\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:_ESMCBMENMOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _ESMCBMENMOFF(x)\~ offsetof(struct esm_cb_menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v StrNCmpNoCase\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:StrNCmpNoCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int StrNCmpNoCase (const char * {\i s1}, const char * {\i s2}, int {\i n}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Compare 2 strings. \par
not case sensitive \par
\par
}
{\xe \v SYSP_EsmCarrierInitGlobals\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_EsmCarrierInitGlobals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_EsmCarrierInitGlobals (int {\i addr}, int {\i size}, char {\i prefix})}
}\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set Devive Address and Size for Carrier Board. \par
if data differs from default this routine have to be called before probing the ESMCB board. \par
\par
}
{\xe \v SYSP_EsmCarrierProbe\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_EsmCarrierProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_EsmCarrierProbe ({\b SYSP_SUPER} * {\i super}, int {\i smbBusNo})}
}\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for all possible known ESM carrier boards. \par
Prefix will be 'c' always. SMB addresses are hardcoded (0xac).\par
If nothing could be read from SMB (no board EEPROM there), no parameter group is created and {\b SYSPARAM_EEPROM_ERROR} is returned.\par
If an unknown/unprogrammed board is found, a parameter group for standard EEPROD section is setup\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i super} {\b IN}  sysparam super object \par
{\i smbBusNo} {\b IN}  SMB bus number\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_IsEsmCB_with_EEPROD2\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_IsEsmCB_with_EEPROD2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_IsEsmCB_with_EEPROD2 (const char * {\i brdName})}
}\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
look in Table to see if EEPROD2 structure should be used with carrier board \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i brdName} {\b IN}  board name\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid TRUE if match, FALSE for fail \par
}\par
\par
}
{\xe \v SYSP_NvsAd65EtcProbe\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_NvsAd65EtcProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsAd65EtcProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for AD65 and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_NvsEsmxCbProbe\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_NvsEsmxCbProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEsmxCbProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for ESMexpress carrier boards and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_NvsHamedCompProbe\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_NvsHamedCompProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsHamedCompProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for HAMED and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_NvsSaurerProbe\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_NvsSaurerProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsSaurerProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for Saurer and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_cbEepromAddr\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:G_cbEepromAddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b G_cbEepromAddr} = 0xac{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_cbEepromSize\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:G_cbEepromSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b G_cbEepromSize} = 512{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_prefix\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:G_prefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b G_prefix} = "c"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_parListAd65Tcal\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_parListAd65Tcal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListAd65Tcal}[]}
}\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
\par
\par
\par
\par
\par
    SYSP_PDE_TCAL( "tcal", NULL, _AD65OFF(tcal), "0,0,0,0"),\par
\par
\par
    SYSP_PDE_END\par
\}\par
\par
}
}
{\xe \v SYSP_parListEsmCbInfo\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_parListEsmCbInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbInfo}[]}
}\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_U32X( SYSP_esm_cb_hwflag, NULL,\par
                   _ESMCBINFOOFF(ci_hw_flag), "0", SYSP_PD_MMPARASTR ),\par
    SYSP_PDE_STR( SYSP_esm_cb_partnum, NULL,\par
                  _ESMCBINFOOFF(ci_custPNum), "", 16, SYSP_PD_MMPARASTR ),\par
    SYSP_PDE_END\par
\}\par
\par
}
}
{\xe \v SYSP_parListEsmCbInfoSaurer\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_parListEsmCbInfoSaurer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbInfoSaurer}[]}
}\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_STR( SYSP_esm_cb_partnum, NULL,\par
                  _ESMCBINFOOFF(ci_custPNum), "", 16, SYSP_PD_MMPARASTR ),\par
    SYSP_PDE_END\par
\}\par
\par
}
}
{\xe \v SYSP_parListEsmCbMenmSaurer\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_parListEsmCbMenmSaurer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbMenmSaurer}[]}
}\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    \par
    SYSP_PDE_TCAL( "tcal", NULL, _ESMCBMENMOFF(tcal), "0, 3700, 0, 3700"),\par
    \par
    SYSP_PDE_COMMODE( "mode_com11", "mode_com3", \par
                      _ESMCBMENMOFF(mm_mode_com1[1]), "RS422", SYSP_PD_NEEDRESET ),\par
    SYSP_PDE_COMMODE( "mode_com12", "mode_com4", \par
                      _ESMCBMENMOFF(mm_mode_com1[2]), "RS422", SYSP_PD_NEEDRESET ),\par
    SYSP_PDE_END\par
\}\par
\par
}
}
{\xe \v SYSP_parListEsmCbTcal\:sysp_esm_cb.c}
{\xe \v sysp_esm_cb.c\:SYSP_parListEsmCbTcal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbTcal}[]}
}\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_TCAL( "tcal", NULL, _ESMCBMENMOFF(tcal), "0,0,0,0"),\par
    SYSP_PDE_S16D( "ham_corrX1", NULL,  _ESMCBMENMOFF(mm_resvd2), "0", SYSP_PD_MMPARASTR),\par
    SYSP_PDE_S16D( "ham_corrX2", NULL, (_ESMCBMENMOFF(mm_resvd2) + 2), "0", SYSP_PD_MMPARASTR),\par
    SYSP_PDE_S16D( "ham_corrY1", NULL, (_ESMCBMENMOFF(mm_resvd2) + 4), "0", SYSP_PD_MMPARASTR),\par
    SYSP_PDE_S16D( "ham_corrY2", NULL, (_ESMCBMENMOFF(mm_resvd2) + 6), "0", SYSP_PD_MMPARASTR),\par
    SYSP_PDE_END\par
\}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_esm_cb.work.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LOGLINE}\~ \{\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _AD65OFF}(x)\~ offsetof(struct ad65_menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _ESMCBMENMOFF}(x)\~ offsetof(struct esm_cb_menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _ESMCBINFOOFF}(x)\~ offsetof(struct esm_cb_info_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b StrNCmpNoCase} (const char *s1, const char *s2, int n)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Compare 2 strings. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_EsmCarrierInitGlobals} (int addr, int size, char prefix)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set Devive Address and Size for Carrier Board. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_EsmCarrierProbe} ({\b SYSP_SUPER} *super, int smbBusNo)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for all possible known ESM carrier boards. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsAd65EtcProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for AD65 and boards with same EEPROM layout. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_IsEsmCB_with_EEPROD2} (const char *brdName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i look in Table to see if EEPROD2 structure should be used with carrier board }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsHamedCompProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for HAMED and boards with same EEPROM layout. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsSaurerProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for Saurer and boards with same EEPROM layout. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEsmxCbProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for ESMexpress carrier boards and boards with same EEPROM layout. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b G_cbEepromSize} = 512\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b G_cbEepromAddr} = 0xac\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b G_prefix} = "c"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListAd65Tcal} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbInfo} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbInfoSaurer} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbTcal} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbMenmSaurer} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _AD65OFF\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:_AD65OFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _AD65OFF(x)\~ offsetof(struct ad65_menm_parms,x)}
}\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _ESMCBINFOOFF\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:_ESMCBINFOOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _ESMCBINFOOFF(x)\~ offsetof(struct esm_cb_info_parms,x)}
}\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _ESMCBMENMOFF\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:_ESMCBMENMOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _ESMCBMENMOFF(x)\~ offsetof(struct esm_cb_menm_parms,x)}
}\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v LOGLINE\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:LOGLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LOGLINE\~ \{\}}
}\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v StrNCmpNoCase\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:StrNCmpNoCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int StrNCmpNoCase (const char * {\i s1}, const char * {\i s2}, int {\i n}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Compare 2 strings. \par
not case sensitive \par
\par
}
{\xe \v SYSP_EsmCarrierInitGlobals\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_EsmCarrierInitGlobals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_EsmCarrierInitGlobals (int {\i addr}, int {\i size}, char {\i prefix})}
}\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set Devive Address and Size for Carrier Board. \par
if data differs from default this routine have to be called before probing the ESMCB board. \par
\par
}
{\xe \v SYSP_EsmCarrierProbe\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_EsmCarrierProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_EsmCarrierProbe ({\b SYSP_SUPER} * {\i super}, int {\i smbBusNo})}
}\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for all possible known ESM carrier boards. \par
Prefix will be 'c' always. SMB addresses are hardcoded (0xac).\par
If nothing could be read from SMB (no board EEPROM there), no parameter group is created and {\b SYSPARAM_EEPROM_ERROR} is returned.\par
If an unknown/unprogrammed board is found, a parameter group for standard EEPROD section is setup\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i super} {\b IN}  sysparam super object \par
{\i smbBusNo} {\b IN}  SMB bus number\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_IsEsmCB_with_EEPROD2\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_IsEsmCB_with_EEPROD2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_IsEsmCB_with_EEPROD2 (const char * {\i brdName})}
}\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
look in Table to see if EEPROD2 structure should be used with carrier board \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i brdName} {\b IN}  board name\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid TRUE if match, FALSE for fail \par
}\par
\par
}
{\xe \v SYSP_NvsAd65EtcProbe\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_NvsAd65EtcProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsAd65EtcProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for AD65 and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_NvsEsmxCbProbe\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_NvsEsmxCbProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEsmxCbProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for ESMexpress carrier boards and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_NvsHamedCompProbe\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_NvsHamedCompProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsHamedCompProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for HAMED and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_NvsSaurerProbe\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_NvsSaurerProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsSaurerProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for Saurer and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_cbEepromAddr\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:G_cbEepromAddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b G_cbEepromAddr} = 0xac{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_cbEepromSize\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:G_cbEepromSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b G_cbEepromSize} = 512{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_prefix\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:G_prefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* {\b G_prefix} = "c"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_parListAd65Tcal\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_parListAd65Tcal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListAd65Tcal}[]}
}\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
\par
\par
\par
\par
\par
    SYSP_PDE_TCAL( "tcal", NULL, _AD65OFF(tcal), "0,0,0,0"),\par
\par
\par
    SYSP_PDE_END\par
\}\par
\par
}
}
{\xe \v SYSP_parListEsmCbInfo\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_parListEsmCbInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbInfo}[]}
}\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_U32X( SYSP_esm_cb_hwflag, NULL,\par
                   _ESMCBINFOOFF(ci_hw_flag), "0", SYSP_PD_MMPARASTR ),\par
    SYSP_PDE_STR( SYSP_esm_cb_partnum, NULL,\par
                  _ESMCBINFOOFF(ci_custPNum), "", 16, SYSP_PD_MMPARASTR ),\par
    SYSP_PDE_END\par
\}\par
\par
}
}
{\xe \v SYSP_parListEsmCbInfoSaurer\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_parListEsmCbInfoSaurer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbInfoSaurer}[]}
}\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_STR( SYSP_esm_cb_partnum, NULL,\par
                  _ESMCBINFOOFF(ci_custPNum), "", 16, SYSP_PD_MMPARASTR ),\par
    SYSP_PDE_END\par
\}\par
\par
}
}
{\xe \v SYSP_parListEsmCbMenmSaurer\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_parListEsmCbMenmSaurer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbMenmSaurer}[]}
}\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    \par
    SYSP_PDE_TCAL( "tcal", NULL, _ESMCBMENMOFF(tcal), "0, 3700, 0, 3700"),\par
    \par
    SYSP_PDE_COMMODE( "mode_com11", "mode_com3", \par
                      _ESMCBMENMOFF(mm_mode_com1[1]), "RS422", SYSP_PD_NEEDRESET ),\par
    SYSP_PDE_COMMODE( "mode_com12", "mode_com4", \par
                      _ESMCBMENMOFF(mm_mode_com1[2]), "RS422", SYSP_PD_NEEDRESET ),\par
    SYSP_PDE_END\par
\}\par
\par
}
}
{\xe \v SYSP_parListEsmCbTcal\:sysp_esm_cb.work.c}
{\xe \v sysp_esm_cb.work.c\:SYSP_parListEsmCbTcal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListEsmCbTcal}[]}
}\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_TCAL( "tcal", NULL, _ESMCBMENMOFF(tcal), "0,0,0,0"),\par
    SYSP_PDE_END\par
\}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_f302.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_f302.c}
{\xe \v sysp_f302.c}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid f302 specific part cloned from EM03  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b F302_FLASH}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b F302_FLASH::systemDataParms}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_FPGA_DATE}(parName, aliasName, offset, _deflt)\~ \{ parName, aliasName, offset, ToRawDate, FromRawDate, NULL, _deflt, 0, 0 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_FPGA_TIME}(parName, aliasName, offset, _deflt)\~ \{ parName, aliasName, offset, ToRawFpgaTime, FromRawFpgaTime, NULL, _deflt, 0, 0 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_BSP_VER}(parName, aliasName, offset, _deflt)\~ \{ parName, aliasName, offset, ToRawBspVer, FromRawBspVer, NULL, _deflt, 0, 0 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct systemDataParms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b F302_FLASH_MAGIC_ID}\~ 0x5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NVS_SECTION_SIZE}\~ 0x2000\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsFlashCreate} ({\b SYSP_MMSMB_SUPER} *)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create NVS object and all parameter sections that shall be present in F302 Flash. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FromRawDate} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i converts raw date to string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ToRawDate} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i converts string to raw date value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FromRawFpgaTime} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i converts raw time to string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ToRawFpgaTime} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i converts string to raw time value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FromRawBspVer} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i converts raw BSP version to string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ToRawBspVer} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i converts string to raw BSP version value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b F302Init} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for f302. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b F302_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for f302. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1100]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListF302SystemData} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in F302 CPU Flash, system data section }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
f302 specific part cloned from EM03 \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid aw {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2008/07/14 11:24:27 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.2 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}\par
{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
\par
}
\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_f302.c}
{\xe \v sysp_f302.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct systemDataParms,x)}
}\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v F302_FLASH_MAGIC_ID\:sysp_f302.c}
{\xe \v sysp_f302.c\:F302_FLASH_MAGIC_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define F302_FLASH_MAGIC_ID\~ 0x5}
}\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v NVS_SECTION_SIZE\:sysp_f302.c}
{\xe \v sysp_f302.c\:NVS_SECTION_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NVS_SECTION_SIZE\~ 0x2000}
}\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_PDE_BSP_VER\:sysp_f302.c}
{\xe \v sysp_f302.c\:SYSP_PDE_BSP_VER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_BSP_VER(parName, aliasName, offset, _deflt)\~ \{ parName, aliasName, offset, ToRawBspVer, FromRawBspVer, NULL, _deflt, 0, 0 \}}
}\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_PDE_FPGA_DATE\:sysp_f302.c}
{\xe \v sysp_f302.c\:SYSP_PDE_FPGA_DATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_FPGA_DATE(parName, aliasName, offset, _deflt)\~ \{ parName, aliasName, offset, ToRawDate, FromRawDate, NULL, _deflt, 0, 0 \}}
}\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_PDE_FPGA_TIME\:sysp_f302.c}
{\xe \v sysp_f302.c\:SYSP_PDE_FPGA_TIME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_FPGA_TIME(parName, aliasName, offset, _deflt)\~ \{ parName, aliasName, offset, ToRawFpgaTime, FromRawFpgaTime, NULL, _deflt, 0, 0 \}}
}\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v F302_SysParamInit\:sysp_f302.c}
{\xe \v sysp_f302.c\:F302_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int F302_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for f302. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v F302Init\:sysp_f302.c}
{\xe \v sysp_f302.c\:F302Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int F302Init ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for f302. \par
Probes for CPU flash {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v FromRawBspVer\:sysp_f302.c}
{\xe \v sysp_f302.c\:FromRawBspVer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FromRawBspVer (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
converts raw BSP version to string \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} {\b IN/OUT}  pointer to destination \par
{\i destLen} {\b IN}  length of destination buffer \par
{\i src} {\b IN}  pointer to source\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM_INVAL_VALUE and empty string if raw is 0xffff \par
}\par
\par
}
{\xe \v FromRawDate\:sysp_f302.c}
{\xe \v sysp_f302.c\:FromRawDate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FromRawDate (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
converts raw date to string \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} {\b IN/OUT}  pointer to destination \par
{\i destLen} {\b IN}  length of destination buffer \par
{\i src} {\b IN}  pointer to source\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM_INVAL_VALUE and empty string if raw is 0xffff \par
}\par
\par
}
{\xe \v FromRawFpgaTime\:sysp_f302.c}
{\xe \v sysp_f302.c\:FromRawFpgaTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FromRawFpgaTime (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
converts raw time to string \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} {\b IN/OUT}  pointer to destination \par
{\i destLen} {\b IN}  length of destination buffer \par
{\i src} {\b IN}  pointer to source\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM_INVAL_VALUE and empty string if raw is 0xffff \par
}\par
\par
}
{\xe \v SYSP_NvsFlashCreate\:sysp_f302.c}
{\xe \v sysp_f302.c\:SYSP_NvsFlashCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsFlashCreate ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create NVS object and all parameter sections that shall be present in F302 Flash. \par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v ToRawBspVer\:sysp_f302.c}
{\xe \v sysp_f302.c\:ToRawBspVer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ToRawBspVer (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
converts string to raw BSP version value \par
String format must be in notation {\f2 mainNbr} :smallNbr\par
An empty {\i src}  string sets the raw time to 0xffff (invalid)\par
Includes the validation function\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} {\b IN/OUT}  pointer to destination \par
{\i src} {\b IN}  pointer to source\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM_INVAL_VALUE if invalid time \par
}\par
\par
}
{\xe \v ToRawDate\:sysp_f302.c}
{\xe \v sysp_f302.c\:ToRawDate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ToRawDate (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
converts string to raw date value \par
String format must be in US notation {\f2 m/d/y}  \par
Where {\f2 m}  is the month 1..12 (leading zeroes allowed) Where {\f2 d}  is the day of month 1..31 (leading zeroes allowed) Where {\f2 y}  is the year. If no century included, 2000 is added to year.\par
An empty {\i src}  string sets the raw date to 0xffff (invalid)\par
Includes the validation function\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} {\b IN/OUT}  pointer to destination \par
{\i src} {\b IN}  pointer to source\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM_INVAL_VALUE if invalid date \par
}\par
\par
}
{\xe \v ToRawFpgaTime\:sysp_f302.c}
{\xe \v sysp_f302.c\:ToRawFpgaTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ToRawFpgaTime (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
converts string to raw time value \par
String format must be in notation {\f2 h} :m\par
Where {\f2 h}  is the hour 0..23 Where {\f2 m}  is the minute 0..59\par
An empty {\i src}  string sets the raw time to 0xffff (invalid)\par
Includes the validation function\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} {\b IN/OUT}  pointer to destination \par
{\i src} {\b IN}  pointer to source\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM_INVAL_VALUE if invalid time \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_f302.c}
{\xe \v sysp_f302.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1100]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_super\:sysp_f302.c}
{\xe \v sysp_f302.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_parListF302SystemData\:sysp_f302.c}
{\xe \v sysp_f302.c\:SYSP_parListF302SystemData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListF302SystemData}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_ETH      ( SYSP_nmac0,       NULL, _EEOFF(nmac),           "00C03A800000" ),\par
    SYSP_PDE_U16X     ( "FPGA_variant",   NULL, _EEOFF(FPGA_variant),   NULL, 0 ),\par
    SYSP_PDE_U16X     ( "FPGA_rev",       NULL, _EEOFF(FPGA_rev),       NULL, 0 ),\par
    SYSP_PDE_FPGA_DATE( "FPGA_date",      NULL, _EEOFF(FPGA_date),      NULL    ),\par
    SYSP_PDE_FPGA_TIME( "FPGA_time",      NULL, _EEOFF(FPGA_time),      NULL    ),\par
    SYSP_PDE_BSP_VER  ( "BSP_version",    NULL, _EEOFF(BSP_version),    "0.0"   ),\par
    SYSP_PDE_U32X     ( "chameleon_base", NULL, _EEOFF(chameleon_base), NULL, 0 ),\par
    SYSP_PDE_U16X     ( "PHY_address0",   NULL, _EEOFF(PHY_address),    "0",  0 ),\par
    SYSP_PDE_U32X     ( "niosclkhz",      NULL, _EEOFF(niosclkhz), NULL, 0 ),\par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in F302 CPU Flash, system data section \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_intern.h File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_intern.h}
{\xe \v sysp_intern.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Internal header file for sysparam library.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_ALLOC}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i structure to maintain allocated objects }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_HELP_DESC}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Descriptor for SYSPARAM parameter descriptions. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_HELP_DESC_TBL}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Descriptor for parameter description table. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_MMSMB_SUPER}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Sysparam super object extended for MENMONs CPUs with SMB NV storage. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_NV_STORAGE}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i NV storage object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_NVS_ADR}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Descriptor for NV storage address. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_PAR_DESC}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Descriptor for a single parameter, used by {\b SYSP_PGRP_MAGPAR}. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_PAR_GRP}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Parameter group object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_PGRP_MAGPAR}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Parameter group for EEPROM structures with NV magic/parity. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_SUPER}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Sysparam super object. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_ALLOC_INIT}(_super, _arr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i initialize super's {\b SYSP_ALLOC} structure with array {\i _arr}  }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_ALLOC}(_size, _super)\~ SYSP_Alloc( &(_super)->alloc, _size)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i alloc a number of bytes from the super objects main allocation object }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_ALLOC_UNDO}(_size, _super)\~ SYSP_AllocUndo( &(_super)->alloc, _size)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i undo {\b SYSP_ALLOC} }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_INTERNAL_RESTART}\~ 0x8000\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i special internal error code to restart entire sysparam }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_NINTD}(_nm, _alias, _offs, _deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i native unsigned int decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_NINTX}(_nm, _alias, _offs, _deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i native unsigned int hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_U32D}(_nm, _alias, _offs, _deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i U32 decimal. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_U32X}(_nm, _alias, _offs, _deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i U32 hex. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_U16X}(_nm, _alias, _offs, _deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i U16 hex. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_S16D}(_nm, _alias, _offs, _deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i S16 decimal. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_U8X}(_nm, _alias, _offs, _deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i U8 hex. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_U8D}(_nm, _alias, _offs, _deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i U8 dec. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_STR}(_nm, _alias, _offs, _deflt, _len, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i ASCII string. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_STRUPPER}(_nm, _alias, _offs, _deflt, _len, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i ASCII string (only upper case). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_REV}(_nm, _alias, _offs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i MEN HW revision. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_ETH}(_nm, _alias, _offs, _deflt)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Ethernet MAC address. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_NSPEED}(_nm, _alias, _offs, _deflt)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Nspeed value. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_BAUD}(_nm, _alias, _offs, _deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i baudrate value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_COMMODE}(_nm, _alias, _offs, _deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i COM mode. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_TCAL}(_nm, _alias, _offs, _deflt)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Touch calibration (4 integers comma separated). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_BOOL0}(_nm, _alias, _offs,_deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i boolean value stored in bit0 of 8 bit fields }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_BOOL1}(_nm, _alias, _offs,_deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i boolean value stored in bit1 of 8 bit fields }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_BOOL2}(_nm, _alias, _offs,_deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i boolean value stored in bit2 of 8 bit fields }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_BOOL3}(_nm, _alias, _offs,_deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i boolean value stored in bit3 of 8 bit fields }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_BOOL4}(_nm, _alias, _offs,_deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i boolean value stored in bit4 of 8 bit fields }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_BOOL5}(_nm, _alias, _offs,_deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i boolean value stored in bit5 of 8 bit fields }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_BOOL6}(_nm, _alias, _offs,_deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i boolean value stored in bit6 of 8 bit fields }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_BOOL7}(_nm, _alias, _offs,_deflt, _flg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i boolean value stored in bit7 of 8 bit fields }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_END}\~ \{ NULL \}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i End marker. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_CON0}(_eeoff, _def)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_CON1}(_eeoff, _def)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_CON2}(_eeoff, _def)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_CON3}(_eeoff, _def)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_GCON}(_eeoff, _def)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_VMODE}(_eeoff)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_CBR}(_eeoff)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_BSADR}(_eeoff)\~ SYSP_PDE_U32X({\b SYSP_bsadr}, {\b SYSP_bs}, (_eeoff), "0", (SYSP_PD_MMPARASTR*0))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_ECL}(_eeoff)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_TTO}(_eeoff)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_TRIES}(_eeoff)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_TDP}(_eeoff)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_HDP}(_eeoff)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_WDT}(_eeoff, _def)\~ SYSP_PDE_S16D({\b SYSP_wdt}, NULL, (_eeoff), (_def), (SYSP_PD_MMPARASTR*0))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_STWAIT}(_eeoff, _def)\~ SYSP_PDE_U8D({\b SYSP_stwait}, NULL, (_eeoff), (_def), (SYSP_PD_MMPARASTR*0))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_UXX}(_eeoff)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PRINTABLE}(ch)\~ IN_RANGE( ch, 0x20, 0x7e )\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i test if {\i ch}  is a valid printable ASCII char }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DBH}\~ ({\b SYSP_super}->dbh)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DBG_MYLEVEL}\~ DBG_ALL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_DONT_PROVIDE_KERPAR}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PROVIDE_KERPAR}\~ 1\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b SYSP_HELP_DESC_TBL} {\b SYSP_HELP_DESC_TBL}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Descriptor for parameter description table. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b SYSP_PAR_GRP} {\b SYSP_PAR_GRP}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Parameter group object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b SYSP_NV_STORAGE} {\b SYSP_NV_STORAGE}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i NV storage object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b SYSP_ALLOC} {\b SYSP_ALLOC}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i structure to maintain allocated objects }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b SYSP_SUPER} {\b SYSP_SUPER}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Sysparam super object. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SYSP_PD_FLAGS} \{ {\b SYSP_PD_NONE} = 0, 
{\b SYSP_PD_MMPARASTR} = 0x1, 
{\b SYSP_PD_RESTART} = 0x2, 
{\b SYSP_PD_NEEDRESET} = 0x4, 
{\b SYSP_PD_ENCRYPT} = 0x8
 \}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_SuperMmsmbInit} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize extended super object for MENMON/SMB. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_RunPostProcessHooks} ({\b SYSP_SUPER} *super, const char *parName, int attr, int errCode)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Run all postprocessing functions. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_NV_STORAGE} * {\b SYSP_NvsCreate} (int objSize, const char *nvsName, {\b SYSP_SUPER} *super, const char *prefix, {\b SYSP_NVS_ADR} nvsAdr, u_int32 nvsSize)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create a {\b SYSP_NV_STORAGE} object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_NvsAdd} ({\b SYSP_SUPER} *super, {\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Add a NV storage object to super list of NVS object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_NV_STORAGE} * {\b SYSP_NvsFind} ({\b SYSP_SUPER} *super, const char *nvsName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Find NV storage object by name. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_ParGrpAdd} ({\b SYSP_NV_STORAGE} *nvs, {\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Add a parameter group object to NVS list of parameter groups. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b SYSP_Alloc} ({\b SYSP_ALLOC} *alloc, int size)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Allocate block from heap specified with {\i alloc} . }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_AllocUndo} ({\b SYSP_ALLOC} *alloc, int size)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Undo previous alloc. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b SYSP_Prefix} (const char *parName, char *prefix)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Determine prefix part of {\i parName} . }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PAR_GRP} * {\b SYSP_ParNameToGroup} ({\b SYSP_SUPER} *super, const char *parName, const char **pureNameP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Find parameter group that handles {\i parName} . }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_FullParName} ({\b SYSP_NV_STORAGE} *nvs, const char *parName, char *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Make full parameter name incl. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ContainsBlanks} (const char *s)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if {\i s}  contains blanks or tabs. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} * {\b SYSP_FindParDesc} (const {\b SYSP_PAR_DESC} *parList, const char *parName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Find parameter description structure in array by parameter name. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ParDescArrayLen} (const {\b SYSP_PAR_DESC} *parList)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i get number of entries in SYSP_PAR_DESC_ARRAY }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawNatIntD} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from int (native endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawNatIntD} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to int (native endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawNatIntX} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from int (native endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawNatIntX} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to int (native endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU32D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int32 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU32D} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int32 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU32X} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int32 (big endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU32X} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int32 (big endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU16X} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int16 (big endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU16X} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int16 (big endian), hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawS16D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from int16 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawS16D} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to int16 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU16D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int16 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU16D} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int16 (big endian), decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU8X} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int8, hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU8X} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int8, hexadecimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawU8D} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from u_int8, decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawU8D} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to u_int8, decimal }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawStr} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from string returns an empty string if {\i src}  (raw data) contains any non-printable char. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawStr} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to string (hope it was checked by ValidateStr) }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawRev} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from revision number returns empty string if all bytes are 0xff }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawStrUpper} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to string (convert to upper case; hope it was checked by ValidateStr) }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawRev} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to revision number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawTcal} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from touch calibration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawTcal} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to touch calibration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawNspeed} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from Nspeed number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawNspeed} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to Nspeed number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawComMode} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from COM mode number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawComMode} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to COM mode number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool7} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool6} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool5} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool4} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool3} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool2} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool1} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawBool0} (void *dest, const char *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool7} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool6} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool5} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool4} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool3} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool2} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool1} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawBool0} (char *dest, int destLen, void *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateBool} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check boolean (accept only '0' or '1') }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateD} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check decimal unsigned integers If {\i max}  is 0, no range checking is done }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateSD} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check decimal signed integers If {\i max}  is 0, no range checking is done }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateX} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check hexadecimal unsigned integers If {\i max}  is 0, no range checking is done }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateStr} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check length of string {\i max}  is the max allowed string length, excluding term '\\0' }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateRev} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check revision number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateTcal} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check revision number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateEth} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check ethernet MAC number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateNspeed} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check Nspeed value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateComMode} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check COM mode value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidateBaud} (const char *src, int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check baudrate value If {\i max}  is 0, no range checking is done }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpCreateStd} ({\b SYSP_NV_STORAGE} *nvs, const char *name, int nvsOffset, int nvsSize, const {\b SYSP_PAR_DESC} *parList, u_int8 magic, {\b SYSP_PGRP_MAGPAR} **mpGrpP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create and read magic/parity parameter for non-production data section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpCreateStdRo} ({\b SYSP_NV_STORAGE} *nvs, const char *name, int nvsOffset, int nvsSize, const {\b SYSP_PAR_DESC} *parList, u_int8 magic, {\b SYSP_PGRP_MAGPAR} **mpGrpP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i same as SYSP_MpGrpCreateStd but group read only }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpCreateProd} ({\b SYSP_NV_STORAGE} *nvs, const char *name, int nvsOffset, int nvsSize, const {\b SYSP_PAR_DESC} *parList, u_int8 magic, {\b SYSP_PGRP_MAGPAR} **mpGrpP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create and read magic/parity parameter for production data section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_EeprodGrpCreate} ({\b SYSP_NV_STORAGE} *nvs, const char *expHwNames[], int ignoreNvsError)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EEPROD parameter group. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_Eeprod2GrpCreate} ({\b SYSP_NV_STORAGE} *nvs, const char *expHwNames[], int ignoreNvsError)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EEPROD2 parameter group. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_Eeprod2GrpCreateEx} ({\b SYSP_NV_STORAGE} *nvs, const char *expHwNames[], u_int32 offset, int ignoreNvsError)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for EEPROD2 parameter group. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_Eeprod3GrpCreate} ({\b SYSP_NV_STORAGE} *nvs, const char *expHwNames[], int ignoreNvsError)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_Eeprod3GrpCreateEx} ({\b SYSP_NV_STORAGE} *nvs, const char *expHwNames[], u_int32 offset, int ignoreNvsError)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_TusParamSet} (char *tus, int tusMaxLen, const char *parName, const char *parVal)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set value of parameter {\i parName}  in tuple string. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MmgrpCreate} ({\b SYSP_NV_STORAGE} *nvs, const char *name, const {\b SYSP_CONST_STRING} *parList, int bufSize, const char *mmParaStr, int mmParaStrMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create a parameter group object for Menmon parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MmParaStringBuild} (char *mmParaStr, int mmParaStrMaxLen, {\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Build MENMON parameter string. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_VxGrpCreate} ({\b SYSP_NV_STORAGE} *nvs, int nvsOffset, int nvsSize, char *vxBline, const char *vxDefBline, int provideKerpar)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create a parameter group object for VxWorks bootline parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawVxblIp} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Extract IP address from VxBl "e" field Return everything until first ":" or until EOS if no ":". }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawVxblSm} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Extract subnet mask from VxBl "e" field Return everything after first ":" between next ":" or EOS. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawVxblIp} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i modify VxBl IP in "e" NOTE: Destroys informatation in ead other than IP and subnetmask (e.g. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawVxblSm} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i modify VxBl SM in "e" }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StrGrpCreate} ({\b SYSP_NV_STORAGE} *nvs, const char *name, const char *alias, int nvsOffset, int nvsSize, const char *defVal)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create a parameter group object for simple strings. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_EsmCarrierInitGlobals} (int addr, int size, char prefix)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set Devive Address and Size for Carrier Board. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_EsmCarrierProbe} ({\b SYSP_SUPER} *super, int smbBusNo)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for all possible known ESM carrier boards. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsAd65EtcProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for AD65 and boards with same EEPROM layout. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_Pp01CarrierProbe} ({\b SYSP_SUPER} *super, char *sectionName, char *prefix, int smbBusNo, u_int32 devAddr, u_int32 devSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_Vc01CarrierProbe} ({\b SYSP_SUPER} *super, char *sectionName, char *prefix, int smbBusNo, u_int32 devAddr, u_int32 devSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_IsEsmCB_with_EEPROD2} (const char *brdName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i look in Table to see if EEPROD2 structure should be used with carrier board }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsHamedCompProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for HAMED and boards with same EEPROM layout. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsSaurerProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for Saurer and boards with same EEPROM layout. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEsmxCbProbe} ({\b SYSP_NV_STORAGE} *nvs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for ESMexpress carrier boards and boards with same EEPROM layout. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_MmNetIfParamsCreate} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create object to handle all fake NETIF parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_AddParamTable} ({\b SYSP_HELP_DESC_TBL} *newTable)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Add a table for board specific parameters. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_SUPER} * {\b SYSP_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i the only global variable. }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Internal header file for sysparam library. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2010/06/07 16:21:39 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.26 \par
}\par
}\par
{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v DBG_MYLEVEL\:sysp_intern.h}
{\xe \v sysp_intern.h\:DBG_MYLEVEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DBG_MYLEVEL\~ DBG_ALL}
}\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v DBH\:sysp_intern.h}
{\xe \v sysp_intern.h\:DBH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DBH\~ ({\b SYSP_super}->dbh)}
}\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ALLOC\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ALLOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b SYSP_ALLOC}(_size, _super)\~ SYSP_Alloc( &(_super)->alloc, _size)}
}\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
alloc a number of bytes from the super objects main allocation object \par
\par
\par
}
{\xe \v SYSP_ALLOC_INIT\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ALLOC_INIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_ALLOC_INIT(_super, _arr)}
}\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid do \{ \\\par
 _super->alloc.mem = (u_int8 *)(_arr); _super->alloc.size = sizeof(_arr);\\\par
 _super->alloc.minavail=0x7fffffff;\\\par
\} while(0);\par
\par
}
initialize super's {\b SYSP_ALLOC} structure with array {\i _arr}  \par
\par
}
{\xe \v SYSP_ALLOC_UNDO\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ALLOC_UNDO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_ALLOC_UNDO(_size, _super)\~ SYSP_AllocUndo( &(_super)->alloc, _size)}
}\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
undo {\b SYSP_ALLOC} \par
\par
\par
}
{\xe \v SYSP_DONT_PROVIDE_KERPAR\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_DONT_PROVIDE_KERPAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_DONT_PROVIDE_KERPAR\~ 0}
}\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_INTERNAL_RESTART\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_INTERNAL_RESTART}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_INTERNAL_RESTART\~ 0x8000}
}\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
special internal error code to restart entire sysparam \par
\par
\par
}
{\xe \v SYSP_PDE_BAUD\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_BAUD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_BAUD(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawU32D, SYSP_FromRawU32D, SYSP_ValidateBaud,\\\par
   _deflt, 0, _flg \}\par
\par
}
baudrate value \par
\par
}
{\xe \v SYSP_PDE_BOOL0\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_BOOL0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_BOOL0(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, \\\par
   SYSP_ToRawBool0, SYSP_FromRawBool0, SYSP_ValidateBool,\\\par
   _deflt, 0, _flg \}\par
\par
}
boolean value stored in bit0 of 8 bit fields \par
\par
}
{\xe \v SYSP_PDE_BOOL1\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_BOOL1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_BOOL1(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, \\\par
   SYSP_ToRawBool1, SYSP_FromRawBool1, SYSP_ValidateBool,\\\par
   _deflt, 0, _flg \}\par
\par
}
boolean value stored in bit1 of 8 bit fields \par
\par
}
{\xe \v SYSP_PDE_BOOL2\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_BOOL2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_BOOL2(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, \\\par
   SYSP_ToRawBool2, SYSP_FromRawBool2, SYSP_ValidateBool,\\\par
   _deflt, 0, _flg \}\par
\par
}
boolean value stored in bit2 of 8 bit fields \par
\par
}
{\xe \v SYSP_PDE_BOOL3\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_BOOL3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_BOOL3(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, \\\par
   SYSP_ToRawBool3, SYSP_FromRawBool3, SYSP_ValidateBool,\\\par
   _deflt, 0, _flg \}\par
\par
}
boolean value stored in bit3 of 8 bit fields \par
\par
}
{\xe \v SYSP_PDE_BOOL4\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_BOOL4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_BOOL4(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, \\\par
   SYSP_ToRawBool4, SYSP_FromRawBool4, SYSP_ValidateBool,\\\par
   _deflt, 0, _flg \}\par
\par
}
boolean value stored in bit4 of 8 bit fields \par
\par
}
{\xe \v SYSP_PDE_BOOL5\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_BOOL5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_BOOL5(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, \\\par
   SYSP_ToRawBool5, SYSP_FromRawBool5, SYSP_ValidateBool,\\\par
   _deflt, 0, _flg \}\par
\par
}
boolean value stored in bit5 of 8 bit fields \par
\par
}
{\xe \v SYSP_PDE_BOOL6\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_BOOL6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_BOOL6(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, \\\par
   SYSP_ToRawBool6, SYSP_FromRawBool6, SYSP_ValidateBool,\\\par
   _deflt, 0, _flg \}\par
\par
}
boolean value stored in bit6 of 8 bit fields \par
\par
}
{\xe \v SYSP_PDE_BOOL7\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_BOOL7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_BOOL7(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, \\\par
   SYSP_ToRawBool7, SYSP_FromRawBool7, SYSP_ValidateBool,\\\par
   _deflt, 0, _flg \}\par
\par
}
boolean value stored in bit7 of 8 bit fields \par
\par
}
{\xe \v SYSP_PDE_BSADR\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_BSADR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_BSADR(_eeoff)\~ SYSP_PDE_U32X({\b SYSP_bsadr}, {\b SYSP_bs}, (_eeoff), "0", (SYSP_PD_MMPARASTR*0))}
}\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_PDE_CBR\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_CBR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_CBR(_eeoff)}
}\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_BAUD(SYSP_cbr, SYSP_baud, (_eeoff), "9600",\\\par
 SYSP_PD_MMPARASTR | SYSP_PD_NEEDRESET)\par
\par
}
}
{\xe \v SYSP_PDE_COMMODE\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_COMMODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_COMMODE(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawComMode, SYSP_FromRawComMode, \\\par
   SYSP_ValidateComMode,\\\par
   _deflt, 0, _flg \}\par
\par
}
COM mode. \par
\par
}
{\xe \v SYSP_PDE_CON0\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_CON0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_CON0(_eeoff, _def)}
}\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_U8X(SYSP_con0, NULL, (_eeoff), (_def), \\\par
 (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET))\par
\par
}
}
{\xe \v SYSP_PDE_CON1\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_CON1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_CON1(_eeoff, _def)}
}\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_U8X(SYSP_con1, NULL, (_eeoff), (_def), \\\par
 (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET))\par
\par
}
}
{\xe \v SYSP_PDE_CON2\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_CON2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_CON2(_eeoff, _def)}
}\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_U8X(SYSP_con2, NULL, (_eeoff), (_def), \\\par
 (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET))\par
\par
}
}
{\xe \v SYSP_PDE_CON3\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_CON3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_CON3(_eeoff, _def)}
}\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_U8X(SYSP_con3, NULL, (_eeoff), (_def), \\\par
 (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET))\par
\par
}
}
{\xe \v SYSP_PDE_ECL\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_ECL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_ECL(_eeoff)}
}\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_U8X(SYSP_ecl, NULL, (_eeoff), "ff", \\\par
 (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET))\par
\par
}
}
{\xe \v SYSP_PDE_END\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_END\~ \{ NULL \}}
}\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
End marker. \par
\par
\par
}
{\xe \v SYSP_PDE_ETH\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_ETH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_ETH(_nm, _alias, _offs, _deflt)}
}\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawEth, SYSP_FromRawEth, SYSP_ValidateEth,\\\par
   _deflt, 0, SYSP_PD_MMPARASTR \}\par
\par
}
Ethernet MAC address. \par
\par
}
{\xe \v SYSP_PDE_GCON\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_GCON}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_GCON(_eeoff, _def)}
}\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_U8X(SYSP_gcon, NULL, (_eeoff), (_def), \\\par
 (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET))\par
\par
}
}
{\xe \v SYSP_PDE_HDP\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_HDP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_HDP(_eeoff)}
}\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_S16D(SYSP_hdp, NULL, (_eeoff), "-1", \\\par
 (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET))\par
\par
}
}
{\xe \v SYSP_PDE_NINTD\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_NINTD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_NINTD(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawNatIntD, SYSP_FromRawNatIntD,SYSP_ValidateD,\\\par
   _deflt, 0, _flg \}\par
\par
}
native unsigned int decimal \par
\par
}
{\xe \v SYSP_PDE_NINTX\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_NINTX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_NINTX(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawNatIntX, SYSP_FromRawNatIntX,SYSP_ValidateX,\\\par
   _deflt, 0, _flg \}\par
\par
}
native unsigned int hexadecimal \par
\par
}
{\xe \v SYSP_PDE_NSPEED\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_NSPEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_NSPEED(_nm, _alias, _offs, _deflt)}
}\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawNspeed, SYSP_FromRawNspeed, \\\par
   SYSP_ValidateNspeed,\\\par
   _deflt, 0, SYSP_PD_MMPARASTR | SYSP_PD_NEEDRESET \}\par
\par
}
Nspeed value. \par
\par
}
{\xe \v SYSP_PDE_REV\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_REV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_REV(_nm, _alias, _offs)}
}\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawRev, SYSP_FromRawRev, SYSP_ValidateRev,\\\par
   NULL, 0, SYSP_PD_MMPARASTR \}\par
\par
}
MEN HW revision. \par
\par
}
{\xe \v SYSP_PDE_S16D\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_S16D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_S16D(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawS16D, SYSP_FromRawS16D, SYSP_ValidateSD,\\\par
   _deflt, 0, _flg \}\par
\par
}
S16 decimal. \par
\par
}
{\xe \v SYSP_PDE_STR\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_STR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_STR(_nm, _alias, _offs, _deflt, _len, _flg)}
}\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawStr, SYSP_FromRawStr, SYSP_ValidateStr,\\\par
   _deflt, _len, _flg\}\par
\par
}
ASCII string. \par
\par
}
{\xe \v SYSP_PDE_STRUPPER\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_STRUPPER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_STRUPPER(_nm, _alias, _offs, _deflt, _len, _flg)}
}\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawStrUpper, SYSP_FromRawStr, SYSP_ValidateStr,\\\par
   _deflt, _len, _flg\}\par
\par
}
ASCII string (only upper case). \par
\par
}
{\xe \v SYSP_PDE_STWAIT\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_STWAIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_STWAIT(_eeoff, _def)\~ SYSP_PDE_U8D({\b SYSP_stwait}, NULL, (_eeoff), (_def), (SYSP_PD_MMPARASTR*0))}
}\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_PDE_TCAL\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_TCAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_TCAL(_nm, _alias, _offs, _deflt)}
}\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawTcal, SYSP_FromRawTcal, SYSP_ValidateTcal,\\\par
   _deflt, 0, SYSP_PD_MMPARASTR \}\par
\par
}
Touch calibration (4 integers comma separated). \par
\par
}
{\xe \v SYSP_PDE_TDP\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_TDP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_TDP(_eeoff)}
}\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_S16D(SYSP_tdp, NULL, (_eeoff), "-1", \\\par
 (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET))\par
\par
}
}
{\xe \v SYSP_PDE_TRIES\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_TRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_TRIES(_eeoff)}
}\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_U8D(SYSP_tries, NULL, (_eeoff), "20", \\\par
 (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET))\par
\par
}
}
{\xe \v SYSP_PDE_TTO\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_TTO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_TTO(_eeoff)}
}\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_U8D(SYSP_tto, NULL, (_eeoff), "0", \\\par
 (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET))\par
\par
}
}
{\xe \v SYSP_PDE_U16X\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_U16X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_U16X(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawU16X, SYSP_FromRawU16X, SYSP_ValidateX,\\\par
   _deflt, 0xFFFF, _flg \}\par
\par
}
U16 hex. \par
\par
}
{\xe \v SYSP_PDE_U32D\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_U32D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_U32D(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawU32D, SYSP_FromRawU32D, SYSP_ValidateD,\\\par
   _deflt, 0, _flg \}\par
\par
}
U32 decimal. \par
\par
}
{\xe \v SYSP_PDE_U32X\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_U32X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_U32X(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawU32X, SYSP_FromRawU32X, SYSP_ValidateX,\\\par
   _deflt, 0, _flg\}\par
\par
}
U32 hex. \par
\par
}
{\xe \v SYSP_PDE_U8D\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_U8D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_U8D(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawU8D, SYSP_FromRawU8D, SYSP_ValidateD,\\\par
   _deflt, 0xFF, _flg \}\par
\par
}
U8 dec. \par
\par
}
{\xe \v SYSP_PDE_U8X\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_U8X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_U8X(_nm, _alias, _offs, _deflt, _flg)}
}\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawU8X, SYSP_FromRawU8X, SYSP_ValidateX,\\\par
   _deflt, 0xFF, _flg\}\par
\par
}
U8 hex. \par
\par
}
{\xe \v SYSP_PDE_UXX\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_UXX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_UXX(_eeoff)}
}\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_U16X("u00",        NULL, (_eeoff)+0x0,     "0", 0),\\\par
    SYSP_PDE_U16X("u01",        NULL, (_eeoff)+0x2,     "0", 0),\\\par
    SYSP_PDE_U16X("u02",        NULL, (_eeoff)+0x4,     "0", 0),\\\par
    SYSP_PDE_U16X("u03",        NULL, (_eeoff)+0x6,     "0", 0),\\\par
    SYSP_PDE_U16X("u04",        NULL, (_eeoff)+0x8,     "0", 0),\\\par
    SYSP_PDE_U16X("u05",        NULL, (_eeoff)+0xa,     "0", 0),\\\par
    SYSP_PDE_U16X("u06",        NULL, (_eeoff)+0xc,     "0", 0),\\\par
    SYSP_PDE_U16X("u07",        NULL, (_eeoff)+0xe,     "0", 0),\\\par
    SYSP_PDE_U16X("u08",        NULL, (_eeoff)+0x10,    "0", 0),\\\par
    SYSP_PDE_U16X("u09",        NULL, (_eeoff)+0x12,    "0", 0),\\\par
    SYSP_PDE_U16X("u10",        NULL, (_eeoff)+0x14,    "0", 0),\\\par
    SYSP_PDE_U16X("u11",        NULL, (_eeoff)+0x16,    "0", 0),\\\par
    SYSP_PDE_U16X("u12",        NULL, (_eeoff)+0x18,    "0", 0),\\\par
    SYSP_PDE_U16X("u13",        NULL, (_eeoff)+0x1a,    "0", 0),\\\par
    SYSP_PDE_U16X("u14",        NULL, (_eeoff)+0x1c,    "0", 0),\\\par
    SYSP_PDE_U16X("u15",        NULL, (_eeoff)+0x1e,    "0", 0)\par
\par
}
}
{\xe \v SYSP_PDE_VMODE\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_VMODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_VMODE(_eeoff)}
}\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SYSP_PDE_U16X(SYSP_vmode, NULL, (_eeoff), "101", \\\par
 (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET))\par
\par
}
}
{\xe \v SYSP_PDE_WDT\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PDE_WDT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_WDT(_eeoff, _def)\~ SYSP_PDE_S16D({\b SYSP_wdt}, NULL, (_eeoff), (_def), (SYSP_PD_MMPARASTR*0))}
}\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_PRINTABLE\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PRINTABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PRINTABLE(ch)\~ IN_RANGE( ch, 0x20, 0x7e )}
}\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
test if {\i ch}  is a valid printable ASCII char \par
\par
\par
}
{\xe \v SYSP_PROVIDE_KERPAR\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PROVIDE_KERPAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PROVIDE_KERPAR\~ 1}
}\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v SYSP_ALLOC\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ALLOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b SYSP_ALLOC}  {\b SYSP_ALLOC}}
}\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
structure to maintain allocated objects \par
\par
\par
}
{\xe \v SYSP_HELP_DESC_TBL\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_HELP_DESC_TBL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b SYSP_HELP_DESC_TBL}  {\b SYSP_HELP_DESC_TBL}}
}\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Descriptor for parameter description table. \par
\par
\par
}
{\xe \v SYSP_NV_STORAGE\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_NV_STORAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b SYSP_NV_STORAGE}  {\b SYSP_NV_STORAGE}}
}\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
NV storage object. \par
Contains the methods and variables to handle an instance of a sysparam NV storage (EEPROM). \par
\par
}
{\xe \v SYSP_PAR_GRP\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PAR_GRP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b SYSP_PAR_GRP}  {\b SYSP_PAR_GRP}}
}\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Parameter group object. \par
Contains the methods and variables to handle an instance of a parameter group, e.g. a section in an EEPROM or parameter group for VxBline or menmon parameter string \par
\par
}
{\xe \v SYSP_SUPER\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_SUPER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b SYSP_SUPER}  {\b SYSP_SUPER}}
}\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sysparam super object. \par
\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v SYSP_PD_FLAGS\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PD_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SYSP_PD_FLAGS}}
}\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumeration values: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v SYSP_PD_NONE\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PD_NONE}
{\b {\i {\i SYSP_PD_NONE}{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
}}  \par
{\xe \v SYSP_PD_MMPARASTR\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PD_MMPARASTR}
{\b {\i {\i SYSP_PD_MMPARASTR}{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
}}  include it in MENMON parameter string \par
{\xe \v SYSP_PD_RESTART\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PD_RESTART}
{\b {\i {\i SYSP_PD_RESTART}{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
}}  return SYSP_INTERNAL_RESTART when set \par
{\xe \v SYSP_PD_NEEDRESET\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PD_NEEDRESET}
{\b {\i {\i SYSP_PD_NEEDRESET}{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
}}  parameter needs restart to take effect \par
{\xe \v SYSP_PD_ENCRYPT\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_PD_ENCRYPT}
{\b {\i {\i SYSP_PD_ENCRYPT}{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
}}  parameter output encrypted \par
}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v SYSP_AddParamTable\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_AddParamTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_AddParamTable ({\b SYSP_HELP_DESC_TBL} * {\i newTable})}
}\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Add a table for board specific parameters. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i newTable} {\b IN}  table to add \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
 \par
}\par
\par
}
{\xe \v SYSP_Alloc\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_Alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* SYSP_Alloc ({\b SYSP_ALLOC} * {\i alloc}, int {\i size})}
}\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Allocate block from heap specified with {\i alloc} . \par
Tries to allocate {\i size}  bytes from the heap maintained with {\i alloc} . On Success, returns a pointer to the first byte of the block. The data block is filled with zeroes.\par
If not enough mem available, NULL is returned.\par
{{\b \par
Warning:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This is not a full malloc() implementation. A memory block can only be free'ed when no other allocs have been made in the meantime; i.e. it works like a stack.\par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_AllocUndo}, {\b SYSP_ALLOC}, {\b SYSP_ALLOC_UNDO}, {\b SYSP_ALLOC_INIT} \par
}\par
\par
}
{\xe \v SYSP_AllocUndo\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_AllocUndo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_AllocUndo ({\b SYSP_ALLOC} * {\i alloc}, int {\i size})}
}\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Undo previous alloc. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_Alloc}, {\b SYSP_ALLOC_UNDO} \par
}\par
\par
}
{\xe \v SYSP_ContainsBlanks\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ContainsBlanks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ContainsBlanks (const char * {\i s})}
}\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if {\i s}  contains blanks or tabs. \par
\par
\par
}
{\xe \v SYSP_Eeprod2GrpCreate\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_Eeprod2GrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_Eeprod2GrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i expHwNames}[], int {\i ignoreNvsError})}
}\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EEPROD2 parameter group. \par
On success, (and if hwName matched), the created parameter group is added to the NVS' list.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i expHwNames} {\b IN}  array of bord names tolerated (null-terminated). Can be NULL, in this case, any name will match. \par
{\i ignoreNvsError} {\b IN}  if TRUE, a NVS read error is ignored\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_Eeprod2GrpCreateEx\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_Eeprod2GrpCreateEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_Eeprod2GrpCreateEx ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i expHwNames}[], u_int32 {\i offset}, int {\i ignoreNvsError})}
}\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EEPROD2 parameter group. \par
On success, (and if hwName matched), the created parameter group is added to the NVS' list.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i expHwNames} {\b IN}  array of bord names tolerated (null-terminated). \par
{\i offset} {\b IN}  offset of EEPROD2 structure inside EEPROM \par
{\i ignoreNvsError} {\b IN}  if TRUE, a NVS read error is ignored\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_Eeprod3GrpCreate\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_Eeprod3GrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_Eeprod3GrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i expHwNames}[], int {\i ignoreNvsError})}
}\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_Eeprod3GrpCreateEx\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_Eeprod3GrpCreateEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_Eeprod3GrpCreateEx ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i expHwNames}[], u_int32 {\i offset}, int {\i ignoreNvsError})}
}\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_EeprodGrpCreate\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_EeprodGrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_EeprodGrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i expHwNames}[], int {\i ignoreNvsError})}
}\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for EEPROD parameter group. \par
On success, (and if hwName matched), the created parameter group is added to the NVS' list.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i expHwNames} {\b IN}  array of bord names tolerated (null-terminated). Can be NULL, in this case, any name will match. \par
{\i ignoreNvsError} {\b IN}  if TRUE, a NVS read error is ignored\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_EsmCarrierInitGlobals\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_EsmCarrierInitGlobals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_EsmCarrierInitGlobals (int {\i addr}, int {\i size}, char {\i prefix})}
}\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set Devive Address and Size for Carrier Board. \par
if data differs from default this routine have to be called before probing the ESMCB board. \par
\par
}
{\xe \v SYSP_EsmCarrierProbe\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_EsmCarrierProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_EsmCarrierProbe ({\b SYSP_SUPER} * {\i super}, int {\i smbBusNo})}
}\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for all possible known ESM carrier boards. \par
Prefix will be 'c' always. SMB addresses are hardcoded (0xac).\par
If nothing could be read from SMB (no board EEPROM there), no parameter group is created and {\b SYSPARAM_EEPROM_ERROR} is returned.\par
If an unknown/unprogrammed board is found, a parameter group for standard EEPROD section is setup\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i super} {\b IN}  sysparam super object \par
{\i smbBusNo} {\b IN}  SMB bus number\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_FindParDesc\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FindParDesc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC}* SYSP_FindParDesc (const {\b SYSP_PAR_DESC} * {\i parList}, const char * {\i parName})}
}\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Find parameter description structure in array by parameter name. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parList} {\b IN}  parameter list \par
{\i parName} {\b IN}  parameter name to find (official or alias) \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYS_PAR_DESC structure or NULL if not found \par
}\par
\par
}
{\xe \v SYSP_FromRawBool0\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawBool0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool0 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool1\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawBool1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool1 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool2\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawBool2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool2 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool3\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawBool3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool3 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool4\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawBool4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool4 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool5\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawBool5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool5 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool6\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawBool6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool6 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawBool7\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawBool7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawBool7 (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawComMode\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawComMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawComMode (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from COM mode number \par
\par
\par
}
{\xe \v SYSP_FromRawNatIntD\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawNatIntD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawNatIntD (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from int (native endian), decimal \par
\par
\par
}
{\xe \v SYSP_FromRawNatIntX\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawNatIntX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawNatIntX (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from int (native endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_FromRawNspeed\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawNspeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawNspeed (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from Nspeed number \par
\par
\par
}
{\xe \v SYSP_FromRawRev\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawRev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawRev (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from revision number returns empty string if all bytes are 0xff \par
\par
\par
}
{\xe \v SYSP_FromRawS16D\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawS16D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawS16D (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from int16 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_FromRawStr\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawStr (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from string returns an empty string if {\i src}  (raw data) contains any non-printable char. \par
\par
\par
}
{\xe \v SYSP_FromRawTcal\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawTcal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawTcal (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from touch calibration \par
\par
\par
}
{\xe \v SYSP_FromRawU16D\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawU16D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU16D (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int16 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_FromRawU16X\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawU16X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU16X (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int16 (big endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_FromRawU32D\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawU32D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU32D (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int32 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_FromRawU32X\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawU32X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU32X (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int32 (big endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_FromRawU8D\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawU8D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU8D (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int8, decimal \par
\par
\par
}
{\xe \v SYSP_FromRawU8X\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawU8X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawU8X (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from u_int8, hexadecimal \par
\par
\par
}
{\xe \v SYSP_FromRawVxblIp\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawVxblIp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawVxblIp (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Extract IP address from VxBl "e" field Return everything until first ":" or until EOS if no ":". \par
\par
\par
}
{\xe \v SYSP_FromRawVxblSm\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FromRawVxblSm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawVxblSm (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Extract subnet mask from VxBl "e" field Return everything after first ":" between next ":" or EOS. \par
\par
\par
}
{\xe \v SYSP_FullParName\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_FullParName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* SYSP_FullParName ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i parName}, char * {\i buf})}
}\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Make full parameter name incl. \par
prefix\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  nvs object \par
{\i parName} {\b IN}  parameter name without prefix \par
{\i buf} {\b OUT}  receives the full parameter name. must have space for SYSP_PREFIX_LEN + SYSP_PARNAME_LEN chars \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pointer to buf \par
}\par
\par
}
{\xe \v SYSP_IsEsmCB_with_EEPROD2\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_IsEsmCB_with_EEPROD2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_IsEsmCB_with_EEPROD2 (const char * {\i brdName})}
}\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
look in Table to see if EEPROD2 structure should be used with carrier board \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i brdName} {\b IN}  board name\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid TRUE if match, FALSE for fail \par
}\par
\par
}
{\xe \v SYSP_MmgrpCreate\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_MmgrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MmgrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, const {\b SYSP_CONST_STRING} * {\i parList}, int {\i bufSize}, const char * {\i mmParaStr}, int {\i mmParaStrMaxLen})}
}\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create a parameter group object for Menmon parameters. \par
Extracts all parameters present in {\i parList}  from the passed {\i mmParaStr}  \par
On success, the parameter group is added to the list of {\i nvs}  groups\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i parList} {\b IN}  array of parameters in this section (NULL term.) array and pointers must be kept intact! \par
{\i bufSize} {\b IN}  max. size of name=value buffer string (for all params) \par
{\i mmParaStr} {\b IN}  the current full MENMON parameter string \par
{\i mmParaStrMaxLen} {\b IN}  max length that mmParaStr can hold (incl. '\\0')\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid created mmGrp object (or NULL if failed) \par
}\par
\par
}
{\xe \v SYSP_MmNetIfParamsCreate\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_MmNetIfParamsCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_MmNetIfParamsCreate ({\b SYSP_SUPER} * {\i super})}
}\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create object to handle all fake NETIF parameters. \par
Should be called{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
from CPU specific probe routine (to ensure parameters exist after a restart) \par
}
\par
\par
}
{\xe \v SYSP_MmParaStringBuild\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_MmParaStringBuild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MmParaStringBuild (char * {\i mmParaStr}, int {\i mmParaStrMaxLen}, {\b SYSP_SUPER} * {\i super})}
}\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Build MENMON parameter string. \par
Builds a tuple string from all parameters in all groups of all NV storage objects, whose attributes report that they want to be included in MM parameter string, and builds a tuple string into {\i mmParaStr} .\par
The official parameter names with prefix will be written to MM para string\par
If a parameter tuple doesn't fit as a whole into {\i mmParaStr} , the tuple is omitted and the function returns SYSPARAM_NO_RESOURCE.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i mmParaStr} {\b OUT}  receives the created MM parameter string \par
{\i mmParaStrMaxLen} {\b IN}  max length of {\i mmParaStr}  (incl. term. 0) \par
{\i super} {\b IN}  SYSPARAM super object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code \par
}\par
\par
}
{\xe \v SYSP_MpGrpCreateProd\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_MpGrpCreateProd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpCreateProd ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, int {\i nvsOffset}, int {\i nvsSize}, const {\b SYSP_PAR_DESC} * {\i parList}, u_int8 {\i magic}, {\b SYSP_PGRP_MAGPAR} ** {\i mpGrpP})}
}\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create and read magic/parity parameter for production data section. \par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Creates and initializes a {\b SYSP_PGRP_MAGPAR} object.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets all method pointers to defaults\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
reads NV storage\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
checks magic parity\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets defaults if either NV storage read failed or magic/parity bad (defaults are all FF's).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The group must be added to NVS group list by caller!\par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i nvsOffset} {\b IN}  starting byte offset of section within NV storage \par
{\i nvsSize} {\b IN}  size of section in bytes \par
{\i parList} {\b IN}  array of parameters in this section. Default values in parList are ignored! \par
{\i magic} {\b IN}  magic ID of section \par
{\i mpGrpP} {\b OUT}  receives created group object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_EEPROM_ERROR: NVS read failed (mpGrp created)\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_INVAL_VALUE: bad magic/parity (mpGrp created) \par
}
\par
}\par
\par
}
{\xe \v SYSP_MpGrpCreateStd\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_MpGrpCreateStd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpCreateStd ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, int {\i nvsOffset}, int {\i nvsSize}, const {\b SYSP_PAR_DESC} * {\i parList}, u_int8 {\i magic}, {\b SYSP_PGRP_MAGPAR} ** {\i mpGrpP})}
}\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create and read magic/parity parameter for non-production data section. \par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Creates and initializes a {\b SYSP_PGRP_MAGPAR} object.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets all method pointers to defaults\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
reads NV storage\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
checks magic parity\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets defaults if either NV storage read failed or magic/parity bad\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Adds group to NVS group list\par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i nvsOffset} {\b IN}  starting byte offset of section within NV storage \par
{\i nvsSize} {\b IN}  size of section in bytes \par
{\i parList} {\b IN}  array of parameters in this section \par
{\i magic} {\b IN}  magic ID of section \par
{\i mpGrpP} {\b OUT}  receives created group object (if non NULL)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
 Any value != 0 means that the group has not been created \par
}\par
\par
}
{\xe \v SYSP_MpGrpCreateStdRo\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_MpGrpCreateStdRo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpCreateStdRo ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, int {\i nvsOffset}, int {\i nvsSize}, const {\b SYSP_PAR_DESC} * {\i parList}, u_int8 {\i magic}, {\b SYSP_PGRP_MAGPAR} ** {\i mpGrpP})}
}\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
same as SYSP_MpGrpCreateStd but group read only \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i nvsOffset} {\b IN}  starting byte offset of section within NV storage \par
{\i nvsSize} {\b IN}  size of section in bytes \par
{\i parList} {\b IN}  array of parameters in this section \par
{\i magic} {\b IN}  magic ID of section \par
{\i mpGrpP} {\b OUT}  receives created group object (if non NULL)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
 Any value != 0 means that the group has not been created \par
}\par
\par
}
{\xe \v SYSP_NvsAd65EtcProbe\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_NvsAd65EtcProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsAd65EtcProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for AD65 and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_NvsAdd\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_NvsAdd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_NvsAdd ({\b SYSP_SUPER} * {\i super}, {\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Add a NV storage object to super list of NVS object. \par
\par
\par
}
{\xe \v SYSP_NvsCreate\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_NvsCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_NV_STORAGE}* SYSP_NvsCreate (int {\i objSize}, const char * {\i nvsName}, {\b SYSP_SUPER} * {\i super}, const char * {\i prefix}, {\b SYSP_NVS_ADR} {\i nvsAdr}, u_int32 {\i nvsSize})}
}\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create a {\b SYSP_NV_STORAGE} object. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i objSize} {\b IN}  size of object (>= {\b SYSP_NV_STORAGE} structure) \par
{\i nvsName} {\b IN}  name of NVS (must remain intact!) \par
{\i super} {\b IN}  sysparam super object \par
{\i prefix} {\b IN}  NVS parameter name prefix (up to 3 chars), caller can destroy pointer later \par
{\i nvsAdr} {\b IN}  NVS address \par
{\i nvsSize} {\b IN}  size of NVS section in bytes\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid allocated and initialized {\b SYSP_NV_STORAGE} object or NULL if alloc failed.\par
}all method pointers are set to their default functions \par
\par
}
{\xe \v SYSP_NvsEsmxCbProbe\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_NvsEsmxCbProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEsmxCbProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for ESMexpress carrier boards and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_NvsFind\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_NvsFind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_NV_STORAGE}* SYSP_NvsFind ({\b SYSP_SUPER} * {\i super}, const char * {\i nvsName})}
}\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Find NV storage object by name. \par
\par
\par
}
{\xe \v SYSP_NvsHamedCompProbe\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_NvsHamedCompProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsHamedCompProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for HAMED and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_NvsSaurerProbe\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_NvsSaurerProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsSaurerProbe ({\b SYSP_NV_STORAGE} * {\i nvs})}
}\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for Saurer and boards with same EEPROM layout. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_ParDescArrayLen\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ParDescArrayLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ParDescArrayLen (const {\b SYSP_PAR_DESC} * {\i parList})}
}\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
get number of entries in SYSP_PAR_DESC_ARRAY \par
\par
\par
}
{\xe \v SYSP_ParGrpAdd\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ParGrpAdd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_ParGrpAdd ({\b SYSP_NV_STORAGE} * {\i nvs}, {\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Add a parameter group object to NVS list of parameter groups. \par
\par
\par
}
{\xe \v SYSP_ParNameToGroup\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ParNameToGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_PAR_GRP}* SYSP_ParNameToGroup ({\b SYSP_SUPER} * {\i super}, const char * {\i parName}, const char ** {\i pureNameP})}
}\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Find parameter group that handles {\i parName} . \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i super} {\b IN}  SYSPARAM super object \par
{\i parName} {\b IN}  parameter name to (including NVS prefix), \par
{\i *pureNameP} {\b OUT}  if not NULL, receives a pointer to the pure parameter name without prefix \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid parameter group or NULL if not found \par
}\par
\par
}
{\xe \v SYSP_Pp01CarrierProbe\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_Pp01CarrierProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_Pp01CarrierProbe ({\b SYSP_SUPER} * {\i super}, char * {\i sectionName}, char * {\i prefix}, int {\i smbBusNo}, u_int32 {\i devAddr}, u_int32 {\i devSize})}
}\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_Prefix\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_Prefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* SYSP_Prefix (const char * {\i parName}, char * {\i prefix})}
}\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Determine prefix part of {\i parName} . \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name to (including NVS prefix), e.g. "c-brd" \par
{\i prefix} {\b OUT}  receives the prefix string (null terminated) (3 chars + term. max). \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid parameter name without prefix If prefix part is longer than 3 chars, prefix will be empty \par
}\par
\par
}
{\xe \v SYSP_RunPostProcessHooks\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_RunPostProcessHooks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_RunPostProcessHooks ({\b SYSP_SUPER} * {\i super}, const char * {\i parName}, int {\i attr}, int {\i errCode})}
}\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Run all postprocessing functions. \par
\par
\par
}
{\xe \v SYSP_StrGrpCreate\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_StrGrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StrGrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, const char * {\i alias}, int {\i nvsOffset}, int {\i nvsSize}, const char * {\i defVal})}
}\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create a parameter group object for simple strings. \par
On success, the parameter group is added to the list of {\i nvs}  groups\par
The string is read from the non volatile storage. If there is a physical read error, or if it contains non-printable chars, default string is setup.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  name of parameter group and name of the parameter itsself \par
{\i alias} {\b IN}  alias name of parameter (can be NULL) \par
{\i nvsOffset} {\b IN}  starting byte offset of string within NV storage \par
{\i nvsSize} {\b IN}  max size of string in NV storage in bytes \par
{\i defVal} {\b IN}  default value for string (can be NULL)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_SuperMmsmbInit\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_SuperMmsmbInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_SuperMmsmbInit ({\b SYSP_MMSMB_SUPER} * {\i xSuper})}
}\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize extended super object for MENMON/SMB. \par
Caller must initialize the following xSuper elements:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
s.alloc\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
s.reInit\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
initBlk \par
}
\par
\par
}
{\xe \v SYSP_ToRawBool0\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawBool0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool0 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool1\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawBool1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool1 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool2\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawBool2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool2 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool3\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawBool3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool3 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool4\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawBool4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool4 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool5\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawBool5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool5 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool6\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawBool6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool6 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawBool7\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawBool7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawBool7 (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawComMode\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawComMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawComMode (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to COM mode number \par
\par
\par
}
{\xe \v SYSP_ToRawNatIntD\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawNatIntD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawNatIntD (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to int (native endian), decimal \par
\par
\par
}
{\xe \v SYSP_ToRawNatIntX\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawNatIntX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawNatIntX (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to int (native endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_ToRawNspeed\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawNspeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawNspeed (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to Nspeed number \par
\par
\par
}
{\xe \v SYSP_ToRawRev\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawRev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawRev (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to revision number \par
\par
\par
}
{\xe \v SYSP_ToRawS16D\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawS16D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawS16D (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to int16 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_ToRawStr\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawStr (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to string (hope it was checked by ValidateStr) \par
\par
\par
}
{\xe \v SYSP_ToRawStrUpper\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawStrUpper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawStrUpper (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to string (convert to upper case; hope it was checked by ValidateStr) \par
\par
\par
}
{\xe \v SYSP_ToRawTcal\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawTcal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawTcal (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to touch calibration \par
\par
\par
}
{\xe \v SYSP_ToRawU16D\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawU16D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU16D (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int16 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_ToRawU16X\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawU16X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU16X (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int16 (big endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_ToRawU32D\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawU32D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU32D (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int32 (big endian), decimal \par
\par
\par
}
{\xe \v SYSP_ToRawU32X\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawU32X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU32X (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int32 (big endian), hexadecimal \par
\par
\par
}
{\xe \v SYSP_ToRawU8D\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawU8D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU8D (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int8, decimal \par
\par
\par
}
{\xe \v SYSP_ToRawU8X\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawU8X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawU8X (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to u_int8, hexadecimal \par
\par
\par
}
{\xe \v SYSP_ToRawVxblIp\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawVxblIp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawVxblIp (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
modify VxBl IP in "e" NOTE: Destroys informatation in ead other than IP and subnetmask (e.g. \par
lease time) {\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} pointer into ead field \par
{\i src} users IP address \par
}
\par
\par
}
{\xe \v SYSP_ToRawVxblSm\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ToRawVxblSm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawVxblSm (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
modify VxBl SM in "e" \par
NOTE: Destroys informatation in ead other than IP and subnetmask (e.g. lease time) {\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} pointer into ead field \par
{\i src} users subnet mask \par
}
\par
\par
}
{\xe \v SYSP_TusParamSet\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_TusParamSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_TusParamSet (char * {\i tus}, int {\i tusMaxLen}, const char * {\i parName}, const char * {\i parVal})}
}\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set value of parameter {\i parName}  in tuple string. \par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If {\i parName}  doesn't exist in tuple string, it is created\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If {\i parVal}  is NULL or an empty string, {\i parName}  is deleted from tuple string\par
}
\par
Before the value is modified, it is checked wether it would fit in the tuple string. If it would not fit, no modification is done and {\b SYSPARAM_VAL_TRUNCATED} is returned.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i tus} {\b IN}  tuple parameter string \par
{\i tusMaxLen} {\b IN}  max length of tuple string (incl. term. 0) \par
{\i parName} {\b IN}  parameter name to search for \par
{\i parVal} {\b IN}  new parameter value (can be NULL or empty string)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 if parameter found, or \par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_NO_RESOURCE - new value doesn't fit into {\i tus}  \par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_INVAL_VALUE - invalid characters in {\i parVal}  \par
}
\par
}\par
\par
}
{\xe \v SYSP_ValidateBaud\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ValidateBaud}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateBaud (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check baudrate value If {\i max}  is 0, no range checking is done \par
\par
\par
}
{\xe \v SYSP_ValidateBool\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ValidateBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateBool (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check boolean (accept only '0' or '1') \par
\par
\par
}
{\xe \v SYSP_ValidateComMode\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ValidateComMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateComMode (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check COM mode value \par
\par
\par
}
{\xe \v SYSP_ValidateD\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ValidateD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateD (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check decimal unsigned integers If {\i max}  is 0, no range checking is done \par
\par
\par
}
{\xe \v SYSP_ValidateEth\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ValidateEth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateEth (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check ethernet MAC number \par
\par
\par
}
{\xe \v SYSP_ValidateNspeed\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ValidateNspeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateNspeed (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check Nspeed value \par
\par
\par
}
{\xe \v SYSP_ValidateRev\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ValidateRev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateRev (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check revision number \par
\par
\par
}
{\xe \v SYSP_ValidateSD\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ValidateSD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateSD (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check decimal signed integers If {\i max}  is 0, no range checking is done \par
\par
\par
}
{\xe \v SYSP_ValidateStr\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ValidateStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateStr (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check length of string {\i max}  is the max allowed string length, excluding term '\\0' \par
\par
\par
}
{\xe \v SYSP_ValidateTcal\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ValidateTcal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateTcal (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check revision number \par
\par
\par
}
{\xe \v SYSP_ValidateX\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_ValidateX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidateX (const char * {\i src}, int {\i max})}
}\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check hexadecimal unsigned integers If {\i max}  is 0, no range checking is done \par
\par
\par
}
{\xe \v SYSP_Vc01CarrierProbe\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_Vc01CarrierProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_Vc01CarrierProbe ({\b SYSP_SUPER} * {\i super}, char * {\i sectionName}, char * {\i prefix}, int {\i smbBusNo}, u_int32 {\i devAddr}, u_int32 {\i devSize})}
}\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_VxGrpCreate\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_VxGrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_VxGrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, int {\i nvsOffset}, int {\i nvsSize}, char * {\i vxBline}, const char * {\i vxDefBline}, int {\i provideKerpar})}
}\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create a parameter group object for VxWorks bootline parameters. \par
On success, the parameter group is added to the list of {\i nvs}  groups\par
If the passed {\i vxBline}  is an empty string, the vxBline is read from the non volatile storage. If there is a physical read error, or if it contains non-printable chars, default bootline is setup.\par
If the passed {\i vxBline}  is not-empty, it is checked for non-printable chars, and defaults are applied if so.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i nvsOffset} {\b IN}  starting byte offset of vxbline within NV storage \par
{\i nvsSize} {\b IN}  size of vxbline in NV storage in bytes \par
{\i vxBline} {\b IN}  the vxworks boot line in memory \par
{\i vxDefBline} {\b IN}  VxWorks boot line with defaults, if NULL, an empty bootline will be the default \par
{\i provideKerpar} {\b IN}  if SYSP_PROVIDE_KERPAR, let "kerpar" be an alias to "s"\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v SYSP_super\:sysp_intern.h}
{\xe \v sysp_intern.h\:SYSP_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_SUPER}* {\b SYSP_super} ()}
}\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
the only global variable. \par
Pointer to super object \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_mm_netif.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Special fake NVS section/parameter group that provides the nmacX and nspeedX parameters of network interfaces that store those values into their own SROM.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_PGRP_NETIF}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_MM_NETIF_NUM_PARAM}\~ 2\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b NmacName} ({\b SYSP_PGRP_NETIF} *netifGrp, char *buf)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b NspeedName} ({\b SYSP_PGRP_NETIF} *netifGrp, char *buf)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NetifGrpNumParams} ({\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get num parameters in mpgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NetifGrpEnumParams} ({\b SYSP_PAR_GRP} *parGrp, int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Enum netifgrp params. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NetifGrpSetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set netifgrp parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NetifGrpGetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get netifgrp parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NetifGrpSetDefaults} ({\b SYSP_PAR_GRP} *parGrp, int force)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set netifgrp to defaults. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NetifGrpSave} ({\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Save netifgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NetifGrpCreate} ({\b SYSP_NV_STORAGE} *nvs, NETIF *netif, int netifNum)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create a parameter group object for NETIF parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FakeReadNvs} ({\b SYSP_NV_STORAGE} *nvs, int offset, int size, u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Fake NVS read routine (NOP). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FakeWriteNvs} ({\b SYSP_NV_STORAGE} *nvs, int offset, int size, const u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Fake NVS write routine (NOP). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_MmNetIfParamsCreate} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create object to handle all fake NETIF parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MmNetIfParamsScan} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Scan list of network interfaces and create parameter groups for them. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_nvsName} [] = "mmnetif"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Special fake NVS section/parameter group that provides the nmacX and nspeedX parameters of network interfaces that store those values into their own SROM. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2005/06/23 15:54:46 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.5 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}\par
Query NETIF subsystem for known devices that provide their own EEPROM\par
If any NETIF device found, create a NVS_OBJECT that handles ALL those devices.\par
For each device, create one parameter group\par
{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v SYSP_MM_NETIF_NUM_PARAM\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:SYSP_MM_NETIF_NUM_PARAM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_MM_NETIF_NUM_PARAM\~ 2}
}\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v FakeReadNvs\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:FakeReadNvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FakeReadNvs ({\b SYSP_NV_STORAGE} * {\i nvs}, int {\i offset}, int {\i size}, u_int8 * {\i data}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Fake NVS read routine (NOP). \par
\par
\par
}
{\xe \v FakeWriteNvs\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:FakeWriteNvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int FakeWriteNvs ({\b SYSP_NV_STORAGE} * {\i nvs}, int {\i offset}, int {\i size}, const u_int8 * {\i data}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Fake NVS write routine (NOP). \par
\par
\par
}
{\xe \v NmacName\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:NmacName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* NmacName ({\b SYSP_PGRP_NETIF} * {\i netifGrp}, char * {\i buf}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v NspeedName\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:NspeedName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* NspeedName ({\b SYSP_PGRP_NETIF} * {\i netifGrp}, char * {\i buf}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MmNetIfParamsCreate\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:SYSP_MmNetIfParamsCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_MmNetIfParamsCreate ({\b SYSP_SUPER} * {\i super})}
}\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create object to handle all fake NETIF parameters. \par
Should be called{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
from CPU specific probe routine (to ensure parameters exist after a restart) \par
}
\par
\par
}
{\xe \v SYSP_MmNetIfParamsScan\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:SYSP_MmNetIfParamsScan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MmNetIfParamsScan (void)}
}\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Scan list of network interfaces and create parameter groups for them. \par
Should be called after all interfaces have been defined/attached in MMBIOS \par
\par
}
{\xe \v SYSP_NetifGrpCreate\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:SYSP_NetifGrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NetifGrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, NETIF * {\i netif}, int {\i netifNum})}
}\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create a parameter group object for NETIF parameters. \par
On success, the parameter group is added to the list of {\i nvs}  groups\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_NetifGrpEnumParams\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:SYSP_NetifGrpEnumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NetifGrpEnumParams ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i idx}, int {\i alias}, {\b SYSPARAM_PARAM_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enum netifgrp params. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::enumParams} \par
}\par
\par
}
{\xe \v SYSP_NetifGrpGetParam\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:SYSP_NetifGrpGetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NetifGrpGetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get netifgrp parameter. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::getParam} \par
}\par
\par
}
{\xe \v SYSP_NetifGrpNumParams\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:SYSP_NetifGrpNumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NetifGrpNumParams ({\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get num parameters in mpgrp. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::numParams} \par
}\par
\par
}
{\xe \v SYSP_NetifGrpSave\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:SYSP_NetifGrpSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NetifGrpSave ({\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Save netifgrp. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::save} \par
}\par
\par
}
{\xe \v SYSP_NetifGrpSetDefaults\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:SYSP_NetifGrpSetDefaults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NetifGrpSetDefaults ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i force})}
}\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set netifgrp to defaults. \par
NOTE: THIS WILL NOT CHANGE MAC ADDRESS\par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setDefaults} \par
}\par
\par
}
{\xe \v SYSP_NetifGrpSetParam\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:SYSP_NetifGrpSetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NetifGrpSetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd}, int {\i attr})}
}\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set netifgrp parameter. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setParam} \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_nvsName\:sysp_mm_netif.c}
{\xe \v sysp_mm_netif.c\:G_nvsName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_nvsName}[] = "mmnetif"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_mmpara.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_mmpara.c}
{\xe \v sysp_mmpara.c}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Parameter group handler for MENMON detected parameters.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_PGRP_MMPARA}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_TUS_PARAM_INFO}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_MMPAR_CREATE_MAX_VAL_LEN}\~ 512\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i max. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MmGrpNumParams} ({\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get num parameters in mpgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MmgrpEnumParams} ({\b SYSP_PAR_GRP} *parGrp, int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Enum mmgrp params. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MmgrpSetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set mmgrp parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MmgrpGetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get mmgrp parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MmgrpCreate} ({\b SYSP_NV_STORAGE} *nvs, const char *name, const {\b SYSP_CONST_STRING} *parList, int bufSize, const char *mmParaStr, int mmParaStrMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create a parameter group object for Menmon parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MmParaStringBuildGroup} (char *mmParaStr, int mmParaStrMaxLen, {\b SYSP_PAR_GRP} *parGrp, char *parVal)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Helper function for SYSP_MmParaStringBuild. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MmParaStringBuild} (char *mmParaStr, int mmParaStrMaxLen, {\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Build MENMON parameter string. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_TusParamInfo} (const char *tus, int tusMaxLen, const char *parName, {\b SYSP_TUS_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Locate parameter {\i parName}  in tuple string {\i tus} . }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_TusParamGet} (const char *tus, int tusMaxLen, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get value of parameter {\i parName}  from tuple string. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b TusParamDel} (char *tus, const {\b SYSP_TUS_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Delete parameter tuple from tuple string. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b TusParamValidate} (const char *parVal)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if TUS parameter value is ok. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_TusParamSet} (char *tus, int tusMaxLen, const char *parName, const char *parVal)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set value of parameter {\i parName}  in tuple string. }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Parameter group handler for MENMON detected parameters. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2007/03/07 11:54:31 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.9 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}This file has the following function groups:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Handler for MMPARA parameter group\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Functions for tuple strings (such as Menmon parameter string)\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Function to rebuild MENMON parameter string\par
}
\par
{\b MMPARA}  group:\par
All parameters are read only for user. Firmware can update parameters at any time.\par
Parameters are non-persistant and cannot be set to defaults.\par
{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v SYSP_MMPAR_CREATE_MAX_VAL_LEN\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:SYSP_MMPAR_CREATE_MAX_VAL_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_MMPAR_CREATE_MAX_VAL_LEN\~ 512}
}\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
max. \par
length of each parameter value in mmParaStr passed to SYSP_MmgrpCreate \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MmParaStringBuildGroup\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:MmParaStringBuildGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MmParaStringBuildGroup (char * {\i mmParaStr}, int {\i mmParaStrMaxLen}, {\b SYSP_PAR_GRP} * {\i parGrp}, char * {\i parVal}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Helper function for SYSP_MmParaStringBuild. \par
\par
\par
}
{\xe \v SYSP_MmgrpCreate\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:SYSP_MmgrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MmgrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, const {\b SYSP_CONST_STRING} * {\i parList}, int {\i bufSize}, const char * {\i mmParaStr}, int {\i mmParaStrMaxLen})}
}\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create a parameter group object for Menmon parameters. \par
Extracts all parameters present in {\i parList}  from the passed {\i mmParaStr}  \par
On success, the parameter group is added to the list of {\i nvs}  groups\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i parList} {\b IN}  array of parameters in this section (NULL term.) array and pointers must be kept intact! \par
{\i bufSize} {\b IN}  max. size of name=value buffer string (for all params) \par
{\i mmParaStr} {\b IN}  the current full MENMON parameter string \par
{\i mmParaStrMaxLen} {\b IN}  max length that mmParaStr can hold (incl. '\\0')\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid created mmGrp object (or NULL if failed) \par
}\par
\par
}
{\xe \v SYSP_MmgrpEnumParams\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:SYSP_MmgrpEnumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MmgrpEnumParams ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i idx}, int {\i alias}, {\b SYSPARAM_PARAM_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enum mmgrp params. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::enumParams} \par
}\par
\par
}
{\xe \v SYSP_MmgrpGetParam\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:SYSP_MmgrpGetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MmgrpGetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get mmgrp parameter. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::getParam} \par
}\par
\par
}
{\xe \v SYSP_MmGrpNumParams\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:SYSP_MmGrpNumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MmGrpNumParams ({\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get num parameters in mpgrp. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::numParams} \par
}\par
\par
}
{\xe \v SYSP_MmgrpSetParam\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:SYSP_MmgrpSetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MmgrpSetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd}, int {\i attr})}
}\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set mmgrp parameter. \par
Is only allowed when a SYSPARAM_SA_FROM_FIRMWARE is specified\par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setParam} \par
}\par
\par
}
{\xe \v SYSP_MmParaStringBuild\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:SYSP_MmParaStringBuild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MmParaStringBuild (char * {\i mmParaStr}, int {\i mmParaStrMaxLen}, {\b SYSP_SUPER} * {\i super})}
}\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Build MENMON parameter string. \par
Builds a tuple string from all parameters in all groups of all NV storage objects, whose attributes report that they want to be included in MM parameter string, and builds a tuple string into {\i mmParaStr} .\par
The official parameter names with prefix will be written to MM para string\par
If a parameter tuple doesn't fit as a whole into {\i mmParaStr} , the tuple is omitted and the function returns SYSPARAM_NO_RESOURCE.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i mmParaStr} {\b OUT}  receives the created MM parameter string \par
{\i mmParaStrMaxLen} {\b IN}  max length of {\i mmParaStr}  (incl. term. 0) \par
{\i super} {\b IN}  SYSPARAM super object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code \par
}\par
\par
}
{\xe \v SYSP_TusParamGet\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:SYSP_TusParamGet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_TusParamGet (const char * {\i tus}, int {\i tusMaxLen}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get value of parameter {\i parName}  from tuple string. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i tus} {\b IN}  tuple parameter string \par
{\i tusMaxLen} {\b IN}  max length of tuple string (incl. term. 0) \par
{\i parName} {\b IN}  parameter name to search for \par
{\i parVal} {\b OUT}  receives parameter value as a string \par
{\i parValMaxLen} {\b IN}  max length of parVal (including terminating 0)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 if parameter found, or \par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_INVAL_PARAM - if parameter not found\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_INVAL_VALUE - parVal not NULL and parValMaxLen==0\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_VAL_TRUNCATED - if parVal too small \par
}
\par
}\par
\par
}
{\xe \v SYSP_TusParamInfo\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:SYSP_TusParamInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_TusParamInfo (const char * {\i tus}, int {\i tusMaxLen}, const char * {\i parName}, {\b SYSP_TUS_PARAM_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Locate parameter {\i parName}  in tuple string {\i tus} . \par
Fill {\i info}  structure with information.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i tus} {\b IN}  tuple parameter string \par
{\i tusMaxLen} {\b IN}  max length of string (incl. term. 0) \par
{\i parName} {\b IN}  parameter name to search for \par
{\i info} {\b OUT}  filled with info (invalid if return code is not 0)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 if parameter found, or SYSPARAM_INVAL_PARAM \par
}\par
\par
}
{\xe \v SYSP_TusParamSet\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:SYSP_TusParamSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_TusParamSet (char * {\i tus}, int {\i tusMaxLen}, const char * {\i parName}, const char * {\i parVal})}
}\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set value of parameter {\i parName}  in tuple string. \par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If {\i parName}  doesn't exist in tuple string, it is created\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If {\i parVal}  is NULL or an empty string, {\i parName}  is deleted from tuple string\par
}
\par
Before the value is modified, it is checked wether it would fit in the tuple string. If it would not fit, no modification is done and {\b SYSPARAM_VAL_TRUNCATED} is returned.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i tus} {\b IN}  tuple parameter string \par
{\i tusMaxLen} {\b IN}  max length of tuple string (incl. term. 0) \par
{\i parName} {\b IN}  parameter name to search for \par
{\i parVal} {\b IN}  new parameter value (can be NULL or empty string)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 if parameter found, or \par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_NO_RESOURCE - new value doesn't fit into {\i tus}  \par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_INVAL_VALUE - invalid characters in {\i parVal}  \par
}
\par
}\par
\par
}
{\xe \v TusParamDel\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:TusParamDel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TusParamDel (char * {\i tus}, const {\b SYSP_TUS_PARAM_INFO} * {\i info}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Delete parameter tuple from tuple string. \par
\par
\par
}
{\xe \v TusParamValidate\:sysp_mmpara.c}
{\xe \v sysp_mmpara.c\:TusParamValidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TusParamValidate (const char * {\i parVal}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if TUS parameter value is ok. \par
\par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_mpgrp.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Handler for parameter groups using magic/parity.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int8 {\b CalcParity} (u_int8 *ptr, u_int32 len)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Compute the 4-bit parity over a number of bytes. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b HasValidMp} ({\b SYSP_PGRP_MAGPAR} *mpGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if raw data of mpgrp has valid magic/parity. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UpdateMp} ({\b SYSP_PGRP_MAGPAR} *mpGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Update magic/parity of mpgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ProdPasswdOk} (const char *pw)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if {\i pw}  is the correct password for production data. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpNumParams} ({\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get num parameters in mpgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpEnumParams} ({\b SYSP_PAR_GRP} *parGrp, int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Enum mpgrp params. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set mpgrp parameter (for non-production data groups). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSetParamProd} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set mpgrp parameter (for production data groups). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpGetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get mpgrp parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpGetParamDefault} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get mpgrp parameter's default. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSetDefaults} ({\b SYSP_PAR_GRP} *parGrp, int force)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set mpgrp to defaults (for non-production data groups). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSetDefaultsProd} ({\b SYSP_PAR_GRP} *parGrp, int force)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set mpgrp to defaults (for production data groups). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSetDefaultsDoNotUpdateEeprom} ({\b SYSP_PAR_GRP} *parGrp, int force)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set mpgrp to defaults (for production data groups). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSave} ({\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Save mpgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PGRP_MAGPAR} * {\b SYSP_MpGrpCreate} ({\b SYSP_NV_STORAGE} *nvs, const char *name, int nvsOffset, int nvsSize, const {\b SYSP_PAR_DESC} *parList, u_int8 magic)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create a parameter group object for NVS section that uses magic/XOR parity. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpCreateStd} ({\b SYSP_NV_STORAGE} *nvs, const char *name, int nvsOffset, int nvsSize, const {\b SYSP_PAR_DESC} *parList, u_int8 magic, {\b SYSP_PGRP_MAGPAR} **mpGrpP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create and read magic/parity parameter for non-production data section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpCreateStdRo} ({\b SYSP_NV_STORAGE} *nvs, const char *name, int nvsOffset, int nvsSize, const {\b SYSP_PAR_DESC} *parList, u_int8 magic, {\b SYSP_PGRP_MAGPAR} **mpGrpP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i same as SYSP_MpGrpCreateStd but group read only }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpCreateProd} ({\b SYSP_NV_STORAGE} *nvs, const char *name, int nvsOffset, int nvsSize, const {\b SYSP_PAR_DESC} *parList, u_int8 magic, {\b SYSP_PGRP_MAGPAR} **mpGrpP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create and read magic/parity parameter for production data section. }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Handler for parameter groups using magic/parity. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2010/07/27 17:21:01 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.13 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v CalcParity\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:CalcParity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int8 CalcParity (u_int8 * {\i ptr}, u_int32 {\i len}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Compute the 4-bit parity over a number of bytes. \par
\par
\par
}
{\xe \v HasValidMp\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:HasValidMp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int HasValidMp ({\b SYSP_PGRP_MAGPAR} * {\i mpGrp}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if raw data of mpgrp has valid magic/parity. \par
\par
\par
}
{\xe \v SYSP_MpGrpCreate\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_PGRP_MAGPAR}* SYSP_MpGrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, int {\i nvsOffset}, int {\i nvsSize}, const {\b SYSP_PAR_DESC} * {\i parList}, u_int8 {\i magic})}
}\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create a parameter group object for NVS section that uses magic/XOR parity. \par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Creates and initializes a {\b SYSP_PGRP_MAGPAR} object.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets all method pointers to defaults\par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i nvsOffset} {\b IN}  starting byte offset of section within NV storage \par
{\i nvsSize} {\b IN}  size of section in bytes \par
{\i parList} {\b IN}  array of parameters in this section \par
{\i magic} {\b IN}  magic ID of section\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid created mpGrp object (or NULL if failed) \par
}\par
\par
}
{\xe \v SYSP_MpGrpCreateProd\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpCreateProd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpCreateProd ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, int {\i nvsOffset}, int {\i nvsSize}, const {\b SYSP_PAR_DESC} * {\i parList}, u_int8 {\i magic}, {\b SYSP_PGRP_MAGPAR} ** {\i mpGrpP})}
}\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create and read magic/parity parameter for production data section. \par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Creates and initializes a {\b SYSP_PGRP_MAGPAR} object.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets all method pointers to defaults\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
reads NV storage\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
checks magic parity\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets defaults if either NV storage read failed or magic/parity bad (defaults are all FF's).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The group must be added to NVS group list by caller!\par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i nvsOffset} {\b IN}  starting byte offset of section within NV storage \par
{\i nvsSize} {\b IN}  size of section in bytes \par
{\i parList} {\b IN}  array of parameters in this section. Default values in parList are ignored! \par
{\i magic} {\b IN}  magic ID of section \par
{\i mpGrpP} {\b OUT}  receives created group object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_EEPROM_ERROR: NVS read failed (mpGrp created)\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_INVAL_VALUE: bad magic/parity (mpGrp created) \par
}
\par
}\par
\par
}
{\xe \v SYSP_MpGrpCreateStd\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpCreateStd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpCreateStd ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, int {\i nvsOffset}, int {\i nvsSize}, const {\b SYSP_PAR_DESC} * {\i parList}, u_int8 {\i magic}, {\b SYSP_PGRP_MAGPAR} ** {\i mpGrpP})}
}\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create and read magic/parity parameter for non-production data section. \par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Creates and initializes a {\b SYSP_PGRP_MAGPAR} object.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets all method pointers to defaults\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
reads NV storage\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
checks magic parity\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets defaults if either NV storage read failed or magic/parity bad\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Adds group to NVS group list\par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i nvsOffset} {\b IN}  starting byte offset of section within NV storage \par
{\i nvsSize} {\b IN}  size of section in bytes \par
{\i parList} {\b IN}  array of parameters in this section \par
{\i magic} {\b IN}  magic ID of section \par
{\i mpGrpP} {\b OUT}  receives created group object (if non NULL)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
 Any value != 0 means that the group has not been created \par
}\par
\par
}
{\xe \v SYSP_MpGrpCreateStdRo\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpCreateStdRo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpCreateStdRo ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, int {\i nvsOffset}, int {\i nvsSize}, const {\b SYSP_PAR_DESC} * {\i parList}, u_int8 {\i magic}, {\b SYSP_PGRP_MAGPAR} ** {\i mpGrpP})}
}\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
same as SYSP_MpGrpCreateStd but group read only \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i nvsOffset} {\b IN}  starting byte offset of section within NV storage \par
{\i nvsSize} {\b IN}  size of section in bytes \par
{\i parList} {\b IN}  array of parameters in this section \par
{\i magic} {\b IN}  magic ID of section \par
{\i mpGrpP} {\b OUT}  receives created group object (if non NULL)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
 Any value != 0 means that the group has not been created \par
}\par
\par
}
{\xe \v SYSP_MpGrpEnumParams\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpEnumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpEnumParams ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i idx}, int {\i alias}, {\b SYSPARAM_PARAM_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enum mpgrp params. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::enumParams} \par
}\par
\par
}
{\xe \v SYSP_MpGrpGetParam\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpGetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpGetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get mpgrp parameter. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::getParam} \par
}\par
\par
}
{\xe \v SYSP_MpGrpGetParamDefault\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpGetParamDefault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpGetParamDefault ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get mpgrp parameter's default. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::getParam} \par
}\par
\par
}
{\xe \v SYSP_MpGrpNumParams\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpNumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpNumParams ({\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get num parameters in mpgrp. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::numParams} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSave\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSave ({\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Save mpgrp. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::save} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSetDefaults\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpSetDefaults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSetDefaults ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i force})}
}\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set mpgrp to defaults (for non-production data groups). \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setDefaults} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSetDefaultsDoNotUpdateEeprom\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpSetDefaultsDoNotUpdateEeprom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSetDefaultsDoNotUpdateEeprom ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i force})}
}\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set mpgrp to defaults (for production data groups). \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setDefaults} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSetDefaultsProd\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpSetDefaultsProd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSetDefaultsProd ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i force})}
}\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set mpgrp to defaults (for production data groups). \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setDefaults} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSetParam\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpSetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd}, int {\i attr})}
}\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set mpgrp parameter (for non-production data groups). \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setParam} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSetParamProd\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_MpGrpSetParamProd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSetParamProd ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd}, int {\i attr})}
}\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set mpgrp parameter (for production data groups). \par
Additionally checks {\i passwd} . If the {\i hwName}  (parName=='brd') of the board is changed, return {\b SYSP_INTERNAL_RESTART} to force a restart of the entire SYSPARAM lib.\par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setParam} \par
}\par
\par
}
{\xe \v SYSP_ProdPasswdOk\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:SYSP_ProdPasswdOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ProdPasswdOk (const char * {\i pw})}
}\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if {\i pw}  is the correct password for production data. \par
\par
\par
}
{\xe \v UpdateMp\:sysp_mpgrp.c}
{\xe \v sysp_mpgrp.c\:UpdateMp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UpdateMp ({\b SYSP_PGRP_MAGPAR} * {\i mpGrp}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Update magic/parity of mpgrp. \par
\par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_mpgrp.work.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int8 {\b CalcParity} (u_int8 *ptr, u_int32 len)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Compute the 4-bit parity over a number of bytes. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b HasValidMp} ({\b SYSP_PGRP_MAGPAR} *mpGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if raw data of mpgrp has valid magic/parity. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UpdateMp} ({\b SYSP_PGRP_MAGPAR} *mpGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Update magic/parity of mpgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ProdPasswdOk} (const char *pw)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if {\i pw}  is the correct password for production data. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpNumParams} ({\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get num parameters in mpgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpEnumParams} ({\b SYSP_PAR_GRP} *parGrp, int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Enum mpgrp params. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set mpgrp parameter (for non-production data groups). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSetParamProd} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set mpgrp parameter (for production data groups). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpGetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get mpgrp parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpGetParamDefault} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get mpgrp parameter's default. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSetDefaults} ({\b SYSP_PAR_GRP} *parGrp, int force)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set mpgrp to defaults (for non-production data groups). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSetDefaultsProd} ({\b SYSP_PAR_GRP} *parGrp, int force)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set mpgrp to defaults (for production data groups). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSetDefaultsDoNotUpdateEeprom} ({\b SYSP_PAR_GRP} *parGrp, int force)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set mpgrp to defaults (for production data groups). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpSave} ({\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Save mpgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PGRP_MAGPAR} * {\b SYSP_MpGrpCreate} ({\b SYSP_NV_STORAGE} *nvs, const char *name, int nvsOffset, int nvsSize, const {\b SYSP_PAR_DESC} *parList, u_int8 magic)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create a parameter group object for NVS section that uses magic/XOR parity. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpCreateStd} ({\b SYSP_NV_STORAGE} *nvs, const char *name, int nvsOffset, int nvsSize, const {\b SYSP_PAR_DESC} *parList, u_int8 magic, {\b SYSP_PGRP_MAGPAR} **mpGrpP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create and read magic/parity parameter for non-production data section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpCreateStdRo} ({\b SYSP_NV_STORAGE} *nvs, const char *name, int nvsOffset, int nvsSize, const {\b SYSP_PAR_DESC} *parList, u_int8 magic, {\b SYSP_PGRP_MAGPAR} **mpGrpP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i same as SYSP_MpGrpCreateStd but group read only }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MpGrpCreateProd} ({\b SYSP_NV_STORAGE} *nvs, const char *name, int nvsOffset, int nvsSize, const {\b SYSP_PAR_DESC} *parList, u_int8 magic, {\b SYSP_PGRP_MAGPAR} **mpGrpP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create and read magic/parity parameter for production data section. }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v CalcParity\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:CalcParity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int8 CalcParity (u_int8 * {\i ptr}, u_int32 {\i len}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Compute the 4-bit parity over a number of bytes. \par
\par
\par
}
{\xe \v HasValidMp\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:HasValidMp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int HasValidMp ({\b SYSP_PGRP_MAGPAR} * {\i mpGrp}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if raw data of mpgrp has valid magic/parity. \par
\par
\par
}
{\xe \v SYSP_MpGrpCreate\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_PGRP_MAGPAR}* SYSP_MpGrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, int {\i nvsOffset}, int {\i nvsSize}, const {\b SYSP_PAR_DESC} * {\i parList}, u_int8 {\i magic})}
}\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create a parameter group object for NVS section that uses magic/XOR parity. \par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Creates and initializes a {\b SYSP_PGRP_MAGPAR} object.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets all method pointers to defaults\par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i nvsOffset} {\b IN}  starting byte offset of section within NV storage \par
{\i nvsSize} {\b IN}  size of section in bytes \par
{\i parList} {\b IN}  array of parameters in this section \par
{\i magic} {\b IN}  magic ID of section\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid created mpGrp object (or NULL if failed) \par
}\par
\par
}
{\xe \v SYSP_MpGrpCreateProd\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpCreateProd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpCreateProd ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, int {\i nvsOffset}, int {\i nvsSize}, const {\b SYSP_PAR_DESC} * {\i parList}, u_int8 {\i magic}, {\b SYSP_PGRP_MAGPAR} ** {\i mpGrpP})}
}\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create and read magic/parity parameter for production data section. \par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Creates and initializes a {\b SYSP_PGRP_MAGPAR} object.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets all method pointers to defaults\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
reads NV storage\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
checks magic parity\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets defaults if either NV storage read failed or magic/parity bad (defaults are all FF's).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The group must be added to NVS group list by caller!\par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i nvsOffset} {\b IN}  starting byte offset of section within NV storage \par
{\i nvsSize} {\b IN}  size of section in bytes \par
{\i parList} {\b IN}  array of parameters in this section. Default values in parList are ignored! \par
{\i magic} {\b IN}  magic ID of section \par
{\i mpGrpP} {\b OUT}  receives created group object\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_EEPROM_ERROR: NVS read failed (mpGrp created)\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_INVAL_VALUE: bad magic/parity (mpGrp created) \par
}
\par
}\par
\par
}
{\xe \v SYSP_MpGrpCreateStd\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpCreateStd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpCreateStd ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, int {\i nvsOffset}, int {\i nvsSize}, const {\b SYSP_PAR_DESC} * {\i parList}, u_int8 {\i magic}, {\b SYSP_PGRP_MAGPAR} ** {\i mpGrpP})}
}\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create and read magic/parity parameter for non-production data section. \par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Creates and initializes a {\b SYSP_PGRP_MAGPAR} object.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets all method pointers to defaults\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
reads NV storage\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
checks magic parity\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
sets defaults if either NV storage read failed or magic/parity bad\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Adds group to NVS group list\par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i nvsOffset} {\b IN}  starting byte offset of section within NV storage \par
{\i nvsSize} {\b IN}  size of section in bytes \par
{\i parList} {\b IN}  array of parameters in this section \par
{\i magic} {\b IN}  magic ID of section \par
{\i mpGrpP} {\b OUT}  receives created group object (if non NULL)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
 Any value != 0 means that the group has not been created \par
}\par
\par
}
{\xe \v SYSP_MpGrpCreateStdRo\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpCreateStdRo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpCreateStdRo ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, int {\i nvsOffset}, int {\i nvsSize}, const {\b SYSP_PAR_DESC} * {\i parList}, u_int8 {\i magic}, {\b SYSP_PGRP_MAGPAR} ** {\i mpGrpP})}
}\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
same as SYSP_MpGrpCreateStd but group read only \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  parameter group name \par
{\i nvsOffset} {\b IN}  starting byte offset of section within NV storage \par
{\i nvsSize} {\b IN}  size of section in bytes \par
{\i parList} {\b IN}  array of parameters in this section \par
{\i magic} {\b IN}  magic ID of section \par
{\i mpGrpP} {\b OUT}  receives created group object (if non NULL)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code\par
 Any value != 0 means that the group has not been created \par
}\par
\par
}
{\xe \v SYSP_MpGrpEnumParams\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpEnumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpEnumParams ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i idx}, int {\i alias}, {\b SYSPARAM_PARAM_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enum mpgrp params. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::enumParams} \par
}\par
\par
}
{\xe \v SYSP_MpGrpGetParam\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpGetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpGetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get mpgrp parameter. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::getParam} \par
}\par
\par
}
{\xe \v SYSP_MpGrpGetParamDefault\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpGetParamDefault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpGetParamDefault ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get mpgrp parameter's default. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::getParam} \par
}\par
\par
}
{\xe \v SYSP_MpGrpNumParams\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpNumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpNumParams ({\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get num parameters in mpgrp. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::numParams} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSave\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSave ({\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Save mpgrp. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::save} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSetDefaults\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpSetDefaults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSetDefaults ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i force})}
}\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set mpgrp to defaults (for non-production data groups). \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setDefaults} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSetDefaultsDoNotUpdateEeprom\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpSetDefaultsDoNotUpdateEeprom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSetDefaultsDoNotUpdateEeprom ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i force})}
}\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set mpgrp to defaults (for production data groups). \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setDefaults} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSetDefaultsProd\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpSetDefaultsProd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSetDefaultsProd ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i force})}
}\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set mpgrp to defaults (for production data groups). \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setDefaults} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSetParam\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpSetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd}, int {\i attr})}
}\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set mpgrp parameter (for non-production data groups). \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setParam} \par
}\par
\par
}
{\xe \v SYSP_MpGrpSetParamProd\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_MpGrpSetParamProd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MpGrpSetParamProd ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd}, int {\i attr})}
}\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set mpgrp parameter (for production data groups). \par
Additionally checks {\i passwd} . If the {\i hwName}  (parName=='brd') of the board is changed, return {\b SYSP_INTERNAL_RESTART} to force a restart of the entire SYSPARAM lib.\par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setParam} \par
}\par
\par
}
{\xe \v SYSP_ProdPasswdOk\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:SYSP_ProdPasswdOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ProdPasswdOk (const char * {\i pw})}
}\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if {\i pw}  is the correct password for production data. \par
\par
\par
}
{\xe \v UpdateMp\:sysp_mpgrp.work.c}
{\xe \v sysp_mpgrp.work.c\:UpdateMp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void UpdateMp ({\b SYSP_PGRP_MAGPAR} * {\i mpGrp}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Update magic/parity of mpgrp. \par
\par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_p504.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_p504.c}
{\xe \v sysp_p504.c}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid P504 board specific part.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_PCIOUT}(_nm, _alias, _offs, _deflt)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i PCI outbound window. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_PCIIN}(_nm, _alias, _offs, _deflt)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i PCI inbound window. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFFX}(x)\~ offsetof(struct menmx_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFFF}(x)\~ offsetof(struct flstr_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsP504CpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for P504 CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawPci} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from PCI outbound/inbound window configuration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawPci} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to PCI outbound/inbound window configuration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidatePciOut} (const char *src, int notused)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check PCI outbound window configuration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidatePciIn} (const char *src, int notused)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check PCI inbound window configuration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b P504Init} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for P504. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b P504SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for P504. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1100]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsHex} [] = "[0-9A-Fa-f]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsDec} [] = "[0-9]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsBool} [] = "[01]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_hwLongDesc} [] = "(1=hardware monitor reset enabled)"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_HELP_DESC} {\b G_descTbl} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Table that describes all statically known board specific parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_HELP_DESC_TBL} {\b G_descTblP504} = \{ NULL, {\b G_descTbl} \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListP504Menm} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in P504 CPU EEPROM, menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListP504MenmX} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in P504 CPU EEPROM, menmon extended section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListP504FlStr} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in P504 boot flash, long string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_CONST_STRING} {\b SYSP_parListP504Mmpara} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in "mmpara" parameter group }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
P504 board specific part. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 Ralf.Truebenbach@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2008/11/04 16:05:13 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.4 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_p504.c}
{\xe \v sysp_p504.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFFF\:sysp_p504.c}
{\xe \v sysp_p504.c\:_EEOFFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFFF(x)\~ offsetof(struct flstr_parms,x)}
}\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFFX\:sysp_p504.c}
{\xe \v sysp_p504.c\:_EEOFFX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFFX(x)\~ offsetof(struct menmx_parms,x)}
}\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_PDE_PCIIN\:sysp_p504.c}
{\xe \v sysp_p504.c\:SYSP_PDE_PCIIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_PCIIN(_nm, _alias, _offs, _deflt)}
}\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawPci, SYSP_FromRawPci, SYSP_ValidatePciIn,\\\par
   _deflt, 0, (SYSP_PD_MMPARASTR*0) \}\par
\par
}
PCI inbound window. \par
\par
}
{\xe \v SYSP_PDE_PCIOUT\:sysp_p504.c}
{\xe \v sysp_p504.c\:SYSP_PDE_PCIOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_PCIOUT(_nm, _alias, _offs, _deflt)}
}\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawPci, SYSP_FromRawPci, SYSP_ValidatePciOut,\\\par
   _deflt, 0, (SYSP_PD_MMPARASTR*0) \}\par
\par
}
PCI outbound window. \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v P504Init\:sysp_p504.c}
{\xe \v sysp_p504.c\:P504Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int P504Init ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for P504. \par
Probes for CPU EEPROM and possible ESM carrier boards {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v P504SysParamInit\:sysp_p504.c}
{\xe \v sysp_p504.c\:P504SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int P504SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for P504. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_FromRawPci\:sysp_p504.c}
{\xe \v sysp_p504.c\:SYSP_FromRawPci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawPci (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from PCI outbound/inbound window configuration \par
\par
\par
}
{\xe \v SYSP_NvsP504CpuProbe\:sysp_p504.c}
{\xe \v sysp_p504.c\:SYSP_NvsP504CpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsP504CpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for P504 CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in P504 CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_ToRawPci\:sysp_p504.c}
{\xe \v sysp_p504.c\:SYSP_ToRawPci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawPci (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to PCI outbound/inbound window configuration \par
\par
\par
}
{\xe \v SYSP_ValidatePciIn\:sysp_p504.c}
{\xe \v sysp_p504.c\:SYSP_ValidatePciIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidatePciIn (const char * {\i src}, int {\i notused})}
}\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check PCI inbound window configuration \par
\par
\par
}
{\xe \v SYSP_ValidatePciOut\:sysp_p504.c}
{\xe \v sysp_p504.c\:SYSP_ValidatePciOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidatePciOut (const char * {\i src}, int {\i notused})}
}\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check PCI outbound window configuration \par
\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_p504.c}
{\xe \v sysp_p504.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1100]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_allowedCharsBool\:sysp_p504.c}
{\xe \v sysp_p504.c\:G_allowedCharsBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsBool}[] = "[01]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_allowedCharsDec\:sysp_p504.c}
{\xe \v sysp_p504.c\:G_allowedCharsDec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsDec}[] = "[0-9]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_allowedCharsHex\:sysp_p504.c}
{\xe \v sysp_p504.c\:G_allowedCharsHex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsHex}[] = "[0-9A-Fa-f]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_descTbl\:sysp_p504.c}
{\xe \v sysp_p504.c\:G_descTbl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_HELP_DESC} {\b G_descTbl}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Table that describes all statically known board specific parameters. \par
\par
\par
}
{\xe \v G_descTblP504\:sysp_p504.c}
{\xe \v sysp_p504.c\:G_descTblP504}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_HELP_DESC_TBL} {\b G_descTblP504} = \{ NULL, {\b G_descTbl} \}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_hwLongDesc\:sysp_p504.c}
{\xe \v sysp_p504.c\:G_hwLongDesc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_hwLongDesc}[] = "(1=hardware monitor reset enabled)"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_super\:sysp_p504.c}
{\xe \v sysp_p504.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_parListP504FlStr\:sysp_p504.c}
{\xe \v sysp_p504.c\:SYSP_parListP504FlStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListP504FlStr}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_STR( SYSP_mmstartup, SYSP_startup, _EEOFFF(fl_startup), "", \par
                  P504_FLASH_STARTUP_LEN, 0 ),\par
    SYSP_PDE_STR( SYSP_kerpar, NULL, _EEOFFF(fl_kerpar), "", \par
                  P504_FLASH_KERPAR_LEN, 0 ),\par
    \par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in P504 boot flash, long string \par
\par
}
{\xe \v SYSP_parListP504Menm\:sysp_p504.c}
{\xe \v sysp_p504.c\:SYSP_parListP504Menm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListP504Menm}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters in P504 CPU EEPROM, menmon section \par
\par
\par
}
{\xe \v SYSP_parListP504MenmX\:sysp_p504.c}
{\xe \v sysp_p504.c\:SYSP_parListP504MenmX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListP504MenmX}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_CON0( _EEOFFX(mmx_con[0]), "8" ),  \par
    SYSP_PDE_CON1( _EEOFFX(mmx_con[1]), "9" ),  \par
    SYSP_PDE_CON2( _EEOFFX(mmx_con[2]), "0" ),  \par
    SYSP_PDE_CON3( _EEOFFX(mmx_con[3]), "0" ),  \par
    SYSP_PDE_GCON( _EEOFFX(mmx_gcon),   "ff"),  \par
    SYSP_PDE_VMODE( _EEOFFX(mmx_vmode) ),\par
    SYSP_PDE_ECL(   _EEOFFX(mmx_ecl) ),\par
    SYSP_PDE_TTO(   _EEOFFX(mmx_tto) ),\par
    SYSP_PDE_TRIES( _EEOFFX(mmx_tries) ),\par
    SYSP_PDE_TDP(   _EEOFFX(mmx_tdp) ),\par
    SYSP_PDE_HDP(   _EEOFFX(mmx_hdp) ),\par
    SYSP_PDE_STWAIT(_EEOFFX(mmx_stwait), "30" ),\par
    SYSP_PDE_WDT(   _EEOFFX(mmx_wdt), "0" ),\par
    SYSP_PDE_BOOL0( "psr1v5",   NULL, _EEOFFX(mmx_hw_monitor), "1", 0 ),\par
    SYSP_PDE_BOOL1( "psr3v3",   NULL, _EEOFFX(mmx_hw_monitor), "1", 0 ),\par
    SYSP_PDE_BOOL2( "psr5v",    NULL, _EEOFFX(mmx_hw_monitor), "1", 0 ),\par
    SYSP_PDE_BOOL3( "psr1v8",   NULL, _EEOFFX(mmx_hw_monitor), "1", 0 ),\par
    SYSP_PDE_BOOL4( "temp_crit",  NULL, _EEOFFX(mmx_hw_monitor), "1", 0 ),\par
    SYSP_PDE_BOOL5( "temp_low",   NULL, _EEOFFX(mmx_hw_monitor), "0", 0 ),\par
    SYSP_PDE_PCIOUT( "pci_out_0", NULL, _EEOFFX(mmx_pci_out[0]),  "80000000,80000000,10000000" ),\par
    SYSP_PDE_PCIOUT( "pci_out_1", NULL, _EEOFFX(mmx_pci_out[6]),  "90000000,90000000,10000000" ),\par
    SYSP_PDE_PCIOUT( "pci_out_2", NULL, _EEOFFX(mmx_pci_out[12]), "00000000,00000000,00000000" ),\par
    SYSP_PDE_PCIIN( "pci_in_0",  NULL, _EEOFFX(mmx_pci_in[0]),   "02000000,00000000,02000000" ),\par
    SYSP_PDE_PCIIN( "pci_in_1",  NULL, _EEOFFX(mmx_pci_in[6]),   "02000000,00000000,00400000" ),\par
        \par
    \par
    \par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in P504 CPU EEPROM, menmon extended section \par
\par
}
{\xe \v SYSP_parListP504Mmpara\:sysp_p504.c}
{\xe \v sysp_p504.c\:SYSP_parListP504Mmpara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_CONST_STRING} {\b SYSP_parListP504Mmpara}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_mem0,\par
    SYSP_mem1,\par
    SYSP_flash0,\par
    SYSP_cpu,\par
    SYSP_cpuclkhz,\par
    SYSP_memclkhz,\par
    SYSP_pciclkhz,\par
    SYSP_clun,\par
    SYSP_dlun,\par
    SYSP_rststat,   \par
    SYSP_mmst,\par
    SYSP_mm,\par
    SYSP_cons,\par
    SYSP_nmac0, \par
    SYSP_nmac1, \par
    NULL\par
\}\par
\par
}
list of parameters in "mmpara" parameter group \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_paramhelp.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Provide help text for commonly used parameters.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _ISDIGIT}(c)\~ ((c)>='0' && (c)<='9')\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_AddParamTable} ({\b SYSP_HELP_DESC_TBL} *newTable)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Add a table for board specific parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_HELP_DESC} * {\b FindDescEntry} (const char *parName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Find entry in desc table according to {\i parName} . }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamHelp} (const char *parName, {\b SYSPARAM_PARAM_HELP} *parHelp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get help strings for standard parameter. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsIp} [] = "[0-9.]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsHex} [] = "[0-9A-Fa-f]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsDec} [] = "[0-9]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsBool} [] = "[01]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_wdtLongDesc1} [] = "in 1/10s, 0=disable watchdog"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_HELP_DESC} {\b G_descTbl} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Table that describes all statically known parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_HELP_DESC_TBL} {\b G_descTblStandard} = \{ NULL, {\b G_descTbl} \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Provide help text for commonly used parameters. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2007/07/11 10:57:28 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.11 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _ISDIGIT\:sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c\:_ISDIGIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _ISDIGIT(c)\~ ((c)>='0' && (c)<='9')}
}\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v FindDescEntry\:sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c\:FindDescEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_HELP_DESC}* FindDescEntry (const char * {\i parName}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Find entry in desc table according to {\i parName} . \par
If {\i parName}  ends with a digit, it matches any entry that similar entries (e.g. parName=nspeed2 matches entry nspeed0), however this works only with official, not alias names.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name to search for \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid entry in desc table or NULL if not found \par
}\par
\par
}
{\xe \v SYSP_AddParamTable\:sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c\:SYSP_AddParamTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_AddParamTable ({\b SYSP_HELP_DESC_TBL} * {\i newTable})}
}\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Add a table for board specific parameters. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i newTable} {\b IN}  table to add \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
 \par
}\par
\par
}
{\xe \v SysParamHelp\:sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c\:SysParamHelp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamHelp (const char * {\i parName}, {\b SYSPARAM_PARAM_HELP} * {\i parHelp})}
}\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get help strings for standard parameter. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i parHelp} {\b OUT}  filled with info about parameter name\par
}
On error, all fields of {\i parHelp}  are filled with zeroes\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: parameter is not known \par
}
\par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_allowedCharsBool\:sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c\:G_allowedCharsBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsBool}[] = "[01]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_allowedCharsDec\:sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c\:G_allowedCharsDec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsDec}[] = "[0-9]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_allowedCharsHex\:sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c\:G_allowedCharsHex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsHex}[] = "[0-9A-Fa-f]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_allowedCharsIp\:sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c\:G_allowedCharsIp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsIp}[] = "[0-9.]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_descTbl\:sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c\:G_descTbl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_HELP_DESC} {\b G_descTbl}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Table that describes all statically known parameters. \par
\par
\par
}
{\xe \v G_descTblStandard\:sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c\:G_descTblStandard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_HELP_DESC_TBL} {\b G_descTblStandard} = \{ NULL, {\b G_descTbl} \}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_wdtLongDesc1\:sysp_paramhelp.c}
{\xe \v sysp_paramhelp.c\:G_wdtLongDesc1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_wdtLongDesc1}[] = "in 1/10s, 0=disable watchdog"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_sc15a.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_sc15a.c}
{\xe \v sysp_sc15a.c}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid SC15A board specific part (cloned from {\b sysp_p504.c} V2.3).  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_PCIOUT}(_nm, _alias, _offs, _deflt)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i PCI outbound window. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_PCIIN}(_nm, _alias, _offs, _deflt)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i PCI inbound window. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFFX}(x)\~ offsetof(struct menmx_parms,x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFFF}(x)\~ offsetof(struct flstr_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsSc15aCpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for SC15A CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawPci} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from PCI outbound/inbound window configuration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawPci} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to PCI outbound/inbound window configuration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidatePciOut} (const char *src, int notused)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check PCI outbound window configuration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ValidatePciIn} (const char *src, int notused)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i check PCI inbound window configuration }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Sc15aInit} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for SC15A. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Sc15aSysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for SC15A. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1100]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsHex} [] = "[0-9A-Fa-f]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsDec} [] = "[0-9]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_allowedCharsBool} [] = "[01]"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b G_hwLongDesc} [] = "(1=hardware monitor reset enabled)"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_HELP_DESC} {\b G_descTbl} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Table that describes all statically known board specific parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_HELP_DESC_TBL} {\b G_descTblSc15a} = \{ NULL, {\b G_descTbl} \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListSc15aMenm} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in SC15A CPU EEPROM, menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListSc15aMenmX} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in SC15A CPU EEPROM, menmon extended section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListSc15aFlStr} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in SC15A boot flash, long string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_CONST_STRING} {\b SYSP_parListSc15aMmpara} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in "mmpara" parameter group }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
SC15A board specific part (cloned from {\b sysp_p504.c} V2.3). \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid rt {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2008/11/04 16:05:16 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.3 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}\par
{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFFF\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:_EEOFFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFFF(x)\~ offsetof(struct flstr_parms,x)}
}\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v _EEOFFX\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:_EEOFFX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFFX(x)\~ offsetof(struct menmx_parms,x)}
}\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_PDE_PCIIN\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:SYSP_PDE_PCIIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_PCIIN(_nm, _alias, _offs, _deflt)}
}\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawPci, SYSP_FromRawPci, SYSP_ValidatePciIn,\\\par
   _deflt, 0, (SYSP_PD_MMPARASTR*0) \}\par
\par
}
PCI inbound window. \par
\par
}
{\xe \v SYSP_PDE_PCIOUT\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:SYSP_PDE_PCIOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_PCIOUT(_nm, _alias, _offs, _deflt)}
}\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawPci, SYSP_FromRawPci, SYSP_ValidatePciOut,\\\par
   _deflt, 0, (SYSP_PD_MMPARASTR*0) \}\par
\par
}
PCI outbound window. \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v Sc15aInit\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:Sc15aInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Sc15aInit ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for SC15A. \par
Probes for CPU EEPROM and possible ESM carrier boards {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Sc15aSysParamInit\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:Sc15aSysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Sc15aSysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for SC15A. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_FromRawPci\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:SYSP_FromRawPci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawPci (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from PCI outbound/inbound window configuration \par
\par
\par
}
{\xe \v SYSP_NvsSc15aCpuProbe\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:SYSP_NvsSc15aCpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsSc15aCpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for SC15A CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in SC15A CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_ToRawPci\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:SYSP_ToRawPci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawPci (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to PCI outbound/inbound window configuration \par
\par
\par
}
{\xe \v SYSP_ValidatePciIn\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:SYSP_ValidatePciIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidatePciIn (const char * {\i src}, int {\i notused})}
}\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check PCI inbound window configuration \par
\par
\par
}
{\xe \v SYSP_ValidatePciOut\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:SYSP_ValidatePciOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ValidatePciOut (const char * {\i src}, int {\i notused})}
}\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
check PCI outbound window configuration \par
\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1100]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_allowedCharsBool\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:G_allowedCharsBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsBool}[] = "[01]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_allowedCharsDec\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:G_allowedCharsDec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsDec}[] = "[0-9]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_allowedCharsHex\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:G_allowedCharsHex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_allowedCharsHex}[] = "[0-9A-Fa-f]"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_descTbl\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:G_descTbl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_HELP_DESC} {\b G_descTbl}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Table that describes all statically known board specific parameters. \par
\par
\par
}
{\xe \v G_descTblSc15a\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:G_descTblSc15a}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_HELP_DESC_TBL} {\b G_descTblSc15a} = \{ NULL, {\b G_descTbl} \}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_hwLongDesc\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:G_hwLongDesc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b G_hwLongDesc}[] = "(1=hardware monitor reset enabled)"{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v G_super\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_parListSc15aFlStr\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:SYSP_parListSc15aFlStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListSc15aFlStr}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_STR( SYSP_mmstartup, SYSP_startup, _EEOFFF(fl_startup), "", \par
                  SC15A_FLASH_STARTUP_LEN, 0 ),\par
    SYSP_PDE_STR( SYSP_kerpar, NULL, _EEOFFF(fl_kerpar), "", \par
                  SC15A_FLASH_KERPAR_LEN, 0 ),\par
    \par
    SYSP_PDE_END\par
\}\par
\par
}
list of parameters in SC15A boot flash, long string \par
\par
}
{\xe \v SYSP_parListSc15aMenm\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:SYSP_parListSc15aMenm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListSc15aMenm}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters in SC15A CPU EEPROM, menmon section \par
\par
\par
}
{\xe \v SYSP_parListSc15aMenmX\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:SYSP_parListSc15aMenmX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListSc15aMenmX}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters in SC15A CPU EEPROM, menmon extended section \par
\par
\par
}
{\xe \v SYSP_parListSc15aMmpara\:sysp_sc15a.c}
{\xe \v sysp_sc15a.c\:SYSP_parListSc15aMmpara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_CONST_STRING} {\b SYSP_parListSc15aMmpara}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_mem0,\par
    SYSP_mem1,\par
    SYSP_flash0,\par
    SYSP_cpu,\par
    SYSP_cpuclkhz,\par
    SYSP_memclkhz,\par
    SYSP_pciclkhz,\par
    SYSP_clun,\par
    SYSP_dlun,\par
    SYSP_rststat,   \par
    SYSP_mmst,\par
    SYSP_mm,\par
    SYSP_cons,\par
    SYSP_nmac0, \par
    SYSP_nmac1, \par
    NULL\par
\}\par
\par
}
list of parameters in "mmpara" parameter group \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_sc20.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_sc20.c}
{\xe \v sysp_sc20.c}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid SC20 specific part.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _EEOFF}(x)\~ offsetof(struct menm_parms,x)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsSc20CpuProbe} ({\b SYSP_MMSMB_SUPER} *xSuper)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Probe for SC20 CPU EEPROM and non-persistant mmpara section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Sc20Init} ({\b SYSP_SUPER} *super)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize/Reinitialize SYSPARAM for SC20. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SC20_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for SC20. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_MMSMB_SUPER} {\b G_super}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i SYSPARAM super object. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u_int32 {\b G_alloc} [1100]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i allocation heap }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListSc20Menm} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in SC20 CPU EEPROM, menmon section }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_CONST_STRING} {\b SYSP_parListSc20Mmpara} []\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i list of parameters in "mmpara" parameter group }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
SC20 specific part. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de}/rla {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2010/12/15 09:17:34 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.3 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid MM_CODE_SHRINK - to bring MENMON < 256 kB\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _EEOFF\:sysp_sc20.c}
{\xe \v sysp_sc20.c\:_EEOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _EEOFF(x)\~ offsetof(struct menm_parms,x)}
}\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v SC20_SysParamInit\:sysp_sc20.c}
{\xe \v sysp_sc20.c\:SC20_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SC20_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for SC20. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Sc20Init\:sysp_sc20.c}
{\xe \v sysp_sc20.c\:Sc20Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Sc20Init ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize/Reinitialize SYSPARAM for SC20. \par
Probes for CPU EEPROM and possible ESM carrier boards {{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_NvsSc20CpuProbe\:sysp_sc20.c}
{\xe \v sysp_sc20.c\:SYSP_NvsSc20CpuProbe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsSc20CpuProbe ({\b SYSP_MMSMB_SUPER} * {\i xSuper}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Probe for SC20 CPU EEPROM and non-persistant mmpara section. \par
Creates all parameter sections that shall be present in SC20 CPU EEPROM even if there is an EEPROM error.\par
Also creates the MENMON parameter section "mmpara"\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_alloc\:sysp_sc20.c}
{\xe \v sysp_sc20.c\:G_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u_int32 {\b G_alloc}[1100]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
allocation heap \par
\par
\par
}
{\xe \v G_super\:sysp_sc20.c}
{\xe \v sysp_sc20.c\:G_super}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_MMSMB_SUPER} {\b G_super}{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
SYSPARAM super object. \par
\par
\par
}
{\xe \v SYSP_parListSc20Menm\:sysp_sc20.c}
{\xe \v sysp_sc20.c\:SYSP_parListSc20Menm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListSc20Menm}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
list of parameters in SC20 CPU EEPROM, menmon section \par
\par
\par
}
{\xe \v SYSP_parListSc20Mmpara\:sysp_sc20.c}
{\xe \v sysp_sc20.c\:SYSP_parListSc20Mmpara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_CONST_STRING} {\b SYSP_parListSc20Mmpara}[]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_mem0,\par
    SYSP_flash0,\par
    SYSP_cpu,\par
    SYSP_cpuclkhz,\par
    SYSP_MPC52XX_inclkhz,\par
    SYSP_memclkhz,\par
    SYSP_MPC52XX_xlbclkhz,\par
    SYSP_MPC52XX_ipbclkhz,\par
    SYSP_pciclkhz,\par
    SYSP_clun,\par
    SYSP_dlun,\par
    SYSP_usbdp,\par
    SYSP_mmst,\par
    SYSP_mm,\par
    SYSP_cons,\par
    SYSP_nmac0,\par
    NULL\par
\}\par
\par
}
list of parameters in "mmpara" parameter group \par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_strgrp.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_strgrp.c}
{\xe \v sysp_strgrp.c}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Parameter group handler for NV sections containg a single string.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_PGRP_STR}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b StrValidate} (const char *parVal)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if string contains invalid chars. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StrGrpNumParams} ({\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get num parameters in mpgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StrGrpEnumParams} ({\b SYSP_PAR_GRP} *parGrp, int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Enum strGrp params. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StrGrpSetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set strGrp parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StrGrpGetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get strGrp parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StrGrpGetParamDefault} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get strGrp parameter's default. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StrGrpSetDefaults} ({\b SYSP_PAR_GRP} *parGrp, int force)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set strGrp to defaults. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StrGrpSave} ({\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Save strGrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StrGrpCreate} ({\b SYSP_NV_STORAGE} *nvs, const char *name, const char *alias, int nvsOffset, int nvsSize, const char *defVal)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create a parameter group object for simple strings. }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Parameter group handler for NV sections containg a single string. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2007/03/08 11:19:56 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.7 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}\par
Handles only one parameter that has the same name as the param group.\par
{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v StrValidate\:sysp_strgrp.c}
{\xe \v sysp_strgrp.c\:StrValidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int StrValidate (const char * {\i parVal}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if string contains invalid chars. \par
\par
\par
}
{\xe \v SYSP_StrGrpCreate\:sysp_strgrp.c}
{\xe \v sysp_strgrp.c\:SYSP_StrGrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StrGrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, const char * {\i name}, const char * {\i alias}, int {\i nvsOffset}, int {\i nvsSize}, const char * {\i defVal})}
}\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create a parameter group object for simple strings. \par
On success, the parameter group is added to the list of {\i nvs}  groups\par
The string is read from the non volatile storage. If there is a physical read error, or if it contains non-printable chars, default string is setup.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i name} {\b IN}  name of parameter group and name of the parameter itsself \par
{\i alias} {\b IN}  alias name of parameter (can be NULL) \par
{\i nvsOffset} {\b IN}  starting byte offset of string within NV storage \par
{\i nvsSize} {\b IN}  max size of string in NV storage in bytes \par
{\i defVal} {\b IN}  default value for string (can be NULL)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_StrGrpEnumParams\:sysp_strgrp.c}
{\xe \v sysp_strgrp.c\:SYSP_StrGrpEnumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StrGrpEnumParams ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i idx}, int {\i alias}, {\b SYSPARAM_PARAM_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enum strGrp params. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::enumParams} \par
}\par
\par
}
{\xe \v SYSP_StrGrpGetParam\:sysp_strgrp.c}
{\xe \v sysp_strgrp.c\:SYSP_StrGrpGetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StrGrpGetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get strGrp parameter. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::getParam} \par
}\par
\par
}
{\xe \v SYSP_StrGrpGetParamDefault\:sysp_strgrp.c}
{\xe \v sysp_strgrp.c\:SYSP_StrGrpGetParamDefault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StrGrpGetParamDefault ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get strGrp parameter's default. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::getParamDefault} \par
}\par
\par
}
{\xe \v SYSP_StrGrpNumParams\:sysp_strgrp.c}
{\xe \v sysp_strgrp.c\:SYSP_StrGrpNumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StrGrpNumParams ({\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get num parameters in mpgrp. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::numParams} \par
}\par
\par
}
{\xe \v SYSP_StrGrpSave\:sysp_strgrp.c}
{\xe \v sysp_strgrp.c\:SYSP_StrGrpSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StrGrpSave ({\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Save strGrp. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::save} \par
}\par
\par
}
{\xe \v SYSP_StrGrpSetDefaults\:sysp_strgrp.c}
{\xe \v sysp_strgrp.c\:SYSP_StrGrpSetDefaults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StrGrpSetDefaults ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i force})}
}\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set strGrp to defaults. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setDefaults} \par
}\par
\par
}
{\xe \v SYSP_StrGrpSetParam\:sysp_strgrp.c}
{\xe \v sysp_strgrp.c\:SYSP_StrGrpSetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StrGrpSetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd}, int {\i attr})}
}\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set strGrp parameter. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setParam} \par
}\par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_sysdep.h File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_sysdep.h}
{\xe \v sysp_sysdep.h}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid SYSPARAM system dependent includes/defines.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_STRCPY}\~ strcpy\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_STRNCPY}\~ strncpy\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_STRCMP}\~ strcmp\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_STRNCMP}\~ strncmp\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_STRLEN}\~ strlen\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_MEMSET}\~ memset\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_MEMCMP}\~ memcmp\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_MEMMOVE}\~ memmove\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_SPRINTF}\~ sprintf\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_VSPRINTF}\~ vsprintf\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_STRTOUL}\~ strtoul\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_STRTOL}\~ strtol\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_STRCHR}\~ strchr\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b offsetof}(type, part)\~ ((int)((char*)&((type*)0)->part-(char*)0))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DBG_WRITE_DEFINED_BY_DBG_OS_H}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DBG_Write}(dbh, fmt, args...)\~ mm_usr_printf( fmt, ## args )\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_TOBE16}(word)\~ (word)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_TOBE32}(dword)\~ (dword)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_FROMBE16}\~ SYSP_TOBE16\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_FROMBE32}\~ SYSP_TOBE32\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
SYSPARAM system dependent includes/defines. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2008/06/27 14:07:49 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.15 \par
}\par
}\par
{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\f2 SYSP_CONFIG_MDIS_BUILD}  - Set this when compiling within MDIS build environment.\par
}
\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\f2 DBG}  - Compile with debug messages enabled (very few are there)\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\f2 SYSP_CONFIG_UNITTEST}  - include unittests\par
}
\par
If SYSP_CONFIG_MDIS_BUILD is not set, the following switches can be set:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\f2 SYSP_CONFIG_LINUX} , {\f2 SYSP_CONFIG_MENMON} , {\f2 SYSP_CONFIG_VXWORKS} , {\f2 SYSP_CONFIG_OS9}  - the operating system used.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\f2 SYSP_CONFIG_LE} , {\f2 SYSP_CONFIG_BE}  little or big endian\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v DBG_Write\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:DBG_Write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DBG_Write(dbh, fmt, args...)\~ mm_usr_printf( fmt, ## args )}
}\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v DBG_WRITE_DEFINED_BY_DBG_OS_H\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:DBG_WRITE_DEFINED_BY_DBG_OS_H}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DBG_WRITE_DEFINED_BY_DBG_OS_H}
}\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v offsetof\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:offsetof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define offsetof(type, part)\~ ((int)((char*)&((type*)0)->part-(char*)0))}
}\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FROMBE16\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_FROMBE16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_FROMBE16\~ SYSP_TOBE16}
}\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FROMBE32\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_FROMBE32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_FROMBE32\~ SYSP_TOBE32}
}\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MEMCMP\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_MEMCMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_MEMCMP\~ memcmp}
}\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MEMMOVE\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_MEMMOVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_MEMMOVE\~ memmove}
}\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MEMSET\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_MEMSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_MEMSET\~ memset}
}\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_SPRINTF\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_SPRINTF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_SPRINTF\~ sprintf}
}\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_STRCHR\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_STRCHR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_STRCHR\~ strchr}
}\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_STRCMP\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_STRCMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_STRCMP\~ strcmp}
}\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_STRCPY\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_STRCPY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_STRCPY\~ strcpy}
}\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_STRLEN\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_STRLEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_STRLEN\~ strlen}
}\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_STRNCMP\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_STRNCMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_STRNCMP\~ strncmp}
}\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_STRNCPY\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_STRNCPY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_STRNCPY\~ strncpy}
}\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_STRTOL\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_STRTOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_STRTOL\~ strtol}
}\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_STRTOUL\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_STRTOUL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_STRTOUL\~ strtoul}
}\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_TOBE16\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_TOBE16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_TOBE16(word)\~ (word)}
}\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_TOBE32\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_TOBE32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_TOBE32(dword)\~ (dword)}
}\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_VSPRINTF\:sysp_sysdep.h}
{\xe \v sysp_sysdep.h\:SYSP_VSPRINTF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_VSPRINTF\~ vsprintf}
}\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_tags.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_tags.c}
{\xe \v sysp_tags.c}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Standard parameter name strings.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_NmacName} (char *buf, int ifNum)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_NspeedName} (char *buf, int ifNum)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_BuspciName} (char *buf, int ifNum)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_PrefixParamName} (char prefix, const char *parName, char *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Build prefixed parameter name (e.g. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mem0} [] = "mem0"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mem1} [] = "mem1"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_flash0} [] = "flash0"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_flash1} [] = "flash1"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_fram0} [] = "fram0"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_cpu} [] = "cpu"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_cpuclkhz} [] = "cpuclkhz"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_memclkhz} [] = "memclkhz"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_pciclkhz} [] = "pciclkhz"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_clun} [] = "clun"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_dlun} [] = "dlun"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat} [] = "rststat"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_pwon} [] = "pwon"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_pdrop} [] = "pdrop"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_temp} [] = "temp"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_sw} [] = "swrst"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_wdog} [] = "wdog"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_rbut} [] = "rbut"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_hrst} [] = "hrst"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_srst} [] = "srst"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_cb} [] = "cbrst"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_unknown} [] = "???"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mmst} [] = "mmst"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mm} [] = "mm"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mm_pmm} [] = "pmm"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mm_smm} [] = "smm"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_cons} [] = "cons"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_brd} [] = "brd"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_brdmod} [] = "brdmod"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_brdrev} [] = "brdrev"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_sernbr} [] = "sernbr"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_prodat} [] = "prodat"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_repdat} [] = "repdat"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_con0} [] = "con0"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_con1} [] = "con1"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_con2} [] = "con2"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_con3} [] = "con3"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_gcon} [] = "gcon"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_gstatshow} [] = "gstatshow"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_vmode} [] = "vmode"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_cbr} [] = "cbr"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_baud} [] = "baud"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_bsadr} [] = "bsadr"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_bs} [] = "bs"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_ecl} [] = "ecl"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_tto} [] = "tto"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_tries} [] = "tries"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_tdp} [] = "tdp"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_hdp} [] = "hdp"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_wdt} [] = "wdt"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stignfault} [] = "stignfault"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stdis} [] = "stdis"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stdis_wdog} [] = "stdis_wdog"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stdis_nand} [] = "stdis_nand"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stdis_usb} [] = "stdis_usb"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stdis_ether} [] = "stdis_ether"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stwait} [] = "stwait"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_ldlogodis} [] = "ldlogodis"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_updcdis} [] = "updcdis"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mmstartup} [] = "mmstartup"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_startup} [] = "startup"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_kerpar} [] = "kerpar"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_useflpar} [] = "useflpar"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_bf} [] = "bf"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_bootfile} [] = "bootfile"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_netip} [] = "netip"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_netgw} [] = "netgw"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nethost} [] = "nethost"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_netname} [] = "netname"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_netaddr} [] = "netaddr"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_netsm} [] = "netsm"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nspeed0} [] = "nspeed0"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nspeed1} [] = "nspeed1"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nspeed2} [] = "nspeed2"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nspeed3} [] = "nspeed3"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nmac0} [] = "nmac0"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nmac1} [] = "nmac1"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nmac2} [] = "nmac2"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nmac3} [] = "nmac3"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_usbdp} [] = "usbdp"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_fpga} [] = "fpga"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_buspci0} [] = "buspci0"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_buspci1} [] = "buspci1"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_buspci2} [] = "buspci2"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rand} [] = "rand"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nobanner} [] = "nobanner"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_normalboot} [] = "normalboot"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_p3rec} [] = "inv_rec"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_p3part} [] = "inv_part"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_p3rev} [] = "inv_rev"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_p3ser} [] = "inv_ser"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_p3crc} [] = "inv_crc"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b SYSP_nspeedValue} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b SYSP_comModeValue} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Standard parameter name strings. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2010/06/07 16:32:43 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.21 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v SYSP_BuspciName\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_BuspciName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* SYSP_BuspciName (char * {\i buf}, int {\i ifNum})}
}\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_NmacName\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_NmacName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* SYSP_NmacName (char * {\i buf}, int {\i ifNum})}
}\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_NspeedName\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_NspeedName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* SYSP_NspeedName (char * {\i buf}, int {\i ifNum})}
}\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_PrefixParamName\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_PrefixParamName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* SYSP_PrefixParamName (char {\i prefix}, const char * {\i parName}, char * {\i buf})}
}\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Build prefixed parameter name (e.g. \par
for carrier boards)\par
If prefix non-zero, build parameter "x-param", where x is the prefix\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i prefix} {\b IN}  board prefix (e.g. 'c') (0 if none) \par
{\i buf} {\b OUT}  filled with name (must have enough space) \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid buf \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v SYSP_baud\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_baud}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_baud}[] = "baud"}
}\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_bf\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_bf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_bf}[] = "bf"}
}\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_bootfile\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_bootfile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_bootfile}[] = "bootfile"}
}\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_brd\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_brd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_brd}[] = "brd"}
}\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_brdmod\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_brdmod}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_brdmod}[] = "brdmod"}
}\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_brdrev\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_brdrev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_brdrev}[] = "brdrev"}
}\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_bs\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_bs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_bs}[] = "bs"}
}\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_bsadr\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_bsadr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_bsadr}[] = "bsadr"}
}\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_buspci0\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_buspci0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_buspci0}[] = "buspci0"}
}\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_buspci1\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_buspci1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_buspci1}[] = "buspci1"}
}\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_buspci2\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_buspci2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_buspci2}[] = "buspci2"}
}\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_cbr\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_cbr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_cbr}[] = "cbr"}
}\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_clun\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_clun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_clun}[] = "clun"}
}\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_comModeValue\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_comModeValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_comModeValue}[]}
}\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    "RS422", "RS232", "RS485", NULL\par
\}\par
\par
}
}
{\xe \v SYSP_con0\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_con0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_con0}[] = "con0"}
}\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_con1\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_con1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_con1}[] = "con1"}
}\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_con2\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_con2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_con2}[] = "con2"}
}\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_con3\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_con3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_con3}[] = "con3"}
}\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_cons\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_cons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_cons}[] = "cons"}
}\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_cpu\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_cpu}[] = "cpu"}
}\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_cpuclkhz\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_cpuclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_cpuclkhz}[] = "cpuclkhz"}
}\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_dlun\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_dlun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_dlun}[] = "dlun"}
}\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ecl\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_ecl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_ecl}[] = "ecl"}
}\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_flash0\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_flash0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_flash0}[] = "flash0"}
}\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_flash1\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_flash1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_flash1}[] = "flash1"}
}\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_fpga\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_fpga}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_fpga}[] = "fpga"}
}\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_fram0\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_fram0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_fram0}[] = "fram0"}
}\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_gcon\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_gcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_gcon}[] = "gcon"}
}\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_gstatshow\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_gstatshow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_gstatshow}[] = "gstatshow"}
}\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_hdp\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_hdp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_hdp}[] = "hdp"}
}\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_kerpar\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_kerpar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_kerpar}[] = "kerpar"}
}\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ldlogodis\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_ldlogodis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_ldlogodis}[] = "ldlogodis"}
}\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mem0\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_mem0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mem0}[] = "mem0"}
}\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mem1\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_mem1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mem1}[] = "mem1"}
}\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_memclkhz\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_memclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_memclkhz}[] = "memclkhz"}
}\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mm\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_mm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mm}[] = "mm"}
}\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mm_pmm\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_mm_pmm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mm_pmm}[] = "pmm"}
}\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mm_smm\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_mm_smm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mm_smm}[] = "smm"}
}\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mmst\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_mmst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mmst}[] = "mmst"}
}\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mmstartup\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_mmstartup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mmstartup}[] = "mmstartup"}
}\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_netaddr\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_netaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_netaddr}[] = "netaddr"}
}\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_netgw\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_netgw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_netgw}[] = "netgw"}
}\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nethost\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_nethost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nethost}[] = "nethost"}
}\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_netip\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_netip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_netip}[] = "netip"}
}\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_netname\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_netname}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_netname}[] = "netname"}
}\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_netsm\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_netsm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_netsm}[] = "netsm"}
}\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nmac0\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_nmac0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nmac0}[] = "nmac0"}
}\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nmac1\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_nmac1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nmac1}[] = "nmac1"}
}\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nmac2\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_nmac2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nmac2}[] = "nmac2"}
}\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nmac3\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_nmac3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nmac3}[] = "nmac3"}
}\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nobanner\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_nobanner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nobanner}[] = "nobanner"}
}\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_normalboot\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_normalboot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_normalboot}[] = "normalboot"}
}\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nspeed0\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_nspeed0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nspeed0}[] = "nspeed0"}
}\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nspeed1\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_nspeed1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nspeed1}[] = "nspeed1"}
}\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nspeed2\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_nspeed2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nspeed2}[] = "nspeed2"}
}\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nspeed3\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_nspeed3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nspeed3}[] = "nspeed3"}
}\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nspeedValue\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_nspeedValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_nspeedValue}[]}
}\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    "AUTO", "10HD", "10FD", "100HD", "100FD", "1000", NULL\par
\}\par
\par
}
}
{\xe \v SYSP_p3crc\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_p3crc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_p3crc}[] = "inv_crc"}
}\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_p3part\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_p3part}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_p3part}[] = "inv_part"}
}\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_p3rec\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_p3rec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_p3rec}[] = "inv_rec"}
}\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_p3rev\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_p3rev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_p3rev}[] = "inv_rev"}
}\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_p3ser\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_p3ser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_p3ser}[] = "inv_ser"}
}\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_pciclkhz\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_pciclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_pciclkhz}[] = "pciclkhz"}
}\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_prodat\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_prodat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_prodat}[] = "prodat"}
}\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rand\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rand}[] = "rand"}
}\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_repdat\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_repdat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_repdat}[] = "repdat"}
}\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rststat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat}[] = "rststat"}
}\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_cb\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rststat_cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_cb}[] = "cbrst"}
}\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_hrst\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rststat_hrst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_hrst}[] = "hrst"}
}\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_pdrop\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rststat_pdrop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_pdrop}[] = "pdrop"}
}\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_pwon\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rststat_pwon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_pwon}[] = "pwon"}
}\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_rbut\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rststat_rbut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_rbut}[] = "rbut"}
}\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_srst\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rststat_srst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_srst}[] = "srst"}
}\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_sw\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rststat_sw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_sw}[] = "swrst"}
}\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_temp\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rststat_temp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_temp}[] = "temp"}
}\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_unknown\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rststat_unknown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_unknown}[] = "???"}
}\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_wdog\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_rststat_wdog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_wdog}[] = "wdog"}
}\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_sernbr\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_sernbr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_sernbr}[] = "sernbr"}
}\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_startup\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_startup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_startup}[] = "startup"}
}\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stdis\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_stdis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stdis}[] = "stdis"}
}\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stdis_ether\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_stdis_ether}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stdis_ether}[] = "stdis_ether"}
}\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stdis_nand\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_stdis_nand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stdis_nand}[] = "stdis_nand"}
}\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stdis_usb\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_stdis_usb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stdis_usb}[] = "stdis_usb"}
}\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stdis_wdog\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_stdis_wdog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stdis_wdog}[] = "stdis_wdog"}
}\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stignfault\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_stignfault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stignfault}[] = "stignfault"}
}\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stwait\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_stwait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stwait}[] = "stwait"}
}\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_tdp\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_tdp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_tdp}[] = "tdp"}
}\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_tries\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_tries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_tries}[] = "tries"}
}\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_tto\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_tto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_tto}[] = "tto"}
}\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_updcdis\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_updcdis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_updcdis}[] = "updcdis"}
}\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_usbdp\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_usbdp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_usbdp}[] = "usbdp"}
}\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_useflpar\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_useflpar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_useflpar}[] = "useflpar"}
}\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_vmode\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_vmode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_vmode}[] = "vmode"}
}\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_wdt\:sysp_tags.c}
{\xe \v sysp_tags.c\:SYSP_wdt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_wdt}[] = "wdt"}
}\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_tags_esm_cb.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_tags_esm_cb.c}
{\xe \v sysp_tags_esm_cb.c}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Standard ESM carrier board parameter name strings.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_esm_cb_partnum} [] = "pnum"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_esm_cb_hwflag} [] = "hwflag"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Standard ESM carrier board parameter name strings. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid cs {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2006/01/05 14:34:38 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.1 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM2 library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v SYSP_esm_cb_hwflag\:sysp_tags_esm_cb.c}
{\xe \v sysp_tags_esm_cb.c\:SYSP_esm_cb_hwflag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_esm_cb_hwflag}[] = "hwflag"}
}\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_esm_cb_partnum\:sysp_tags_esm_cb.c}
{\xe \v sysp_tags_esm_cb.c\:SYSP_esm_cb_partnum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_esm_cb_partnum}[] = "pnum"}
}\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_tags_mpc52xx.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_tags_mpc52xx.c}
{\xe \v sysp_tags_mpc52xx.c}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Standard MPC5200 parameter name strings.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC52XX_inclkhz} [] = "inclkhz"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC52XX_xlbclkhz} [] = "xlbclkhz"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC52XX_ipbclkhz} [] = "ipbclkhz"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Standard MPC5200 parameter name strings. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid uf {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2005/06/23 15:54:40 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.3 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v SYSP_MPC52XX_inclkhz\:sysp_tags_mpc52xx.c}
{\xe \v sysp_tags_mpc52xx.c\:SYSP_MPC52XX_inclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC52XX_inclkhz}[] = "inclkhz"}
}\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC52XX_ipbclkhz\:sysp_tags_mpc52xx.c}
{\xe \v sysp_tags_mpc52xx.c\:SYSP_MPC52XX_ipbclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC52XX_ipbclkhz}[] = "ipbclkhz"}
}\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC52XX_xlbclkhz\:sysp_tags_mpc52xx.c}
{\xe \v sysp_tags_mpc52xx.c\:SYSP_MPC52XX_xlbclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC52XX_xlbclkhz}[] = "xlbclkhz"}
}\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_tags_mpc85xx.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_tags_mpc85xx.c}
{\xe \v sysp_tags_mpc85xx.c}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Standard MPC85XX parameter name strings.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC85XX_ccbclkhz} [] = "ccbclkhz"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC85XX_brgclkhz} [] = "brgclkhz"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC85XX_immr} [] = "immr"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Standard MPC85XX parameter name strings. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid kp {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2005/06/23 15:54:42 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.2 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid none\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v SYSP_MPC85XX_brgclkhz\:sysp_tags_mpc85xx.c}
{\xe \v sysp_tags_mpc85xx.c\:SYSP_MPC85XX_brgclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC85XX_brgclkhz}[] = "brgclkhz"}
}\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC85XX_ccbclkhz\:sysp_tags_mpc85xx.c}
{\xe \v sysp_tags_mpc85xx.c\:SYSP_MPC85XX_ccbclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC85XX_ccbclkhz}[] = "ccbclkhz"}
}\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC85XX_immr\:sysp_tags_mpc85xx.c}
{\xe \v sysp_tags_mpc85xx.c\:SYSP_MPC85XX_immr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC85XX_immr}[] = "immr"}
}\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysp_vxbline.c File Reference\par \pard\plain 
{\tc\tcl2 \v sysp_vxbline.c}
{\xe \v sysp_vxbline.c}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Parameter group handler for VxWorks bootline parameters.  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSP_PGRP_VX}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b VXBL_BOOT_PARAMS}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i structure to convert boot line }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_DEV_LEN}\~ 20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_HOST_LEN}\~ 20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_ADDR_LEN}\~ 30\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_TARGET_ADDR_LEN}\~ 50\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_ADDR_LEN}\~ 30\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_FILE_LEN}\~ 80\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_USR_LEN}\~ 20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_STARTUP_LEN}\~ 256\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_PASSWORD_LEN}\~ 20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_OTHER_LEN}\~ 80\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_FIELD_LEN}\~ 80\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOOT_NUM_LEN}\~ 10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _BPOFF}(x)\~ offsetof({\b VXBL_BOOT_PARAMS},x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_VXBLIP}(_nm, _alias, _offs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PDE_VXBLSM}(_nm, _alias, _offs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_VxBootStringToStruct} (char *bootString, {\b VXBL_BOOT_PARAMS} *pBootParams)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Parse VxBline string and return parsed parameters in structure. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_VxBootStructToString} (char *paramString, const {\b VXBL_BOOT_PARAMS} *pBootParams)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Convert struct to vxBline. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b VxBlValidate} (const char *parVal)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if bootline contains invalid chars. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_VxGrpNumParams} ({\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get num parameters in mpgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_VxGrpEnumParams} ({\b SYSP_PAR_GRP} *parGrp, int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Enum vxgrp params. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_VxGrpSetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set vxgrp parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_VxGrpGetParam} ({\b SYSP_PAR_GRP} *parGrp, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get vxgrp parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_VxGrpSetDefaults} ({\b SYSP_PAR_GRP} *parGrp, int force)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set vxgrp to defaults. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_VxGrpSave} ({\b SYSP_PAR_GRP} *parGrp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Save vxgrp. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_VxGrpCreate} ({\b SYSP_NV_STORAGE} *nvs, int nvsOffset, int nvsSize, char *vxBline, const char *vxDefBline, int provideKerpar)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Create a parameter group object for VxWorks bootline parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ScanStringTil} (char **bootStringP, char *dest, int destLen, char term)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b EatBlanks} (char *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b GetBase} (int base, char *s, u_int32 *val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawVxblIp} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Extract IP address from VxBl "e" field Return everything until first ":" or until EOS if no ":". }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawVxblSm} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Extract subnet mask from VxBl "e" field Return everything after first ":" between next ":" or EOS. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawVxblIp} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i modify VxBl IP in "e" NOTE: Destroys informatation in ead other than IP and subnetmask (e.g. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawVxblSm} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i modify VxBl SM in "e" }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSP_PGRP_VX} * {\b SYSP_VxGrpFind} ({\b SYSP_SUPER} *super)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SysParamVxBootParamsPrompt} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Interactive VxBline modification in MENMON. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b G_kerparAlias} [7]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SYSP_PAR_DESC} {\b SYSP_parListVx} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Parameter group handler for VxWorks bootline parameters. \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2008/06/11 17:27:24 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 1.12 \par
}\par
}{{\b \par
Project:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM library \par
}{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid HURRICANE\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _BPOFF\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:_BPOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _BPOFF(x)\~ offsetof({\b VXBL_BOOT_PARAMS},x)}
}\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_ADDR_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_ADDR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_ADDR_LEN\~ 30}
}\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_ADDR_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_ADDR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_ADDR_LEN\~ 30}
}\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_DEV_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_DEV_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_DEV_LEN\~ 20}
}\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_FIELD_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_FIELD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_FIELD_LEN\~ 80}
}\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_FILE_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_FILE_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_FILE_LEN\~ 80}
}\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_HOST_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_HOST_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_HOST_LEN\~ 20}
}\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_NUM_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_NUM_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_NUM_LEN\~ 10}
}\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_OTHER_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_OTHER_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_OTHER_LEN\~ 80}
}\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_PASSWORD_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_PASSWORD_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_PASSWORD_LEN\~ 20}
}\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_STARTUP_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_STARTUP_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_STARTUP_LEN\~ 256}
}\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_TARGET_ADDR_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_TARGET_ADDR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_TARGET_ADDR_LEN\~ 50}
}\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v BOOT_USR_LEN\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:BOOT_USR_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOOT_USR_LEN\~ 20}
}\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_PDE_VXBLIP\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_PDE_VXBLIP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_VXBLIP(_nm, _alias, _offs)}
}\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawVxblIp, SYSP_FromRawVxblIp, NULL,\\\par
   NULL, 0, (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET)\}\par
\par
}
}
{\xe \v SYSP_PDE_VXBLSM\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_PDE_VXBLSM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PDE_VXBLSM(_nm, _alias, _offs)}
}\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{ _nm, _alias, _offs, SYSP_ToRawVxblSm, SYSP_FromRawVxblSm, NULL,\\\par
   NULL, 0, (SYSP_PD_MMPARASTR*0 | SYSP_PD_NEEDRESET)\}\par
\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EatBlanks\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:EatBlanks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* EatBlanks (char * {\i p}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v GetBase\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:GetBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* GetBase (int {\i base}, char * {\i s}, u_int32 * {\i val}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v ScanStringTil\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:ScanStringTil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ScanStringTil (char ** {\i bootStringP}, char * {\i dest}, int {\i destLen}, char {\i term}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawVxblIp\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_FromRawVxblIp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawVxblIp (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Extract IP address from VxBl "e" field Return everything until first ":" or until EOS if no ":". \par
\par
\par
}
{\xe \v SYSP_FromRawVxblSm\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_FromRawVxblSm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawVxblSm (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Extract subnet mask from VxBl "e" field Return everything after first ":" between next ":" or EOS. \par
\par
\par
}
{\xe \v SYSP_ToRawVxblIp\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_ToRawVxblIp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawVxblIp (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
modify VxBl IP in "e" NOTE: Destroys informatation in ead other than IP and subnetmask (e.g. \par
lease time) {\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} pointer into ead field \par
{\i src} users IP address \par
}
\par
\par
}
{\xe \v SYSP_ToRawVxblSm\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_ToRawVxblSm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawVxblSm (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
modify VxBl SM in "e" \par
NOTE: Destroys informatation in ead other than IP and subnetmask (e.g. lease time) {\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dest} pointer into ead field \par
{\i src} users subnet mask \par
}
\par
\par
}
{\xe \v SYSP_VxBootStringToStruct\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_VxBootStringToStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * SYSP_VxBootStringToStruct (char * {\i bootString}, {\b VXBL_BOOT_PARAMS} * {\i pBootParams})}
}\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Parse VxBline string and return parsed parameters in structure. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i bootString} {\b IN}  ptr to line to be parsed \par
{\i pBootParams} {\b OUT}  ptr to struct to be filled \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A pointer to the last character successfully parsed plus one \par
}\par
\par
}
{\xe \v SYSP_VxBootStructToString\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_VxBootStructToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * SYSP_VxBootStructToString (char * {\i paramString}, const {\b VXBL_BOOT_PARAMS} * {\i pBootParams})}
}\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Convert struct to vxBline. \par
Note: no overflow checking of the string is made! Worst case, the string can have approx. 656 chars.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i paramString} {\b OUT}  ptr to line to be filled \par
{\i pBootParams} {\b IN}  ptr to struct to be encoded \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid pointer into bootString to terminating '\\0' \par
}\par
\par
}
{\xe \v SYSP_VxGrpCreate\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_VxGrpCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_VxGrpCreate ({\b SYSP_NV_STORAGE} * {\i nvs}, int {\i nvsOffset}, int {\i nvsSize}, char * {\i vxBline}, const char * {\i vxDefBline}, int {\i provideKerpar})}
}\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Create a parameter group object for VxWorks bootline parameters. \par
On success, the parameter group is added to the list of {\i nvs}  groups\par
If the passed {\i vxBline}  is an empty string, the vxBline is read from the non volatile storage. If there is a physical read error, or if it contains non-printable chars, default bootline is setup.\par
If the passed {\i vxBline}  is not-empty, it is checked for non-printable chars, and defaults are applied if so.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvs} {\b IN}  NV storage object (fully initialized) \par
{\i nvsOffset} {\b IN}  starting byte offset of vxbline within NV storage \par
{\i nvsSize} {\b IN}  size of vxbline in NV storage in bytes \par
{\i vxBline} {\b IN}  the vxworks boot line in memory \par
{\i vxDefBline} {\b IN}  VxWorks boot line with defaults, if NULL, an empty bootline will be the default \par
{\i provideKerpar} {\b IN}  if SYSP_PROVIDE_KERPAR, let "kerpar" be an alias to "s"\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_VxGrpEnumParams\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_VxGrpEnumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_VxGrpEnumParams ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i idx}, int {\i alias}, {\b SYSPARAM_PARAM_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enum vxgrp params. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::enumParams} \par
}\par
\par
}
{\xe \v SYSP_VxGrpFind\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_VxGrpFind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SYSP_PGRP_VX}* SYSP_VxGrpFind ({\b SYSP_SUPER} * {\i super}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_VxGrpGetParam\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_VxGrpGetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_VxGrpGetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get vxgrp parameter. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::getParam} \par
}\par
\par
}
{\xe \v SYSP_VxGrpNumParams\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_VxGrpNumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_VxGrpNumParams ({\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get num parameters in mpgrp. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::numParams} \par
}\par
\par
}
{\xe \v SYSP_VxGrpSave\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_VxGrpSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_VxGrpSave ({\b SYSP_PAR_GRP} * {\i parGrp})}
}\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Save vxgrp. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::save} \par
}\par
\par
}
{\xe \v SYSP_VxGrpSetDefaults\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_VxGrpSetDefaults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_VxGrpSetDefaults ({\b SYSP_PAR_GRP} * {\i parGrp}, int {\i force})}
}\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set vxgrp to defaults. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setDefaults} \par
}\par
\par
}
{\xe \v SYSP_VxGrpSetParam\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_VxGrpSetParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_VxGrpSetParam ({\b SYSP_PAR_GRP} * {\i parGrp}, const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd}, int {\i attr})}
}\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set vxgrp parameter. \par
{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SYSP_PAR_GRP::setParam} \par
}\par
\par
}
{\xe \v SysParamVxBootParamsPrompt\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SysParamVxBootParamsPrompt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SysParamVxBootParamsPrompt (void)}
}\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Interactive VxBline modification in MENMON. \par
Display the current value of each parameter and prompt for a new value. Typing a RETURN leaves the parameter unchanged. Typing a period (.) clears the parameter. ^D exits. A '-' edits the previous field\par
This locates the "vxbline" parameter section by using the global {\i SYSP_super}  pointer.\par
After modification done, modified vxBline is saved to NVS storage, and vxBline string has been updated in memory \par
\par
}
{\xe \v VxBlValidate\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:VxBlValidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int VxBlValidate (const char * {\i parVal}){\f2  [static]}}
}\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if bootline contains invalid chars. \par
\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v G_kerparAlias\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:G_kerparAlias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char {\b G_kerparAlias}[7]{\f2  [static]}}
}\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_parListVx\:sysp_vxbline.c}
{\xe \v sysp_vxbline.c\:SYSP_parListVx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SYSP_PAR_DESC} {\b SYSP_parListVx}[]}
}\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
    SYSP_PDE_STR( "bootdev",    NULL, _BPOFF(bootDev), NULL,  BOOT_DEV_LEN, 0),\par
    SYSP_PDE_NINTD( "unitnum",  NULL, _BPOFF(unitNum), NULL, 0),\par
    SYSP_PDE_NINTD( "procnum",  NULL, _BPOFF(procNum), NULL, 0),\par
    SYSP_PDE_STR( "hostname",   NULL, _BPOFF(hostName), NULL,  BOOT_HOST_LEN\par
                  , 0),\par
    SYSP_PDE_STR( "e", SYSP_netip, _BPOFF(ead),NULL, BOOT_TARGET_ADDR_LEN, SYSP_PD_NEEDRESET),\par
    SYSP_PDE_STR( "h", SYSP_nethost, _BPOFF(had), NULL, BOOT_ADDR_LEN, SYSP_PD_NEEDRESET),\par
    SYSP_PDE_STR( "g", SYSP_netgw, _BPOFF(gad), NULL, BOOT_ADDR_LEN, SYSP_PD_NEEDRESET),\par
    SYSP_PDE_STR( "tn",SYSP_netname,_BPOFF(targetName), NULL, BOOT_HOST_LEN,0),\par
    SYSP_PDE_STR( "s",  G_kerparAlias, _BPOFF(startupScript), NULL, \par
                  BOOT_STARTUP_LEN, 0),\par
    SYSP_PDE_STR( SYSP_bf, SYSP_bootfile, _BPOFF(bootFile), NULL, \par
                  BOOT_FILE_LEN, 0),\par
    SYSP_PDE_STR( "b",  NULL, _BPOFF(bad), NULL, BOOT_TARGET_ADDR_LEN, 0),\par
    SYSP_PDE_STR( "u", NULL, _BPOFF(usr), NULL, BOOT_USR_LEN, 0),\par
    SYSP_PDE_STR( "p", NULL, _BPOFF(passwd), NULL, BOOT_PASSWORD_LEN, 0),\par
    SYSP_PDE_STR( "o", NULL, _BPOFF(other), NULL, BOOT_OTHER_LEN, 0),\par
    SYSP_PDE_NINTX( "f", NULL, _BPOFF(flags), NULL, 0),\par
\par
    \par
    SYSP_PDE_VXBLIP( SYSP_netaddr, NULL, _BPOFF(ead) ),\par
    SYSP_PDE_VXBLSM( SYSP_netsm, NULL, _BPOFF(ead) ),\par
\par
    SYSP_PDE_END\par
\}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sysparam2.h File Reference\par \pard\plain 
{\tc\tcl2 \v sysparam2.h}
{\xe \v sysparam2.h}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Header file for MEN's sysparam library (second try!).  
\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSPARAM_MMSMB_INIT}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i structure passed to xxxSysParamInit for MENMON/SMB implementations }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSPARAM_NVS_INFO}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i NVS info structure. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSPARAM_PARAM_HELP}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Parameter help structure. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SYSPARAM_PARAM_INFO}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Parameter info structure. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSPARAM_NOT_INIT}\~ 1\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i xxxSysParamInit not called }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSPARAM_INVAL_PARAM}\~ 2\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i invalid/unknown parameter name }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSPARAM_INVAL_VALUE}\~ 3\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i invalid value }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSPARAM_EEPROM_ERROR}\~ 4\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i error reading/writing EEPROM }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSPARAM_READ_ONLY}\~ 5\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i parameter is read only }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSPARAM_NO_RESOURCE}\~ 6\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i out of resources }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSPARAM_VAL_TRUNCATED}\~ 7\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i value has been truncated }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSPARAM_NOT_SUPPORTED}\~ 8\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i operation not supported }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PREFIX_LEN}\~ 4\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i max length of NVS prefix incl }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_PARNAME_LEN}\~ 16\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i max length of parameter name excl }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSP_NVSNAME_LEN}\~ 10\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i max length of NVS section incl }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSPARAM_SMB_BUS_FLASH}\~ 0xff\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i fake SMB bus number for SYSPARAM_MMSMB_INIT.eeXXX functions: use flash }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef const char * {\b SYSP_CONST_STRING}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i a pointer to a const string }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef const enum  \{ ... \}  {\b SYSP_NSPEED_VALUES_IDX}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i index in SYSP_nspeedValue match SYSP_nspeedValue[] entries }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef const enum  \{ ... \}  {\b SYSP_COMMODE_VALUES_IDX}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i index in SYSP_nspeedValue match SYSP_comModeValue[] entries }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int(* {\b SYSP_POST_PROCESS_CB} )(const char *parName, int attr, int errCode)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i callback type to post process parameter changes }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SYSPARAM_SET_ATTR} \{ {\b SYSPARAM_SA_NON_PERSISTANT} = 0x1, 
{\b SYSPARAM_SA_FROM_FIRMWARE} = 0x2
 \}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i attributes for SysParamSetEx (can be binary ORed) }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SYSPARAM_ACC_ATTR} \{ {\b SYSPARAM_ACC_RO} = 1, 
{\b SYSPARAM_ACC_RW} = 2, 
{\b SYSPARAM_ACC_PW} = 3, 
{\b SYSPARAM_ACC_RW_MASK} = 3, 
{\b SYSPARAM_ACC_ENCRYPT} = 0x10, 
{\b SYSPARAM_ACC_NEEDRESET} = 0x20, 
{\b SYSPARAM_ACC_MMPARASTR} = 0x40, 
{\b SYSPARAM_ACC_PERSISTANT} = 0x80
 \}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i parameter access attributes }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b SYSP_NSPEED_AUTO} =  0, 
{\b SYSP_NSPEED_10HD}, 
{\b SYSP_NSPEED_10FD}, 
{\b SYSP_NSPEED_100HD}, 
{\b SYSP_NSPEED_100FD}, 
{\b SYSP_NSPEED_1000}
 \}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i index in SYSP_nspeedValue match SYSP_nspeedValue[] entries }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b SYSP_COMMODE_RS422} =  0, 
{\b SYSP_COMMODE_RS232}, 
{\b SYSP_COMMODE_RS485}
 \}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i index in SYSP_nspeedValue match SYSP_comModeValue[] entries }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamGetAll} (char *buf, int bufLen, int alias)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get all parameters with their values. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamGet} (const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get value of single system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamGetDefault} (const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get default value of single system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamSet} (const char *parName, const char *parVal, const char *passwd)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Modify value of single system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamSetEx} (const char *parName, const char *parVal, const char *passwd, int attr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Modify value of single system parameter (extended version). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamSetDefaults} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set all non volatile parameters to defaults. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamMakePersistant} (const char *parName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Write temporary changes to NV storage. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamEnum} (int idx, int alias, {\b SYSPARAM_PARAM_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Enumerate all parameters of Sysparam. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamNumParams} (int *numP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get total number of parameters handled by Sysparam. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b SysParamErrStr} (int errCode)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Convert SYSPARAM error code to string. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamSetFmt} (const char *parName, const char *passwd, int attr, const char *fmt,...)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set system parameter using printf style arguments. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamSignedInt} (const char *par, int base, int32 def, int32 *valueP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get value of signed integer system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamUnsignedInt} (const char *par, int base, u_int32 def, u_int32 *valueP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get value of unsigned integer system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamUnsignedIntArray} (const char *par, int base, int no, u_int32 *defP, u_int32 *valueP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get array of unsigned integer system parameters. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamDefUnsignedInt} (const char *par, int base, u_int32 def, u_int32 *valueP)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamDefSignedInt} (const char *par, int base, int32 def, int32 *valueP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get default value of signed integer system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamBool} (const char *par, int def)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get value of boolean system parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MenBrdNameWithModel} (char prefix, char *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Determine chars 3..9 (e.g. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MenBrdProdString} (char prefix, char *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Make full production data string. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SysParamHelp} (const char *parName, {\b SYSPARAM_PARAM_HELP} *parHelp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get help strings for standard parameter. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_NmacName} (char *buf, int ifNum)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_NspeedName} (char *buf, int ifNum)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_BuspciName} (char *buf, int ifNum)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SYSP_PrefixParamName} (char prefix, const char *parName, char *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Build prefixed parameter name (e.g. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_PostProcessingHookInstall} ({\b SYSP_POST_PROCESS_CB} cb)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Configure one additional postprocessing function. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsEnum} (int idx, {\b SYSPARAM_NVS_INFO} *info)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Enumerate NVS sections. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsReadRaw} ({\b SYSP_CONST_STRING} nvsName, int offset, int size, u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Read raw from specified NVS section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_NvsWriteRaw} ({\b SYSP_CONST_STRING} nvsName, int offset, int size, const u_int8 *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Write specified NVS section. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Sc15aSysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for SC15A. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b P504SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for P504. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b F6SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b A12SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for A12. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Em04SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EM04. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Em04ASysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EM04A. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EM03_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EM03. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EM09_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EM09. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b PP01_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b KM01_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EM01_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EM01. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EP01_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EP01. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EP05_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initBlk)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EP06_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b VC01_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Ep04SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for EP04. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b F302_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for f302. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b D602SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SC20_SysParamInit} (const {\b SYSPARAM_MMSMB_INIT} *initblk)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initialize SYSPARAM for SC20. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SysParamVxBootParamsPrompt} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Interactive VxBline modification in MENMON. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_MmNetIfParamsScan} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Scan list of network interfaces and create parameter groups for them. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_FromRawEth} (char *dest, int destLen, void *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i from ethernet MAC number returns empty string if all bytes are 0xff }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_ToRawEth} (void *dest, const char *src)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i to ethernet MAC number }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StringArrFindStr} (const {\b SYSP_CONST_STRING} *arr, {\b SYSP_CONST_STRING} str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Check if string array {\i contains}  a string with the same value as {\i str}  {\i arr}  must be NULL terminated. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StringArrayLen} (const {\b SYSP_CONST_STRING} *arr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Count number of string pointers in array until NULL pointer found. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StringArrCopy} ({\b SYSP_CONST_STRING} dst[], const {\b SYSP_CONST_STRING} src[], int max)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i copy stringtable {\i src}  to stringtbl {\i dst}  }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_StrSafeCpy} (char *dst, const char *src, int destLen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SYSP_AllocInfo} (int *availP, int *minAvailP)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get allocator info. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SYSP_TusParamGet} (const char *tus, int tusMaxLen, const char *parName, char *parVal, int parValMaxLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get value of parameter {\i parName}  from tuple string. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mem0} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mem1} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_flash0} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_flash1} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_fram0} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_cpu} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_cpuclkhz} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_memclkhz} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_pciclkhz} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC52XX_inclkhz} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC52XX_xlbclkhz} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC52XX_ipbclkhz} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC85XX_ccbclkhz} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC85XX_brgclkhz} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC85XX_immr} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC83XX_inclkhz} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC83XX_csbclkhz} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_MPC83XX_ceclkhz} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_clun} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_dlun} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_pwon} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_pdrop} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_temp} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_sw} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_wdog} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_rbut} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_hrst} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_srst} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_cb} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rststat_unknown} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mmst} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mm} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mm_pmm} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mm_smm} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_cons} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_brd} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_brdmod} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_brdrev} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_sernbr} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_prodat} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_repdat} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_con0} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_con1} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_con2} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_con3} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_gcon} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_gstatshow} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_vmode} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_cbr} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_baud} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_bsadr} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_bs} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_ecl} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_tto} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_tries} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_tdp} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_hdp} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_wdt} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stignfault} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stdis} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stdis_wdog} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stdis_nand} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stdis_usb} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stdis_ether} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_stwait} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_ldlogodis} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_updcdis} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_mmstartup} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_startup} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_kerpar} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_useflpar} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_bf} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_bootfile} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_netip} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nethost} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_netgw} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_netname} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_netaddr} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_netsm} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nspeed0} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nspeed1} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nspeed2} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nspeed3} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nmac0} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nmac1} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nmac2} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nmac3} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_esm_cb_partnum} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_esm_cb_hwflag} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_usbdp} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_fpga} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_buspci0} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_buspci1} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_buspci2} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_rand} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_nobanner} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b SYSP_normalboot} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b SYSP_nspeedValue} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b SYSP_comModeValue} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
Header file for MEN's sysparam library (second try!). \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\f2 klaus.popp@men.de} {{\b \par
Date}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2012/03/16 18:56:42 \par
}{{\b \par
Revision}\par
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid 2.44 \par
}\par
}\par
{{\b \par
Preprocessor Switches:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v SYSP_NVSNAME_LEN\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NVSNAME_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_NVSNAME_LEN\~ 10}
}\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
max length of NVS section incl \par
term 0 \par
\par
}
{\xe \v SYSP_PARNAME_LEN\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_PARNAME_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PARNAME_LEN\~ 16}
}\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
max length of parameter name excl \par
pfx \par
\par
}
{\xe \v SYSP_PREFIX_LEN\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_PREFIX_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSP_PREFIX_LEN\~ 4}
}\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
max length of NVS prefix incl \par
term. 0 \par
\par
}
{\xe \v SYSPARAM_EEPROM_ERROR\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_EEPROM_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSPARAM_EEPROM_ERROR\~ 4}
}\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
error reading/writing EEPROM \par
\par
\par
}
{\xe \v SYSPARAM_INVAL_PARAM\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_INVAL_PARAM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSPARAM_INVAL_PARAM\~ 2}
}\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
invalid/unknown parameter name \par
\par
\par
}
{\xe \v SYSPARAM_INVAL_VALUE\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_INVAL_VALUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSPARAM_INVAL_VALUE\~ 3}
}\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
invalid value \par
\par
\par
}
{\xe \v SYSPARAM_NO_RESOURCE\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_NO_RESOURCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSPARAM_NO_RESOURCE\~ 6}
}\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
out of resources \par
\par
\par
}
{\xe \v SYSPARAM_NOT_INIT\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_NOT_INIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSPARAM_NOT_INIT\~ 1}
}\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
xxxSysParamInit not called \par
\par
\par
}
{\xe \v SYSPARAM_NOT_SUPPORTED\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_NOT_SUPPORTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSPARAM_NOT_SUPPORTED\~ 8}
}\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
operation not supported \par
\par
\par
}
{\xe \v SYSPARAM_READ_ONLY\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_READ_ONLY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSPARAM_READ_ONLY\~ 5}
}\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
parameter is read only \par
\par
\par
}
{\xe \v SYSPARAM_SMB_BUS_FLASH\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_SMB_BUS_FLASH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSPARAM_SMB_BUS_FLASH\~ 0xff}
}\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
fake SMB bus number for SYSPARAM_MMSMB_INIT.eeXXX functions: use flash \par
\par
\par
}
{\xe \v SYSPARAM_VAL_TRUNCATED\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_VAL_TRUNCATED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSPARAM_VAL_TRUNCATED\~ 7}
}\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
value has been truncated \par
\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v SYSP_COMMODE_VALUES_IDX\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_COMMODE_VALUES_IDX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef \{ ... \}   {\b SYSP_COMMODE_VALUES_IDX}}
}\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
index in SYSP_nspeedValue match SYSP_comModeValue[] entries \par
\par
\par
}
{\xe \v SYSP_CONST_STRING\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_CONST_STRING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef const char* {\b SYSP_CONST_STRING}}
}\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
a pointer to a const string \par
\par
\par
}
{\xe \v SYSP_NSPEED_VALUES_IDX\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NSPEED_VALUES_IDX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef \{ ... \}   {\b SYSP_NSPEED_VALUES_IDX}}
}\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
index in SYSP_nspeedValue match SYSP_nspeedValue[] entries \par
\par
\par
}
{\xe \v SYSP_POST_PROCESS_CB\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_POST_PROCESS_CB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int(* {\b SYSP_POST_PROCESS_CB})( const char *parName, int attr, int errCode)}
}\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
callback type to post process parameter changes \par
\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}
}\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
index in SYSP_nspeedValue match SYSP_nspeedValue[] entries \par
\par
{{{\b \par
Enumeration values: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v SYSP_NSPEED_AUTO\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NSPEED_AUTO}
{\b {\i {\i SYSP_NSPEED_AUTO}{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
}}  auto \par
{\xe \v SYSP_NSPEED_10HD\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NSPEED_10HD}
{\b {\i {\i SYSP_NSPEED_10HD}{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
}}  10MBit/s half duplex \par
{\xe \v SYSP_NSPEED_10FD\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NSPEED_10FD}
{\b {\i {\i SYSP_NSPEED_10FD}{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
}}  10MBit/s full duplex \par
{\xe \v SYSP_NSPEED_100HD\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NSPEED_100HD}
{\b {\i {\i SYSP_NSPEED_100HD}{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
}}  100MBit/s half duplex \par
{\xe \v SYSP_NSPEED_100FD\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NSPEED_100FD}
{\b {\i {\i SYSP_NSPEED_100FD}{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
}}  100MBit/s full duplex \par
{\xe \v SYSP_NSPEED_1000\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NSPEED_1000}
{\b {\i {\i SYSP_NSPEED_1000}{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
}}  1000MBit/s \par
}
\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}
}\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
index in SYSP_nspeedValue match SYSP_comModeValue[] entries \par
\par
{{{\b \par
Enumeration values: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v SYSP_COMMODE_RS422\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_COMMODE_RS422}
{\b {\i {\i SYSP_COMMODE_RS422}{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
}}  RS422 (has uncritical voltage level). \par
{\xe \v SYSP_COMMODE_RS232\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_COMMODE_RS232}
{\b {\i {\i SYSP_COMMODE_RS232}{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
}}  RS232 mode. \par
{\xe \v SYSP_COMMODE_RS485\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_COMMODE_RS485}
{\b {\i {\i SYSP_COMMODE_RS485}{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
}}  RS485 mode. \par
}
\par
}
{\xe \v SYSPARAM_ACC_ATTR\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_ACC_ATTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SYSPARAM_ACC_ATTR}}
}\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
parameter access attributes \par
Returned in the {\b SYSPARAM_PARAM_INFO} structure by {\b SysParamEnum()}\par
(some flags can be binary ORed) \par
{{{\b \par
Enumeration values: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v SYSPARAM_ACC_RO\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_ACC_RO}
{\b {\i {\i SYSPARAM_ACC_RO}{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
}}  read-only for user, writeable from firmware \par
{\xe \v SYSPARAM_ACC_RW\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_ACC_RW}
{\b {\i {\i SYSPARAM_ACC_RW}{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
}}  read/write \par
{\xe \v SYSPARAM_ACC_PW\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_ACC_PW}
{\b {\i {\i SYSPARAM_ACC_PW}{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
}}  read-only, writeable with password \par
{\xe \v SYSPARAM_ACC_RW_MASK\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_ACC_RW_MASK}
{\b {\i {\i SYSPARAM_ACC_RW_MASK}{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
}}  mask for above flags \par
{\xe \v SYSPARAM_ACC_ENCRYPT\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_ACC_ENCRYPT}
{\b {\i {\i SYSPARAM_ACC_ENCRYPT}{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
}}  parameter shall be displayed encrypted \par
{\xe \v SYSPARAM_ACC_NEEDRESET\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_ACC_NEEDRESET}
{\b {\i {\i SYSPARAM_ACC_NEEDRESET}{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
}}  parameter needs reset to take effect \par
{\xe \v SYSPARAM_ACC_MMPARASTR\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_ACC_MMPARASTR}
{\b {\i {\i SYSPARAM_ACC_MMPARASTR}{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
}}  parameter is part of MENMON parameter string \par
{\xe \v SYSPARAM_ACC_PERSISTANT\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_ACC_PERSISTANT}
{\b {\i {\i SYSPARAM_ACC_PERSISTANT}{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
}}  parameter can be saved non-volatile \par
}
\par
}
{\xe \v SYSPARAM_SET_ATTR\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_SET_ATTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SYSPARAM_SET_ATTR}}
}\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
attributes for SysParamSetEx (can be binary ORed) \par
\par
{{{\b \par
Enumeration values: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v SYSPARAM_SA_NON_PERSISTANT\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_SA_NON_PERSISTANT}
{\b {\i {\i SYSPARAM_SA_NON_PERSISTANT}{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
}}  don't immediately write to NVS \par
{\xe \v SYSPARAM_SA_FROM_FIRMWARE\:sysparam2.h}
{\xe \v sysparam2.h\:SYSPARAM_SA_FROM_FIRMWARE}
{\b {\i {\i SYSPARAM_SA_FROM_FIRMWARE}{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
}}  attempt to set from firmware \par
}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v A12SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:A12SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int A12SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for A12. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v D602SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:D602SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int D602SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initblk})}
}\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v EM01_SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:EM01_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EM01_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EM01. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v EM03_SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:EM03_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EM03_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EM03. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Em04ASysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:Em04ASysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Em04ASysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EM04A. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Em04SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:Em04SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Em04SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EM04. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v EM09_SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:EM09_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EM09_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EM09. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v EP01_SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:EP01_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EP01_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EP01. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v Ep04SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:Ep04SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Ep04SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for EP04. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v EP05_SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:EP05_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EP05_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v EP06_SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:EP06_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EP06_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initblk})}
}\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v F302_SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:F302_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int F302_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for f302. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v F6SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:F6SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int F6SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initblk})}
}\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v KM01_SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:KM01_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int KM01_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initblk})}
}\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v P504SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:P504SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int P504SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for P504. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v PP01_SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:PP01_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PP01_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initblk})}
}\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v Sc15aSysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:Sc15aSysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Sc15aSysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for SC15A. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SC20_SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:SC20_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SC20_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initBlk})}
}\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize SYSPARAM for SC20. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i initBlk} {\b IN}  SYSPARAM initialisation structure for MENMON/SMB implementations. Caller can destroy {\i initBlk}  after this call has finished\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code if fatal error \par
}\par
\par
}
{\xe \v SYSP_AllocInfo\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_AllocInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SYSP_AllocInfo (int * {\i availP}, int * {\i minAvailP})}
}\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get allocator info. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i availP} {\b OUT}  receices currently available mem \par
{\i minAvailP} {\b OUT}  receices minimum available mem \par
}
\par
\par
}
{\xe \v SYSP_BuspciName\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_BuspciName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* SYSP_BuspciName (char * {\i buf}, int {\i ifNum})}
}\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_FromRawEth\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_FromRawEth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_FromRawEth (char * {\i dest}, int {\i destLen}, void * {\i src})}
}\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
from ethernet MAC number returns empty string if all bytes are 0xff \par
\par
\par
}
{\xe \v SYSP_MenBrdNameWithModel\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MenBrdNameWithModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MenBrdNameWithModel (char {\i prefix}, char * {\i buf})}
}\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Determine chars 3..9 (e.g. \par
EM04-00) of MEN product name\par
Uses SYSP_brd and SYSP_brdmod parameter. SYSP_brd value is padded with '-' if it contains only 4 chars\par
If SYSP_brd not valid, return empty string. If SYSP_brdmod not valid, model number will be missing from string\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i prefix} {\b IN}  board prefix (e.g. 'c') (0 if none) \par
{\i buf} {\b OUT}  filled with name (must have space for 7 chars + EOS)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_MenBrdProdString\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MenBrdProdString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MenBrdProdString (char {\i prefix}, char * {\i buf})}
}\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Make full production data string. \par
Generates a string like this: EM04-00, Rev 01.02.03, Serial 8765\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i prefix} {\b IN}  board prefix (e.g. 'c') (0 if none) \par
{\i buf} {\b OUT}  filled with name (must have space for approx. 40 chars)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_MmNetIfParamsScan\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MmNetIfParamsScan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_MmNetIfParamsScan (void)}
}\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Scan list of network interfaces and create parameter groups for them. \par
Should be called after all interfaces have been defined/attached in MMBIOS \par
\par
}
{\xe \v SYSP_NmacName\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NmacName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* SYSP_NmacName (char * {\i buf}, int {\i ifNum})}
}\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_NspeedName\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NspeedName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* SYSP_NspeedName (char * {\i buf}, int {\i ifNum})}
}\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_NvsEnum\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NvsEnum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsEnum (int {\i idx}, {\b SYSPARAM_NVS_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enumerate NVS sections. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i idx} {\b IN}  nth section to query \par
{\i info} {\b OUT}  filled with info about NVS section\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 if ok (section found), or SYSPARAM_INVAL_VALUE if {\i idx}  out of range \par
}\par
\par
}
{\xe \v SYSP_NvsReadRaw\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NvsReadRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsReadRaw ({\b SYSP_CONST_STRING} {\i nvsName}, int {\i offset}, int {\i size}, u_int8 * {\i data})}
}\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Read raw from specified NVS section. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvsName} {\b IN}  NVS section name to read from \par
{\i offset} {\b IN}  starting byte offset within NVS \par
{\i size} {\b IN}  number of bytes to read from NVS \par
{\i data} {\b OUT}  receives read data \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code \par
}\par
\par
}
{\xe \v SYSP_NvsWriteRaw\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_NvsWriteRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_NvsWriteRaw ({\b SYSP_CONST_STRING} {\i nvsName}, int {\i offset}, int {\i size}, const u_int8 * {\i data})}
}\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Write specified NVS section. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i nvsName} {\b IN}  NVS section to write\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}\par
\par
}
{\xe \v SYSP_PostProcessingHookInstall\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_PostProcessingHookInstall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_PostProcessingHookInstall ({\b SYSP_POST_PROCESS_CB} {\i cb})}
}\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Configure one additional postprocessing function. \par
This function is called from SysParamSet whenever a parameter's value is changed (regardless if the change was marked persistent)\par
Overwrites any hook previously installed \par
\par
}
{\xe \v SYSP_PrefixParamName\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_PrefixParamName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* SYSP_PrefixParamName (char {\i prefix}, const char * {\i parName}, char * {\i buf})}
}\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Build prefixed parameter name (e.g. \par
for carrier boards)\par
If prefix non-zero, build parameter "x-param", where x is the prefix\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i prefix} {\b IN}  board prefix (e.g. 'c') (0 if none) \par
{\i buf} {\b OUT}  filled with name (must have enough space) \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid buf \par
}\par
\par
}
{\xe \v SYSP_StringArrayLen\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_StringArrayLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StringArrayLen (const {\b SYSP_CONST_STRING} * {\i arr})}
}\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Count number of string pointers in array until NULL pointer found. \par
\par
\par
}
{\xe \v SYSP_StringArrCopy\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_StringArrCopy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StringArrCopy ({\b SYSP_CONST_STRING} {\i dst}[], const {\b SYSP_CONST_STRING} {\i src}[], int {\i max})}
}\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
copy stringtable {\i src}  to stringtbl {\i dst}  \par
Copy {\i max}  entries (excl. NULL terminator), make sure that {\i dst}  is NULL terminated\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid number of entries copied (excluding NULL terminator) \par
}\par
\par
}
{\xe \v SYSP_StringArrFindStr\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_StringArrFindStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StringArrFindStr (const {\b SYSP_CONST_STRING} * {\i arr}, {\b SYSP_CONST_STRING} {\i str})}
}\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Check if string array {\i contains}  a string with the same value as {\i str}  {\i arr}  must be NULL terminated. \par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid index in {\i arr}  or -1 if not found \par
}\par
\par
}
{\xe \v SYSP_StrSafeCpy\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_StrSafeCpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_StrSafeCpy (char * {\i dst}, const char * {\i src}, int {\i destLen})}
}\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ToRawEth\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_ToRawEth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_ToRawEth (void * {\i dest}, const char * {\i src})}
}\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
to ethernet MAC number \par
\par
\par
}
{\xe \v SYSP_TusParamGet\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_TusParamGet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SYSP_TusParamGet (const char * {\i tus}, int {\i tusMaxLen}, const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get value of parameter {\i parName}  from tuple string. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i tus} {\b IN}  tuple parameter string \par
{\i tusMaxLen} {\b IN}  max length of tuple string (incl. term. 0) \par
{\i parName} {\b IN}  parameter name to search for \par
{\i parVal} {\b OUT}  receives parameter value as a string \par
{\i parValMaxLen} {\b IN}  max length of parVal (including terminating 0)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 if parameter found, or \par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_INVAL_PARAM - if parameter not found\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_INVAL_VALUE - parVal not NULL and parValMaxLen==0\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
SYSPARAM_VAL_TRUNCATED - if parVal too small \par
}
\par
}\par
\par
}
{\xe \v SysParamBool\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamBool (const char * {\i par}, int {\i def})}
}\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get value of boolean system parameter. \par
On error, or when parameter is empty, default value {\i def}  is applied.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i def} {\b IN}  default value (0/1)\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid value of system parameter or {\i def}  on error \par
}\par
\par
}
{\xe \v SysParamDefSignedInt\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamDefSignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamDefSignedInt (const char * {\i par}, int {\i base}, int32 {\i def}, int32 * {\i valueP})}
}\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get default value of signed integer system parameter. \par
On error, or when parameter is empty, default value {\i def}  is applied. If parameter is empty, no error is returned.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i base} {\b IN}  radix 10 or 16 \par
{\i def} {\b IN}  default value (if parameter/value invalid) \par
{\i valueP} {\b OUT}  receives value of system parameter\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamGet} \par
}\par
\par
}
{\xe \v SysParamDefUnsignedInt\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamDefUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamDefUnsignedInt (const char * {\i par}, int {\i base}, u_int32 {\i def}, u_int32 * {\i valueP})}
}\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SysParamEnum\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamEnum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamEnum (int {\i idx}, int {\i alias}, {\b SYSPARAM_PARAM_INFO} * {\i info})}
}\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enumerate all parameters of Sysparam. \par
Writes info about parameter specified by {\i idx}  to {\i info} .\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i idx} {\b IN}  the nth parameter to query \par
{\i alias} {\b IN}  if TRUE, return alias name \par
{\i info} {\b OUT}  receives the parameter name and the parameter's access attributes\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_VALUE} if {\i idx}  out of range \par
}
\par
}\par
\par
}
{\xe \v SysParamErrStr\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamErrStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* SysParamErrStr (int {\i errCode})}
}\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Convert SYSPARAM error code to string. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i errCode} {\b IN}  SYSPARAM error code\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Error string \par
}\par
\par
}
{\xe \v SysParamGet\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamGet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamGet (const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get value of single system parameter. \par
This gets the current value of the parameter {\i parName} . Parameter name can be either the official parameter name or the alias name.\par
If {\b SysParamGet()} returns non-zero, {\i parVal}  will contain an empty string (unless {\i parValMaxLen}  is {\f2 0} ).\par
If the parameter value (as a string) is longer than {\i parValMaxLen} , string in {\i parVal}  is truncated. {\i parVal}  is always guaranteed to be null-terminated.\par
{\i parVal}  may contain blanks.\par
This function can be used to probe for the existance of a parameter name. Pass {\i parVal}  as NULL and parValMaxLen as 0 in this case.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i parVal} {\b OUT}  receives the parameter's value as a string \par
{\i parValMaxLen} {\b IN}  maximum bytes that {\i parVal}  can hold, including the terminating '\\0'\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: parameter is not known\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_VALUE}: parValMaxLen is 0 and {\i parVal}  is not NULL. Or internal representation is damaged\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_VAL_TRUNCATED}: only a part of value could be copied to {\i parVal}  (and {\i parVal}  was not NULL) \par
}
\par
}\par
\par
}
{\xe \v SysParamGetAll\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamGetAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamGetAll (char * {\i buf}, int {\i bufLen}, int {\i alias})}
}\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get all parameters with their values. \par
Build a string containing all known parameters and their values.\par
Each parameter/value tuple is put into a separate line.\par
If a tuple does not fit as a whole in {\i buf} , it is omitted.\par
Example: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \par
brd=EM04\\n\par
kerpar=ip=auto rw\\n\par
e=192.1.1.22:FFFFFF00\\n\par
mmstartup=\\n\par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i buf} {\b OUT}  receives the all parameter/value pairs as a string \par
{\i bufLen} {\b IN}  maximum bytes that {\i buf}  can hold, including the terminating '\\0' \par
{\i alias} {\b IN}  if TRUE, return the alias parameter names rather than the official names\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_VAL_TRUNCATED}: only a part of pairs could be copied to {\i buf}  \par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NO_RESOURCE}: Could not allocate temp. buffer \par
}
\par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamEnum} \par
}\par
\par
}
{\xe \v SysParamGetDefault\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamGetDefault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamGetDefault (const char * {\i parName}, char * {\i parVal}, int {\i parValMaxLen})}
}\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get default value of single system parameter. \par
This gets the {\b default}  value of the parameter {\i parName} . Parameter name can be either the official parameter name or the alias name.\par
This is currently not supported by all types of parameters, If it is not supported, {\b SYSPARAM_INVAL_VALUE} is returned\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i parVal} {\b OUT}  receives the parameter's value as a string \par
{\i parValMaxLen} {\b IN}  maximum bytes that {\i parVal}  can hold, including the terminating '\\0'\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: parameter is not known\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_VALUE}: parValMaxLen is 0 and {\i parVal}  is not NULL. Or default value not available\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_VAL_TRUNCATED}: only a part of value could be copied to {\i parVal}  (and {\i parVal}  was not NULL) \par
}
\par
}\par
\par
}
{\xe \v SysParamHelp\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamHelp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamHelp (const char * {\i parName}, {\b SYSPARAM_PARAM_HELP} * {\i parHelp})}
}\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get help strings for standard parameter. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i parHelp} {\b OUT}  filled with info about parameter name\par
}
On error, all fields of {\i parHelp}  are filled with zeroes\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: parameter is not known \par
}
\par
}\par
\par
}
{\xe \v SysParamMakePersistant\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamMakePersistant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamMakePersistant (const char * {\i parName})}
}\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Write temporary changes to NV storage. \par
Make temporary changes persistant. Temporary changes are those made by calls to {\b SysParamSetEx()} with {\b SYSPARAM_SA_NON_PERSISTANT} flag set.\par
This function can either write all parameter groups (if {\i parName}  is NULL) or a specific parameter group (in this case parName must specify a parameter of that group).\par
For example, to save the VxWorks bootline parameter group to NV storage, call SysParamMakePersistant("s").\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix.\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: {\i parName}  is not NULL and is not known\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_EEPROM_ERROR}: Error during NVS update\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_READ_ONLY}: Specified parameter cannot be made persistant \par
}
\par
}\par
\par
}
{\xe \v SysParamNumParams\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamNumParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamNumParams (int * {\i numP})}
}\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get total number of parameters handled by Sysparam. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i *numP} {\b OUT}  receives number of parameters\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid SYSPARAM error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called \par
}
\par
}\par
\par
}
{\xe \v SysParamSet\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamSet (const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd})}
}\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Modify value of single system parameter. \par
This updates the internal representation of the specified parameter {\i parName}  and the parameter is written to non-volatile storage.\par
It is a shortcut to {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  SysParamSetEx( parName, parVal, passwd, 0 ); \par
}
\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i parVal} {\b IN}  new value for parameter as a string \par
{\i passwd} {\b IN}  an optional password for protected parameters can be NULL if parameter is not protected\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: parameter is not known\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_VALUE}: invalid value for parameter or {\i parVal}  too long\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_EEPROM_ERROR}: Error during NVS update\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_READ_ONLY}: Parameter is read only or bad password was specified.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NO_RESOURCE}: {\i parVal}  could not be stored due to lack of space (in NV storage or temp. buffers).\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_VAL_TRUNCATED}: only parts of {\i parVal}  have been stored.\par
}
\par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamSetEx} \par
}\par
\par
}
{\xe \v SysParamSetDefaults\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamSetDefaults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamSetDefaults (void)}
}\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set all non volatile parameters to defaults. \par
All parameter groups that are stored in non volatile storage are set to their default values and are written into NV storage.\par
Inventory/production parameter groups are not modified by this call.\par
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_EEPROM_ERROR}: Error during NVS update \par
}
\par
}\par
\par
}
{\xe \v SysParamSetEx\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamSetEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamSetEx (const char * {\i parName}, const char * {\i parVal}, const char * {\i passwd}, int {\i attr})}
}\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Modify value of single system parameter (extended version). \par
This updates the internal representation of the specified parameter {\i parName} . Parameter name can be either the official parameter name or the alias name.\par
If {\b SYSPARAM_SA_NON_PERSISTANT} is not specified in {\i attr} , the parameter is also written into non volatile storage (NVS).\par
If {\b SYSPARAM_SA_NON_PERSISTANT} is given, NVS is not updated. NVS can be updated by another call to SysParamSetEx for a parameter in the same parameter group (with SYSPARAM_SA_NON_PERSISTANT clear) or by calling {\b SysParamMakePersistant()}.\par
Parameters that are read-only for the normal user can be written to by specifying attribute {\b SYSPARAM_SA_FROM_FIRMWARE} in {\i attr} . This flag should be set only when called from firmware.\par
A parameter's value can be cleared by passing an empty string ("") in {\i parVal} .\par
{\b Restart when production data name has changed}  When modifying the name of a production data section ("brd" parameter), the SYSPARAM library is entirely restarted, since the new name may imply a new EEPROM layout. After SYSPARAM has been restart (which is invisible to the user) the available parameters may have changed. Modifying the board name is only possible with {\b SYSPARAM_SA_NON_PERSISTANT} flag cleared.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i parVal} {\b IN}  new value for parameter as a string \par
{\i passwd} {\b IN}  an optional password for protected parameters can be NULL if parameter is not protected \par
{\i attr} {\b IN}  attribute flags (see {\b SYSPARAM_SET_ATTR})\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 on success, or sysparam error code\par
{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NOT_INIT}: xxxSysParamInit() has not been called\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_PARAM}: parameter is not known\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_INVAL_VALUE}: invalid value for parameter or {\i parVal}  too long\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_EEPROM_ERROR}: Error during NVS update\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_READ_ONLY}: Parameter is read only and {\b SYSPARAM_SA_FROM_FIRMWARE} was not set in {\i attr} , or bad password was specified.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_NO_RESOURCE}: {\i parVal}  could not be stored due to lack of space (in NV storage or temp. buffers).\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
{\b SYSPARAM_VAL_TRUNCATED}: only parts of {\i parVal}  have been stored. \par
}
\par
}\par
\par
}
{\xe \v SysParamSetFmt\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamSetFmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamSetFmt (const char * {\i parName}, const char * {\i passwd}, int {\i attr}, const char * {\i fmt}, ...)}
}\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set system parameter using printf style arguments. \par
{{\b \par
Warning:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Formatted string may not exceed 40 chars!\par
}{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i passwd} {\b IN}  an optional password for protected parameters can be NULL if parameter is not protected \par
{\i attr} {\b IN}  attribute flags (see {\b SYSPARAM_SET_ATTR}) \par
{\i fmt} {\b IN}  printf like format string \par
{\i ...} {\b IN}  arguments for format\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamSetEx} \par
}\par
\par
}
{\xe \v SysParamSignedInt\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamSignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamSignedInt (const char * {\i par}, int {\i base}, int32 {\i def}, int32 * {\i valueP})}
}\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get value of signed integer system parameter. \par
On error, or when parameter is empty, default value {\i def}  is applied. If parameter is empty, no error is returned.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i base} {\b IN}  radix 10 or 16 \par
{\i def} {\b IN}  default value \par
{\i valueP} {\b OUT}  receives value of system parameter\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamGet} \par
}\par
\par
}
{\xe \v SysParamUnsignedInt\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamUnsignedInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamUnsignedInt (const char * {\i par}, int {\i base}, u_int32 {\i def}, u_int32 * {\i valueP})}
}\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get value of unsigned integer system parameter. \par
On error, or when parameter is empty, default value {\i def}  is applied. If parameter is empty, no error is returned.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i base} {\b IN}  radix 10 or 16 \par
{\i def} {\b IN}  default value \par
{\i valueP} {\b OUT}  receives value of system parameter\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamGet} \par
}\par
\par
}
{\xe \v SysParamUnsignedIntArray\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamUnsignedIntArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SysParamUnsignedIntArray (const char * {\i par}, int {\i base}, int {\i no}, u_int32 * {\i defP}, u_int32 * {\i valueP})}
}\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get array of unsigned integer system parameters. \par
On error, or when parameter is empty, default value {\i def}  is applied. If parameter is empty, no error is returned.\par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i parName} {\b IN}  parameter name including possible prefix. \par
{\i base} {\b IN}  radix 10 or 16 \par
{\i no} {\b IN}  number of array elements \par
{\i def} {\b IN}  default values \par
{\i valueP} {\b OUT}  receives value of system parameter\par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid sysparam error code \par
}{{\b \par
See also:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b SysParamGet} \par
}\par
\par
}
{\xe \v SysParamVxBootParamsPrompt\:sysparam2.h}
{\xe \v sysparam2.h\:SysParamVxBootParamsPrompt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SysParamVxBootParamsPrompt (void)}
}\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Interactive VxBline modification in MENMON. \par
Display the current value of each parameter and prompt for a new value. Typing a RETURN leaves the parameter unchanged. Typing a period (.) clears the parameter. ^D exits. A '-' edits the previous field\par
This locates the "vxbline" parameter section by using the global {\i SYSP_super}  pointer.\par
After modification done, modified vxBline is saved to NVS storage, and vxBline string has been updated in memory \par
\par
}
{\xe \v VC01_SysParamInit\:sysparam2.h}
{\xe \v sysparam2.h\:VC01_SysParamInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int VC01_SysParamInit (const {\b SYSPARAM_MMSMB_INIT} * {\i initblk})}
}\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v SYSP_baud\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_baud}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_baud}[]}
}\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_bf\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_bf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_bf}[]}
}\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_bootfile\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_bootfile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_bootfile}[]}
}\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_brd\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_brd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_brd}[]}
}\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_brdmod\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_brdmod}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_brdmod}[]}
}\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_brdrev\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_brdrev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_brdrev}[]}
}\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_bs\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_bs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_bs}[]}
}\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_bsadr\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_bsadr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_bsadr}[]}
}\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_buspci0\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_buspci0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_buspci0}[]}
}\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_buspci1\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_buspci1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_buspci1}[]}
}\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_buspci2\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_buspci2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_buspci2}[]}
}\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_cbr\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_cbr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_cbr}[]}
}\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_clun\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_clun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_clun}[]}
}\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_comModeValue\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_comModeValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_comModeValue}[]}
}\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_con0\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_con0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_con0}[]}
}\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_con1\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_con1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_con1}[]}
}\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_con2\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_con2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_con2}[]}
}\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_con3\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_con3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_con3}[]}
}\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_cons\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_cons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_cons}[]}
}\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_cpu\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_cpu}[]}
}\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_cpuclkhz\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_cpuclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_cpuclkhz}[]}
}\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_dlun\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_dlun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_dlun}[]}
}\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ecl\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_ecl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_ecl}[]}
}\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_esm_cb_hwflag\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_esm_cb_hwflag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_esm_cb_hwflag}[]}
}\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_esm_cb_partnum\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_esm_cb_partnum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_esm_cb_partnum}[]}
}\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_flash0\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_flash0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_flash0}[]}
}\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_flash1\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_flash1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_flash1}[]}
}\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_fpga\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_fpga}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_fpga}[]}
}\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_fram0\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_fram0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_fram0}[]}
}\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_gcon\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_gcon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_gcon}[]}
}\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_gstatshow\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_gstatshow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_gstatshow}[]}
}\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_hdp\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_hdp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_hdp}[]}
}\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_kerpar\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_kerpar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_kerpar}[]}
}\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_ldlogodis\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_ldlogodis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_ldlogodis}[]}
}\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mem0\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_mem0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mem0}[]}
}\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mem1\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_mem1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mem1}[]}
}\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_memclkhz\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_memclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_memclkhz}[]}
}\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mm\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_mm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mm}[]}
}\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mm_pmm\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_mm_pmm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mm_pmm}[]}
}\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mm_smm\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_mm_smm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mm_smm}[]}
}\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mmst\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_mmst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mmst}[]}
}\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_mmstartup\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_mmstartup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_mmstartup}[]}
}\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC52XX_inclkhz\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MPC52XX_inclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC52XX_inclkhz}[]}
}\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC52XX_ipbclkhz\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MPC52XX_ipbclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC52XX_ipbclkhz}[]}
}\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC52XX_xlbclkhz\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MPC52XX_xlbclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC52XX_xlbclkhz}[]}
}\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC83XX_ceclkhz\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MPC83XX_ceclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC83XX_ceclkhz}[]}
}\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC83XX_csbclkhz\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MPC83XX_csbclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC83XX_csbclkhz}[]}
}\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC83XX_inclkhz\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MPC83XX_inclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC83XX_inclkhz}[]}
}\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC85XX_brgclkhz\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MPC85XX_brgclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC85XX_brgclkhz}[]}
}\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC85XX_ccbclkhz\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MPC85XX_ccbclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC85XX_ccbclkhz}[]}
}\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_MPC85XX_immr\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_MPC85XX_immr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_MPC85XX_immr}[]}
}\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_netaddr\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_netaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_netaddr}[]}
}\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_netgw\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_netgw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_netgw}[]}
}\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nethost\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_nethost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nethost}[]}
}\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_netip\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_netip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_netip}[]}
}\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_netname\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_netname}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_netname}[]}
}\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_netsm\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_netsm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_netsm}[]}
}\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nmac0\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_nmac0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nmac0}[]}
}\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nmac1\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_nmac1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nmac1}[]}
}\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nmac2\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_nmac2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nmac2}[]}
}\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nmac3\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_nmac3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nmac3}[]}
}\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nobanner\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_nobanner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nobanner}[]}
}\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_normalboot\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_normalboot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_normalboot}[]}
}\par
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nspeed0\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_nspeed0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nspeed0}[]}
}\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nspeed1\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_nspeed1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nspeed1}[]}
}\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nspeed2\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_nspeed2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nspeed2}[]}
}\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nspeed3\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_nspeed3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_nspeed3}[]}
}\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_nspeedValue\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_nspeedValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* {\b SYSP_nspeedValue}[]}
}\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_pciclkhz\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_pciclkhz}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_pciclkhz}[]}
}\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_prodat\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_prodat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_prodat}[]}
}\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rand\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rand}[]}
}\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_repdat\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_repdat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_repdat}[]}
}\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rststat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat}[]}
}\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_cb\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rststat_cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_cb}[]}
}\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_hrst\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rststat_hrst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_hrst}[]}
}\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_pdrop\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rststat_pdrop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_pdrop}[]}
}\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_pwon\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rststat_pwon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_pwon}[]}
}\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_rbut\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rststat_rbut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_rbut}[]}
}\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_srst\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rststat_srst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_srst}[]}
}\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_sw\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rststat_sw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_sw}[]}
}\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_temp\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rststat_temp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_temp}[]}
}\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_unknown\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rststat_unknown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_unknown}[]}
}\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_rststat_wdog\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_rststat_wdog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_rststat_wdog}[]}
}\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_sernbr\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_sernbr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_sernbr}[]}
}\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_startup\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_startup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_startup}[]}
}\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stdis\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_stdis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stdis}[]}
}\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stdis_ether\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_stdis_ether}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stdis_ether}[]}
}\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stdis_nand\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_stdis_nand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stdis_nand}[]}
}\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stdis_usb\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_stdis_usb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stdis_usb}[]}
}\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stdis_wdog\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_stdis_wdog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stdis_wdog}[]}
}\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stignfault\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_stignfault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stignfault}[]}
}\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_stwait\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_stwait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_stwait}[]}
}\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_tdp\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_tdp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_tdp}[]}
}\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_tries\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_tries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_tries}[]}
}\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_tto\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_tto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_tto}[]}
}\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_updcdis\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_updcdis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_updcdis}[]}
}\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_usbdp\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_usbdp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_usbdp}[]}
}\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_useflpar\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_useflpar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_useflpar}[]}
}\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_vmode\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_vmode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_vmode}[]}
}\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v SYSP_wdt\:sysparam2.h}
{\xe \v sysparam2.h\:SYSP_wdt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char {\b SYSP_wdt}[]}
}\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
SYSPARAM2 Page Documentation{\tc \v Page Documentation}
\par \pard\plain 
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v API Differences to original SYSPARAM lib}
API Differences to original SYSPARAM lib\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid New API routines:\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Users must include {\b sysparam2.h} rather sysparam.h\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
New API routine {\b SysParamSetEx()} to{
\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
set parameter without writing it to non volatile storage\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
set read-only parameter from firmware\par
}
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
New API routine {\b SysParamSetFmt()} to generate a value with printf arguments\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
New API routine {\b SysParamNumParams()} and {\b SysParamEnum()} to enumerate parameters\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
New API routine {\b SysParamMakePersistant()} to save all or a group of parameters\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
New API routine {\b SysParamErrStr()} to convert error code to string\par
}
\par
Different behaviour:{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Parameters in production data section are visible to {\b SysParamGet()} and {\b SysParamEnum()} even if the production data section is not valid. {\b SysParamGet()} returns {\b SYSPARAM_INVAL_VALUE} in this case\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Parameter {\i vxBlineFromEeprom}  to xxxSysParamInit() function removed. vxBline is now read from EEPROM when it contains an empty string\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
vxBline can now be passed a default value (through {\b SYSP_VxGrpCreate()})\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamGet()} and {\b SysParamGetAll()} return SYSPARAM_VAL_TRUNCATED if the user's buffer is too small\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamSet()} returns SYSPARAM_VAL_TRUNCATED if not all parameters could be stored in VxWorks bootline\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamSet()} returns SYSPARAM_NO_RESOURCE if a string parameter is too long (value is not changed in this case)\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b SysParamGet()} can be used to test for the existance of a parameter without getting the value by passing parVal as NULL\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
VxWorks bootline handler now supports all VxWorks parameters, i.e. "b", "u", "p", "o", "f"\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Much better parameter validation for {\b SysParamSet()}\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
New parameter {\i alias}  to {\b SysParamGetAll()} to include alias names rather official names in output string \par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Definition of tuple strings}
Definition of tuple strings\par
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Tuple strings are used e.g. in the MENMON parameter string to store multiple parameters with their value in a single ASCII string.\par
The following does not apply to VxWorks bootline, which has a similar, but not identical format.\par
Example for a tuple string: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  "par1=value1 par2='value with blanks' par4=yy"  \par
}
\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Parameter names may consist of ASCII chars [0x21..0x7e], except blanks and '=' chars.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Parameter names are case sensitive\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
A parameter name must not appear more than once in the tuple string\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The equal sign '=' must immediately follow the parameter name\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The parameter value starts after the '=' and ends with the next blank or EOS.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If the value contains blanks, value must be surrounded by ticks '\\''\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Ticks can be nested, but only if each opening tick is preceeded by a '=' character, e.g: {
\par
\pard\plain \s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  "par2='value with blanks subpar='nested value''"  \par
}
\par
}
\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Parameter value may contain ASCII chars [0x20..0x7e]\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Tuples are separated by any number of blanks \par
}
\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}